# MySQL

## 索引

### 1.如何优化查询速度？

>  创建适当的索引，优化查询语句，避免全局扫描，缓存查询结果，提升硬件，数据归档和分离，数据库分片。

**创建适当的索引**

通过创建适当的索引，可以加速查询操作。索引可以提高查询语句的执行效率，尤其是对于常用的查询条件和排序字段进行索引，可以显著减少查询的扫描范围和 IO 开销。

**优化查询语句**

优化查询语句本身，避免全表扫描和大数据量的关联查询。可以优化查询条件，使用合适的索引、合理的查询策略，减少不必要的字段和数据返回。

**缓存查询结果**

对于一些相对稳定的查询结果，可以将其缓存在内存中，避免重复查询数据库，提高查询速度。

缓存的查询速度一定比直接查询数据库的效率高，这是因为缓存具备以下特征：

1. 内存访问速度快：缓存通常将数据存储在内存中，而数据库将数据存储在磁盘上。相比于磁盘访问，内存访问速度更快，可以达到纳秒级别的读取速度，远远快于数据库的毫秒级别的读取速度。
2. IO 操作次数少：数据库通常需要进行磁盘 IO 操作，包括读取和写入磁盘数据。而缓存将数据存储在内存中，避免了磁盘 IO 的开销。内存访问不需要进行磁盘寻址和机械运动，相对来说速度更快。
3. 特殊的数据结构：缓存的数据结构通常为 key-value 形式的，也就是说缓存可以做到任何数据量级下的查询数据复杂度为 O(1)，所以它的查询效率是非常高的；而数据库采用的是传统数据结构设计，可能需要查询二叉树、或全文搜索、或回表查询等操作，所以其查询性能是远低于缓存系统的。

**提升硬件配置**

对于大数据量的表，可以考虑采用更高性能的硬件设备，如更快的存储介质（如固态硬盘），更大的内存容量等，以提升查询的 IO 性能。

**数据归档和分离**

对于历史数据或不经常访问的数据，可以进行归档和分离，将这些数据从主表中独立出来，减少主表的数据量，提高查询速度。

**数据库分片**

当单个数据库无法满足查询性能需求时，可以考虑使用数据库分片技术，将数据分散到多个数据库中，每个数据库只处理部分数据，从而提高查询的并发度和整体性能。

数据库分片技术的具体实现是分库分表。

### 2. 数据库四大特性和四大隔离级别

MySQL 事务具备 ACID 四大特性，如下所述：

1. **原子性（Atomicity）**：事务中的所有操作要么全部执行成功，要么全部失败回滚，不能只执行其中一部分操作。
2. **一致性（Consistency）**：事务执行前后，数据库的完整性约束没有被破坏，数据总是从一个一致性状态转移到另一个一致性状态。
3. **隔离性（Isolation）**：事务之间是相互隔离的，每个事务对其他事务的操作是透明的，一个事务的中间结果对其他事务是不可见的。
4. **持久性（Durability）**：事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失。

其中，隔离性是实现事务的重要特征之一。

MySQL 中提供了四种事务隔离级别：

1. 读未提交（Read Uncommitted）
2. 读已提交（Read Committed）
3. 可重复读（Repeatable Read）
4. 串行化（Serializable）

不同的事务隔离解决可以解决不同的问题，如下图所示：

![img](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/1687165869094-c5f1d452-4af9-4d1f-ab4a-27ecbfd24a2b.png)

### 3. 事务的实现原理

隔离性 ------------------- 通过锁实现
原子性、持久性-------- 通过 redo log（重做日志）实现 。
一致性 ------------------- 通过 undo log（回滚日志）实现 ：



redo log（重做日志） 实现 原子性、持久性

事务提交之后，先将事务写入redo log日志，后续再将 Buffer Pool 中修改数据慢慢写入到磁盘。

此时如果数据库崩溃或者宕机，Buffer Pool 中的数据丢失，可能有部分已修改数据未能同步到磁盘。

那么，当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。


undo log（回滚日志）实现 一致性

undo log记录了数据在操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。


以一个update语句执行为例：

```xml
Innodb引擎在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在 BufferPool 中（也就是内存中）。
执行update语句，修改 BufferPool 中的数据。
针对update语句生成一个 RedoLog 对象，并存入 LoggerBuffer 中。
针对update语句生成 UndoLog 日志，用于事务回滚。
如果提交事务，那么久将 RedoLog 对象进行持久化，后续还有其他机制将 BufferPool 中修改的数据页持久化到磁盘。
如果事务回滚，那么则利用 UndoLog 日志进行数据恢复。
```

### 4. 索引的数据结构，为什么查询快？

MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

1.**B+ 树的非叶子节点不存放实际的记录数据，仅存放索引**，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，**查询底层节点的磁盘 I/O次数会更少。**（为什么不选二叉树也有类似原因)

2.**B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引）**，这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生**复杂的树的变化**；

3.**B+ 树叶子节点之间用链表连接了起来，有利于范围查询**，而 **B 树要实现范围查询，因此只能通过树的遍历**来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

> ![图片](MySQL-面试整理.assets/dd076212a7637b9032c97a615c39dcd7.png)

### 5. 聚簇索引和非聚簇索引对比

**聚簇索引和非聚簇索引的比较**

**查询性能**：聚簇索引通常对范围查询更为高效，因为它将数据按照索引键值的顺序存储。然而，非聚簇索引可能在某些情况下提供更好的性能，特别是当索引覆盖查询所需的所有列时（即覆盖索引）。

**更新开销**：当数据行的键值（即聚簇索引的键值）发生变化时，聚簇索引可能需要重新组织数据的存储顺序，这可能会导致更大的更新开销。而非聚簇索引只需要更新索引条目。

### 6. 数据库中的锁

**基于锁的属性分类：**

 1.**共享锁**（Share Lock，S锁）：当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁主要用于支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。

 2.**排他锁**（Exclusive Lock，X锁）：当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁避免了出现脏数据和脏读的问题。

**基于锁的粒度分类：**

 1.**行级锁**（InnoDB）：对数据库表中的某一行或多行记录进行加锁，使得其他事务在当前事务释放锁之前无法修改这些记录。 2.**表级锁**（InnoDB、MyISAM）：对整个数据库表进行加锁，使得其他事务在当前事务释放锁之前无法对该表进行访问或修改。表级锁包括表共享读锁和表独占写锁。 3.**页级锁**（InnoDB、BDB引擎）：是一种介于行级锁和表级锁之间的锁，它锁定的是数据页而不是整个表或单个行。页级锁在某些情况下可以减少锁的竞争，提高并发性能。 4.**记录锁**：行级锁的一种，单条记录上加的锁。 5.**间隙锁**（InnoDB）：在索引记录之间的间隙上加的锁，主要用于防止两个事务同时向一个范围内插入新的记录，产生幻读的情况。 6.**临键锁**（Next-Key Locks）：是InnoDB的行级锁和间隙锁的结合，即除了锁住记录本身，还要再锁住索引记录前面的间隙。

**基于锁的状态分类：**

 1.意向共享锁（Intention Shared Lock）：事务有意向对表中的某些行加共享锁。 2.意向排他锁（Intention Exclusive Lock）：事务有意向对表中的某些行加排他锁。

**全局锁**： 对整个数据库进行加锁，阻止其他用户对该数据库的访问和修改。例如，当需要让整个数据库进行备份时，可以使用全局锁。但全局锁会严重影响并发性能，应谨慎使用。
