# MySQL

## 索引

### 1.如何优化查询速度？

>  创建适当的索引，优化查询语句，避免全局扫描，缓存查询结果，提升硬件，数据归档和分离，数据库分片。

**创建适当的索引**

通过创建适当的索引，可以加速查询操作。索引可以提高查询语句的执行效率，尤其是对于常用的查询条件和排序字段进行索引，可以显著减少查询的扫描范围和 IO 开销。

**优化查询语句**

优化查询语句本身，避免全表扫描和大数据量的关联查询。可以优化查询条件，使用合适的索引、合理的查询策略，减少不必要的字段和数据返回。

**缓存查询结果**

对于一些相对稳定的查询结果，可以将其缓存在内存中，避免重复查询数据库，提高查询速度。

缓存的查询速度一定比直接查询数据库的效率高，这是因为缓存具备以下特征：

1. 内存访问速度快：缓存通常将数据存储在内存中，而数据库将数据存储在磁盘上。相比于磁盘访问，内存访问速度更快，可以达到纳秒级别的读取速度，远远快于数据库的毫秒级别的读取速度。
2. IO 操作次数少：数据库通常需要进行磁盘 IO 操作，包括读取和写入磁盘数据。而缓存将数据存储在内存中，避免了磁盘 IO 的开销。内存访问不需要进行磁盘寻址和机械运动，相对来说速度更快。
3. 特殊的数据结构：缓存的数据结构通常为 key-value 形式的，也就是说缓存可以做到任何数据量级下的查询数据复杂度为 O(1)，所以它的查询效率是非常高的；而数据库采用的是传统数据结构设计，可能需要查询二叉树、或全文搜索、或回表查询等操作，所以其查询性能是远低于缓存系统的。

**提升硬件配置**

对于大数据量的表，可以考虑采用更高性能的硬件设备，如更快的存储介质（如固态硬盘），更大的内存容量等，以提升查询的 IO 性能。

**数据归档和分离**

对于历史数据或不经常访问的数据，可以进行归档和分离，将这些数据从主表中独立出来，减少主表的数据量，提高查询速度。

**数据库分片**

当单个数据库无法满足查询性能需求时，可以考虑使用数据库分片技术，将数据分散到多个数据库中，每个数据库只处理部分数据，从而提高查询的并发度和整体性能。

数据库分片技术的具体实现是分库分表。

### 2. 数据库四大特性和四大隔离级别

MySQL 事务具备 ACID 四大特性，如下所述：

1. **原子性（Atomicity）**：事务中的所有操作要么全部执行成功，要么全部失败回滚，不能只执行其中一部分操作。
2. **一致性（Consistency）**：事务执行前后，数据库的完整性约束没有被破坏，数据总是从一个一致性状态转移到另一个一致性状态。
3. **隔离性（Isolation）**：事务之间是相互隔离的，每个事务对其他事务的操作是透明的，一个事务的中间结果对其他事务是不可见的。
4. **持久性（Durability）**：事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失。

其中，隔离性是实现事务的重要特征之一。

MySQL 中提供了四种事务隔离级别：

1. 读未提交（Read Uncommitted）
2. 读已提交（Read Committed）
3. 可重复读（Repeatable Read）
4. 串行化（Serializable）

不同的事务隔离解决可以解决不同的问题，如下图所示：

![img](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/1687165869094-c5f1d452-4af9-4d1f-ab4a-27ecbfd24a2b.png)

### 3. 事务的实现原理

隔离性 ------------------- 通过锁实现
原子性、持久性-------- 通过 redo log（重做日志）实现 。
一致性 ------------------- 通过 undo log（回滚日志）实现 ：



redo log（重做日志） 实现 原子性、持久性

事务提交之后，先将事务写入redo log日志，后续再将 Buffer Pool 中修改数据慢慢写入到磁盘。

此时如果数据库崩溃或者宕机，Buffer Pool 中的数据丢失，可能有部分已修改数据未能同步到磁盘。

那么，当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。


undo log（回滚日志）实现 一致性

undo log记录了数据在操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。


以一个update语句执行为例：

```xml
Innodb引擎在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在 BufferPool 中（也就是内存中）。
执行update语句，修改 BufferPool 中的数据。
针对update语句生成一个 RedoLog 对象，并存入 LoggerBuffer 中。
针对update语句生成 UndoLog 日志，用于事务回滚。
如果提交事务，那么久将 RedoLog 对象进行持久化，后续还有其他机制将 BufferPool 中修改的数据页持久化到磁盘。
如果事务回滚，那么则利用 UndoLog 日志进行数据恢复。
```

