### Redis

- **缓存的语义规定**

  - 做缓存，就要遵循缓存的语义规定：
  - 读：读缓存redis，没有，读mysql，并将mysql的值写入到redis。
  - 写：写mysql，成功后，更新或者失效掉缓存redis中的值。

- Redis是一个k-v结构的非关系型数据库，它是一个缓存中间件和数据库

- 为什么需要使用缓存，因为大部分的网站的操作都是读，而每次都去查询数据库如MySQL会十分消耗性能，每次读写数据库都会进行磁盘IO。数据库的本质：读和写

- 而缓存是基于内存的，速度会比直接查询更快

- NoSQL - Not only SQL 不仅仅是SQL。很多类型的信息如：用户的个人信息、社交网络、地理位置。这些数据的格式不需要一个固定的格式，不需要多余的操作就可以横向拓展

- NoSQL有很多特点、

  - 方便拓展 数据之间没有数据。
  - 大数据高性能（Redis一秒可以写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存）
  - 数据类型是多样的，不需要固定数据的数据库设计，随取随用
  - 传统的RDBMS和NoSQL
    - **传统的RDBMS**
    - 结构化组织数据
    - SQL
    - 数据和关系都存储在单独的表中
    - 操作语言：数据定义语言
    - 严格的一致性
    - 基础的事务
    - **NoSQL**
    - 不仅仅是数据库
    - 没有固定的查询语言
    - 键值对、列存储、文档存储、图形存储
    - 最终一致性
    - CAP原理和BASE（异地多活）
    - 高性能、高可用、高可拓

  - **3V 主要是用来描述问题的**
    - 海量 Velume
    - 多样 Variety
    - 实时 Velocity
  - **3高 主要是对程序的要求**
    - 高性能 （保证用户体验）
    - 高可用  - > 高并发
    - 高可拓 （随时可以对系统进行水平拆分或者垂直拆分）

- Redis是单线程的 - 基于IO多路复用模型 - 速度极快 而且CPU不是Redis性能的瓶颈 Redis的性能瓶颈是根据机器的内存和网络带宽决定

- 面试题：为什么Redis是单线程的还那么快？

  - 误区1：高性能的饿服务器一定是多线程的
  - 误区2：多线程（CPU会进行上下文切换） 一定比单线程效率高
  - Redis是把所有的数据都存储在内存中，所以使用单线程效率是最高的。多线程存在CPU的上下文切换，上下文切换的代价时非常昂贵的，对于内存系统来说，如果没有上下文切换性能是最高的。多次读写都是在一个CPU上的，在内存情况下，这个就是最佳方案

- 面试题：Redis的五大数据类型

  - 字符串 strings
  - 散列 hashes   hash可以存储一些变更的数据，尤其是用户信息的保存，和经常变动的信息，hash更加适合存储对象 ，而String更加适合字符串的存储 
  - 列表 list （底层是链表）
  - 集合 sets （内容是不可以重复的）
  - 有序集合 sorted sets （Zset - 底层基于跳表）

- 三种特殊的数据类型

  - geospatial 地理位置 朋友的定位，附近的人，打车举例计算
  - hyperloglog 基数 （不重复的元素）
  - bitmaps 位存储  统计用户信息，活跃，不活跃！登录，未登录 

- Redis的事务

  - 要么同时成功、要么同时失败
  - redis的单条命令是保持原子性的，但是事务不保持原子性
  - redis事务的本质：一个事务中的所有的命令都会被序列化，在事务执行的过程中，会按照顺序执行，一次性、顺序性、排他性
  - redis没有隔离级别的概念
  - **开启事务 （multi）**
  - 命令入队
  - **执行事务（exec）**

- Redis 的配置文件

- 持久化规则

  - 持久化操作，在规定的时间之内，执行了多少次操作，就会持久化到文件 .rdb 和 .aof 文件

  - ```
    # 如果在60秒之内，如果如果至少有 10000 个key进行了修改，就会执行持久化操作
    save 60 10000
    ```

- **RDB**

  - 会存储所有的数据
  - Redis会单独创建（fork）一个子进程来进程持久化。首先，它会将数据写到一个临时文件中去，等待持久化过程结束了，在使用这个临时文件替换上次持久化好的文件，整个过程中，主进程是不执行任何IO操作的，这就保证了极高的性能。如果需要让进行大规模数据恢复，且对于数据库完整性不是特别敏感，那么RDB模式比AOF模式更加高效。RDB的缺点是最后一次持久化的数据可能丢失。默认的情况下就是RDB
  - 优点：适合大规模的数据恢复。对数据库的完整性要求不高
  - 缺点：需要一定的时间间隔操作，如果Redis意外挂机了，数据可能会丢失，最后一次的修改数据可能就没了
  - fork进程的时候，会占用一些内存空间

- **AOF**

  - 会存储所有的执行的命令，在恢复的时候，会把这个文件全部在执行一遍
  - 以日志的形式记录每个写操作，将Redis执行过的命令都记录下来（读操作不记录），只可以追加文件但是不可以修改文件。Redis启动之初，会读取这个文件重建数据。换言之，Redis重启的话，会根据日志文件的内容重新将指令执行一次以完成数据的恢复工作
  - Redis保存的是 appendonly.aof 文件  默认是不开启的
  - aof默认是无限制增加的，可以配置其重写 此时会fork一个新的进程来重写
  - 注意：如果aof被破坏，那就恢复不了了。此时可以进行aof文件恢复 
  - 优点：每次修改都会同步，文件的完整性较好。默认是每秒同步一次。从不同步效率最高
  - 缺点：相对于数据文件来说，aof远大于rdb，因为需要保存所有的操作，但是rdb只保存数据。修复的效率比rdb慢，aof运行的效率也比rdb慢

- Redis订阅发布

  - 消息队列
  - 实时聊天
  - 订阅、关注系统

- **Redis主从复制**

  - 就是将一台Redis服务器的数据，复制到其他的Redis服务器，前着为主节点，后面为从节点。数据的复制是单向的，只能由主节点到从节点。Master以写为主，而Slave以读为主
  - 主从复制的作用
    - 数据冗余：实现数据的热备份，持久化之外的一种冗余方式
    - 故障恢复：当主节点gg之后，可以选择从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余
    - 负载均衡：在主从复制的基础上，配合读写分离，由主节点提供写服务，从节点提供读服务。分担服务器负载，提高Redis服务器的并发
    - 高可用基础（集群）：主从模式是哨兵模式和集群能够实施的基础，主从复制是高可用的基础
    - 一般，项目中只使用一台Redis是不可以的
    - 从结构上，单个Redis服务容易发生单点故障，并发一台服务器需要处理所有的请求，压力较大
    - 从容量上，单个Redis服务器的内存容量有限，就算一台Redis服务器容量为256G，但是也不能把所有的内存都用来存储数据，一般来说，单个机器Redis最大的内存不应该超过20G
  - 最低配置  一主二从
    - 只需要配置从库，因为默认情况下，每个节点都是主节点，所以设置从节点认主节点即可
  - 主从复制的原理
    - 从节点启动成功连接到 master 后会发生一条 sync 同步指令
    - master接到指令，启动后台的存盘进程，同时收集到所有的修改数据集命令，在后台进程执行完毕之后，master 将 **整个数据文件** 传递到从节点，并完成 一次同步
      - 全量复制：从节点在接收到数据库文件之后，将其存盘加载在内存中
      - 增量复制：主节点继续将所有收集的修改命令一次传给从节点，实现同步
    - 但是只要重新连接主节点，一次完全同步将会被执行，我们的数据会在从节点中看到
    - 一主二从的模式 ：
      - A（主）
        - B（从）
        - C（从）
      - A（主）
        - B（从）
          - C（从）
      - 也就是说，第一种吗，从节点都挂在一个主机上，第二种，是从节点的从节点，都不会使用
  - 如果主机宕机 可以手动切换主机

- **哨兵模式**

  - 为了解决主节点宕机
  - 哨兵模式是一种特殊的模式。Redis提供一个独立的进程，作为进程会独立运行
  - **原理：哨兵线程通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。如果发现主节点宕机，就选举从节点为主节点。从而保证主从可用**

- **Redis缓存穿透**

  - 用户想要查询一个数据，发现缓存中也没有，于是继续向持久层数据库查询，发现没有，于是本次查询失败，当用户很多的时候，缓存没有命中，都是请求数据库，这就会给持久层带来很大的压力
  - 解决方案：
    - **布隆过滤器**，对可能查询的参数以hash的形式存储。在控制层先进行校验，符合则通过，不符合就丢弃
    - **缓存空对象** 当存储层中没有命中的时候，即使返回的是空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据就会从缓存中获取，就保护了后端数据源
    - 但是缓存空对象会有新的问题：如果空值可以被缓存起来，那么就意外着存在更多的空间存储控制
    - 即使空指设置了过期时间，还是会存在缓存层的数据会有一段时间窗口不一致，这对于保证一致性的业务会有影响

- **Redis缓存击穿**

  - 缓存一个热点数据过期，然后又大量请求，全部访问数据库查询数据
  - **解决方案**
    - 设置热点数据永不过期
    - 加互斥锁

- **Redis缓存雪崩**

  - 由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原型整体不能提供服务，于是所有的请求都会到达存储层，存储层的调用会暴增，造成存储层宕机
  - **解决方案**
    - 保证缓存层服务器高可用。即使个别节点、个别机器、甚至是机房宕机，依然可以提供服务，如Redis Sentinel 和 Redis Cluster 都实现了高可用
    - 依赖隔离组件为后端限流并降级：缓存失效之后，通过加锁或者队列来空指读数据库中写缓存的线程数量，比如一个key只允许一个线程查询数据和写缓存，其他线程等待
    - 数据预热：可以通过缓存reload机制，预先更新缓存，再即将发生大并发访问之前缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

- **Redis缓存并发**

  - 缓存并发指的是高并发场景下大量查询过期的key、最后查询数据库将缓存结果写回到缓存、造成数据库压力过大

- **分布式锁**

  - 在缓存更新或者过期的情况下，先获取锁，在进行更新或者从数据库中获取数据之后，再释放锁，需要一定的时间等待，就可以从缓存中继续获取数据

- Redis用作分布式锁的应用

- Redis配合RabbitMQ实现削峰和限流降级

- Redis集群实现高可用

- **布隆过滤器**

  - 是bit数组，由0和1组成。如果需要多个不同的hash函数生成多个hash只，并对hash值指定的bit设置为1，但是存在覆盖的风险，所以并不是完全准确的，但是有前人经过测试：0.81%的错误率，还是可以接受的

- **Redis使用场景**

  | 类型   | 适用场景                                    |
  | ------ | ------------------------------------------- |
  | String | 缓存，限流，计数器，分布式锁，分布式session |
  | Hash   | 存储用户信息，用户主页访问量，组合查询      |
  | List   | 微博关注人时间轴列表，简单队列              |
  | Set    | 赞，踩，标签，好友关系                      |
  | Zset   | 排行榜                                      |

  - 或者简单消息队列，发布订阅实施消息系统等等

- **Redis和数据库同步**

  - 如果仅仅是读数据，没有这个问题
  - 如果是新增数据，也没有这个问题
  - 当数据需要更新的时候，如何保证缓存和数据库的双写一致性
  - **三种更新策略**
    - 先更新数据库，再更新缓存
    - 先删除缓存，再更新数据库
    - 先更新数据库，再删除缓存
  - 方案1：并发的时候，执行顺序无法保证，可能A先更新数据库，但是B后更新数据库但是先更新缓存。加锁的话，可以避免，但是这样会导致吞吐量下降，可以根据业务场景考虑
  - 方案2：该方案会导致不一致的原因是。同时有一个请求A进行更新操作。另外一个B进行查询操作，那么会出现以下场景：
    - （1）请求A进行写操作，删除缓存
    - （2）请求B查询发现缓存不存在
    - （3）请求B去数据库查询得到旧值
    - （4）请求B将旧值写入缓存
    - （5）请求A将新的值写入数据库。 
    - **延时双删策略** 。因此采用 延时双删测控，即进入逻辑旧删除key，执行完操作，延时再删除key
  - 方案3：更新数据库 - 删除缓存 - 可能出现的问题场景 
    - （1）缓存刚刚好失效
    - （2）请求A查询数据库，得到一个旧值
    - （3）请求B将新值写入数据库
    - （4）请求B删除缓存
    - （5）请求A将查到的旧值写入缓存
    - 先天条件要求：请求第二步的读取操作耗时要大于更新操作，条件比较苛刻
    - 但是他如果真的发生怎么办？
      - A：给键设置合理的过期时间
      - B：异步延时删除key

- **如何保证Redis数据库都是热点数据？**

  - A：可以通过手工的方式，加载热点数据
  - B：可以使用Redis自带的数据淘汰策略
  - Redis内存数据大小上升到一定大小的时候，就会实施数据淘汰策略（回收策略）
  - Redis提供的6大数据淘策略
    - volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据进行淘汰
    - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选即将要过期的数据进行淘汰
    - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中选择任意数据进行淘汰
    - allkeys-lru：从数据集中选择（server.db[i].dict）中挑选最近最少使用的数据淘汰
    - allkeys-random：从数据集中选择（server.db[i].dict）中挑选任意数据淘汰
    - no-enviction（驱逐）：禁止驱逐数据

- **Redis单线程使用异步多路复用IO**

  - NIO 是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。 

- **什么是跳表**
  
  - TODO