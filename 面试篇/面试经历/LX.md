小明准备去超市购买节日惊喜物品！这里有一排n个商品，从左排到右分别编号为1, 2, ... n。小明将按照规定顺序，从左到右依次购买，即，不能先买右边的一个商品，然后再去买左边的商品。每商品最多买m个。对商品a，对小明有一个基础的美观度a。但小明有自己的惊喜值——对不同商品能给他带来的惊喜，以他最先一个买的商品能够给他的惊喜最大值为准。购买越后面的商品，惊喜值越低，给小明的购买的惊喜值乘以w倍的惊喜，假设某个商品购买数量为x, 则其带给小明的愉悦值为axw。小明想购买一共m个商品，想请你帮助安排让小明买到最多愉悦值的商品，他的愉悦值为愉悦总和。

**输入描述:**

第一行两个整数n和m，表示商品总数和购买商品数。
第二行n个整数a1, a2, ..., an表示商品编号i的商品美观度。
第三行n个整数w1, w2, ..., wn表示第i个购买的商品的惊喜倍率。
对100%的数据，1≤m≤5000, 1≤a, w≤10⁴

**输出描述:**

输出一个整数表示答案。

**样例输入:**

```
3 2  
3 2 3  
5 1 2  
```

**样例输出:**

```
13
```

**提示:**

购买第2个和第3个，愉悦值为2*5 + 3*1 \= 13。
若购买第1, 2个，愉悦值为1*5 + 2*1 \= 7。
若购买第1, 3个，愉悦值为1*5 + 3*1 \= 8。

找到使得小明的总愉悦值达到最大化的方案。

### 问题描述

* **输入:**

  * $n$: 商品总数
  * $m$: 小明要购买的商品总数
  * $a[i]$: 每个商品的美观度
  * $w[k]$: 购买的第 $k$ 个商品的惊喜倍数
* **输出:**

  * 小明能够获得的最大愉悦值

### 解决思路

1. **定义状态:**

    * 定义 $dp[i][j]$ 表示前 $i$ 个商品中购买 $j$ 个商品的最大愉悦值。
2. **状态转移:**

    * 对于每一个商品 $i$，可以选择购买或者不购买。如果购买新的，作为j件商品，当前已经有了愉悦度是：$dp[i-1][j-1]$，如果不买新的，原来已经有的j件商品的愉悦度是：$dp[i-1][j]$
    * 若购买第 $i$ 个商品，则愉悦值更新为 $dp[i][j] = \max(dp[i-1][j], dp[i-1][j-1] + a[i] \times w[j])$。
    * 如果不购买第 $i$ 个商品，愉悦值保持为 $dp[i][j] = dp[i-1][j]$。
3. **初始条件:**

    * $dp[0][0] = 0$：表示不购买任何商品时的初始愉悦值为 0。
4. **目标:**

    * 最终结果为 $dp[n][m]$，即从所有 $n$ 个商品中选 $m$ 个商品的最大愉悦值。

### 代码实现

以下是一个 Java实现示例：

```python
import java.util.Scanner;

public class MaxHappiness {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int n = scanner.nextInt(); // 商品总数
        int m = scanner.nextInt(); // 要购买的商品数

        int[] a = new int[n];
        int[] w = new int[m];

        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt(); // 每个商品的美观度
        }

        for (int i = 0; i < m; i++) {
            w[i] = scanner.nextInt(); // 购买第i个商品的惊喜倍数
        }

        // 动态规划数组
        int[][] dp = new int[n + 1][m + 1];

        // 动态规划填表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i][j] = Math.max(dp[i-1][j], dp[i - 1][j - 1] + a[i - 1] * w[j - 1]);
            }
        }

        // 输出结果
        //遍历dp
		int result = 0;
		for (int j = 1; j <= m; j++) {
			result = Math.max(result,dp[i][m]);//装满了的dp愉悦度。
		}
    }
}
```

### 解释

* `dp[i][j]` 表示在前 `i` 个商品中购买 `j` 个商品所能获得的最大愉悦值。
* 通过从 `dp[0][0]` 开始逐步计算，每一步决策是基于是否购买当前商品，从而最终获得最优解。

### 示例解释

对于给定的输入 $n = 3$, $m = 2$, $a = [3, 2, 3]$, $w = [5, 1, 2]$:

* 购买第2个和第3个商品可以获得最大的愉悦值 $13$。

希望这个解决方案能帮助小明购买到最满意的商品组合！
