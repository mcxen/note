# 一、MySQL索引

## MySQL 如何实现索引机制？

三类：B+树索引、Hash索引、全文索引

## InnoDB索引和MyISAM索引实现的区别？

MyISAM索引文件和数据文件是分离的，使用B+树实现，主键索引和辅助索引实现一致，索引文件仅保存记录所在页的指针（物理地址），通过这些地址来读取页，进而读取被索引的行。

## 一个表如果没有创建索引，那么还会创建B+树吗？

会，MySQL会隐式创建基于row_id的索引。

# 二、说一下B+树索引实现原理

假设有一个表index_demo，表中有2个 INT 类型的列，1个 CHAR(1) 类型的列，c1列为主键

```mysql
CREATE TABLE index_demo(c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(C1));
```

index_demo表的简化的行格式示意图如下：

![image-20221201142516000](MySQL问题整理.assets/image-20221201142516000.png)

我们只在示意图里展示记录的这几个部分：

* `record_type:` 表示记录的类型，0是普通记录、2是最小记录、3是最大记录、1是B+树非叶子节点记录。
* `next_record:` 表示下一条记录的相对位置，我们用箭头来表明下一条记录。
* `各个列的值:` 这里只记录在 index_demo 表中的三个列，分别是c1、c2 和 c3。
* `其他信息:` 除了上述三种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将`其他信息`项暂时去掉并把它竖起来的效果就是这样：

<img src="MySQL问题整理.assets/image-20221201143245347.png" alt="image-20221201143245347" style="zoom:50%;" />

![image-20221201143303460](MySQL问题整理.assets/image-20221201143303460.png)

`MySQL InnoDB的默认的页大小就是16KB`，因此数据存储在磁盘中，可能会占用多个数据页。

![image-20221201144758237](MySQL问题整理.assets/image-20221201144758237.png)

## 聚簇索引和非聚簇索引 B+ 树实现有什么区别？

**聚簇索引**

**特点：**

* `索引和数据保存在同一个B+树中`。
* `页内的记录`是按照`主键`的大小排序排成一个单向链表。
* `页与页之间`也是根据页中记录的`主键`的大小顺序排成一个`双向链表`。

* 非叶子节点存储的是记录的`主键+页号`。
* 叶子节点存储的是`完整的用户记录`。

**限制：**

* 只有InnoDB引擎支持聚簇索引，`MyISAM`不支持聚簇索引。
* 由于数据的物理存储排序方式只能有一种，所以`每个MySQL的表只能有一个聚簇索引`。
* 如果没有为表定义主键，InnoDB会选择`非空的唯一索引列替代`。如果没有这样的列，InnoDB会`隐式的定义一个主键`作为聚簇索引。
* 为了充分利用聚簇索引的聚簇特性，InnoDB中的表的`主键应选择有序的id`，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。

**非聚簇索引**

(二级索引、辅助索引)

`聚簇索引`，只能在搜索条件时`主键值`时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建`非聚簇索引`。

例如，`以c2列作为搜索条件`，那么需要使用`c2列创建一颗B+树`，如下所示：

![image-20221201162155274](MySQL问题整理.assets/image-20221201162155274.png)

**与聚簇索引有几处不同：**

* `页内的记录`是按照从`c2列`的大小排序排成一个`单向链表`。
* `页和页之间`也是根据页中的记录的`c2列`的大小排序排成一个`双向链表`。
* 非叶子节点存储的是记录的`c2列+页号`。
* 叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值。

## 平衡二叉树、红黑树、B树和B+树的区别是什么？都有哪些应用场景？

## 一个B+树中大概能存放多少条索引记录？

## 使用B+树存储的索引CRUD执行效率如何？

## 什么是自适应哈希索引

自适应哈希索引是InnoDB引擎的一个特殊功能，把它注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree所有之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置。

## 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）

* 自增主键能够维持底层数据顺序写入
* 读取可以由B+树的二分查找定位
* 支持范围查找，范围数据自带顺序

## 使用int自增主键后，最大id是10，删除id为10和9的字段后，再插入记录，最后添加的id是多少？删除后重启MySQL然后添加记录最后id是多少？

删除之后

* 如果重启，会从最大的id开始递增
* 如果未重启，会延续删除之前最大的id开始递增

# 三、索引的优缺点

**优点**

聚簇（主键）索引：

* 顺序读写
* 范围快速查找
* 范围查找自带顺序

非聚簇索引：

* 条件查询避免全表扫描
* 范围，排序，分组查询返回行ID，排序分组后，再回表查询完整数据，有可能利用顺序读写
* 覆盖索引不需要回表操作

## 如果是大段文本内容，如何创建（优化）索引

第一种方式是分表存储，然后创建索引

第二种使用ElasticSearch为大文本创建索引

# 四、什么是聚簇索引

## 一个表中可以有多个（非）聚簇索引吗？

聚簇索引只能有一个，非聚簇索引可以有多个

## CRUD时聚簇索引与非聚簇索引的区别是什么？

* 聚簇索引插入新值比采用非聚簇索引的速度要慢很多，因为插入要保证主键不能重复
* 聚簇索引范围，排序查找效率高，因为是有序的
* 非聚簇索引访问需要两次索引查找，第一次找主键值，第二次根据主键值找到行数据。（覆盖索引除外）

## 非聚簇索引为什么不存数据地址值而存储主键？

因为聚簇索引中有时会引发分页操作、重排操作，数据有可能会移动

# 五、什么是回表

## 非聚簇索引一定回表查询吗？

不一定，只要B+树中包含的字段（创建索引的字段），覆盖（包含）想要select的字段，那么久不会回表查询了。

## 为什么要回表查询？直接存储数据不可以吗？

为了控制非聚簇索引的大小

## 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？

不是，InnoDB会生成 rowid 辅助回表查询

# 六、什么是联合索引，组合索引，复合索引

`为c2和c3列建立联合索引`，如下所示：

![image-20221211155428530](MySQL问题整理.assets/image-20221211155428530.png)

# 七、什么是唯一索引

## 什么时候使用唯一索引？

业务需求唯一字段的时候，一般不考虑性能问题

# 八、什么时候适合创建索引，什么时候不适合创建索引？

适合创建索引

* 频繁作为where条件语句查询字段
* 关联字段需要建立索引
* 排序字段可以建立索引
* 分组字段可以建立索引
* 统计字段可以建立索引（如 count(), max())

不适合创建索引

* 频繁更新的字段不适合创建索引
* where, 分组，排序中用不到的字段不必要创建索引
* 可以确定表数据非常少不需要建立索引
* 参与mysql函数计算的列不适合建立索引

# 九、什么是索引下推

未开启索引下推：

* 根据筛选条件在索引树中筛选第一个条件
* 获得结果集后回表操作
* 进行其他条件筛选
* 再次回表查询

开启索引下推：在条件查询时，当前索引树如果全部满足全部筛选条件，可以在当前树中完成全部筛选过滤， 得到比较小的结果集再进行回表操作。

# 十、有哪些情况下会导致索引失效？

* 计算、函数导致索引失效

  ```mysql
  EXPLAIN SELECT * FROM emp WHERE emp.name LIKE 'abc%';
  EXPLAIN SELECT * FROM emp WHERE LEFT(emp.name, 3) = 'abc'; # 索引失效
  ```

* LIKE以%, _ 开头索引失效

  ```mysql
  EXPLAIN SELECT * FROM emp WHERE emp.name LIKE '%ab%'; # 索引失效
  ```

* 不等于（!= 或者 <>）索引失效

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name <> 'abc'; # 索引失效
  ```

* IS NOT NULL 失效 和 IS NULL（有可能）

  **注意：**当数据库中的数据的索引列的`NULL值达到比较高的比例的时候`，即使在IS NOT NULL的情况下MYSQL的查询优化器会选择使用索引，此时`type的值是range（范围查询）`

* 类型转换导致索引失效

* 复合索引失效

* 查询优化器决定是否使得索引失效

## 为什么LIKE以%开头索引会失效？

user(id, name, age)

使用name创建索引

```mysql
SELECT * FROM user WHERE name LIKE '%明'; # type = all
SELECT name FROM user WHERE name LIKE '%明'; # type = index
```

其实并不会完全失效，覆盖索引下会出现 type = index，表示遍历了索引树，再回表查询

覆盖索引没有生效的时会直接type=all

# 十一、一个表有多个索引的时候，能否手动选择使用哪个索引？

不可用手动直接干预，只能通过mysql优化器自动选择

## 如何查看一个表的索引？

```mysql
show index from t_emp; # 显示表上的索引
explain select * from t_emp where deptid=1; # 显示可能会用到的索引及最终使用的索引
```

## 能否查看到索引选择的逻辑？是否使用过optimize_trace？

```mysql
set session optimizer_trace = "enabled=on", end_markers_in_json=on;
select * from information_schema.OPTIMIZER_TRACE;
set session optimizer_trace="enabled=off";
```

## 多个索引优先级是如何匹配的？

1. 主键（唯一索引）匹配
2. 全值匹配（单值匹配）
3. 最左前缀匹配
4. 范围匹配
5. 索引扫描
6. 全表扫描

一般性建议

* 对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）
* 在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好
* 选择组合索引时，尽量包含where中更多字段的索引
* 组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面
* 尽量避免造成索引失效的情况

# 十二、使用 Order By 时能否通过索引排序？

没有过滤条件不走索引

## 通过索引排序内部流程是什么？

关键配置：

* sort_buffer 可供排序的内存缓冲区大小
* max_length_for_sort_data 单行所有字段总和限制，超过这个大小启动双路排序

1. 通过索引过滤筛选条件所需要排序的字段+其他字段（如果是符合索引）

2. 判断所有内容是否覆盖select的字段

   1）如果覆盖索引，select的字段和排序都在索引上，那么再内存中进行排序，排序后输出结果

   2）如果索引没有覆盖查询字段，接下来计算select的字段是否超过max_length_for_sort_data限制，如果超过，启动双路排序，否则使用单路

## 什么是双路排序和单路排序

单路排序：一次取出所有字段进行排序，内存不够用的时候会使用磁盘

双路排序：取出排序字段进行排序，排序完成后再次回表查询所需要的其他字段

## Group By 分组和 Order By 在索引使用上有什么区别？

group by 使用索引的原则几乎跟order by一致，唯一区别：

* group by 先排序再分组，按照索引建的最佳左前缀法则
* group by 没有过滤条件，也可以用上索引。order by 必须有过滤条件才能使用上索引

## 如果表中有字段为null，又被经常查询该不该给这个字段创建索引？

应该创建索引，使用的时候尽量使用 is null 判断。

 # 十三、MySQL内部技术架构

## MySQL内部支持缓存查询吗？

当MySQL接收到客户端的查询SQL之后，仅仅只需要对齐进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互

MySQL5.7支持内部缓存，8.0之后就废弃掉了

### MySQL8.0之后为什么废除查询缓存？

缓存的意义在于快速查询提升系统西能，可以灵活控制缓存的一致性

mysql缓存的限制

1. mysql基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表
2. SQL必须完全一致才会Cache命中
3. 为了节省内存空间，太大的result set不会被cache
4. mysql缓存在分库分表环境下不起作用
5. 执行SQL里有出触发器，自定义函数时，mysql缓存也是不起作用的
6. 在表的结构和数据发生改变时，基于该表相关的cache立即全部失效

### 替代方案是什么

应用层组织缓存，最简单是使用redis, ehcached等。

## MySQL内部有哪些核心模块组成，作用是什么？

<img src="MySQL问题整理.assets/image-20221211210331900.png" alt="image-20221211210331900" style="zoom:50%;" />

## 一条sql发送给mysql后，内部是如何执行的？(说一下MySQL执行一条查询语句的内部执行过程？)

![image-20221211211323227](MySQL问题整理.assets/image-20221211211323227.png)

**首先**，`MySQL客户端通过协议与MySQL服务器建立连接，通过SQL接口发送SQL语句，[先查询缓存，如果命中，直接返回结果，否则进行语句解析(对于MySQL5.7, 8.0废除了内部缓存)]`。

**接下来**，`MySQL解析器通过关键字将SQL语句进行解析，并生成一颗对应的解析树`，解析器使用MySQL语法规则验证和解析SQL语句。例如，它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确，引号能否前后匹配等;`预处理器则根据MySQL规则进一步检查解析树是否合法`，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看是否有歧义等。`然后预处理器会进行查询重写，生成一颗新的解析树。`

**接下来**，`查询优化器将解析树转化成执行计划`。MySQL优化程序会对我们的语句做一些优化，如子查询转为连接、表达式简化等等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等。我们可以使用EXPLAIN语句来查看某个语句的执行计划。

**最后**，`进入执行器阶段`。完成查询优化后，`查询执行引擎`会按照生成的执行计划调用存储一起提供的接口执行SQL查询并将结果返回给客户端。在MySQL8一下的版本，如果设置了查询缓存，这时会讲查询结果进行缓存，再返回给客户端。

<img src="MySQL问题整理.assets/image-20221211213852774.png" alt="image-20221211213852774" style="zoom:70%;" />

### MySQL提示“不存在此列"是执行到哪个节点报出的？

Paster:解析器 分析sql语法的时候检查的列。

### 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？

在优化器阶段**Optimizer: 查询优化器**

## MySQL8.0存储引擎

1. InnoDB存储引擎

* InnoDB是MySQL的默认事务型引擎。它被设计用来处理大量的短期事务。可以确保事务的完整提交和回滚。
* 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。
* 数据文件结构
  * 表名.frm存储表结构（MySQL8.0时，合并在表名.ibd中）
  * 表名.ibd存储数据和索引
* InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性影响。

2. MyISM存储引擎

* MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但`MyISAM不支持事务和行级锁`，有一个毫无疑问的缺陷就是崩溃后无法安全恢复
* 优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用
* 数据文件结构
  * 表名.frm存储表结构
  * 表名.MYD存储数据
  * 表名.MYI存储索引
* MyISAM只缓存索引，不缓存真实数据

## MySQL存储引擎架构了解吗？

以下是官网的InnoDB引擎结构图，主要分为内存结构和磁盘结构两大部分。

<img src="MySQL问题整理.assets/image-20221211221636235.png" alt="image-20221211221636235" style="zoom:67%;" />

### 能否单独为一张表设置存储引擎？

可以

`方法一：`

设置默认存储引擎：

```mysql
SET DEFAULT_STORAGE_ENGINE=MyISAM;
```

`方法二：`

或者修改 my.cnf 文件：vim /etc/my.cnf

新增一行：default-storage-engine=MyISAM

重启MySQL：systemctl restart mysqld

`方法三:`

我们可以为不同的表设置不同的存储引擎

```mysql
CREATE TABLE 表明（创建语句;) ENGINE = 存储引擎名称;
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

 ## MyISAM 和 InnoDB 的区别是什么？

![image-20221211224409445](MySQL问题整理.assets/image-20221211224409445.png)

# 十四、MySQL事务

## 什么是ACID?

**1、原子性A** atomicity

`只做一个步骤`

事务是数据库的逻辑工作单元，事务中包含的各操作`要么都做，要么都不做`

**2、一致性C** consistency

`保证要吃完`刚张嘴就挂了，失去一致性

事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。

**3、隔离性I** isolation

`不被干扰`

一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

**4、持久性 永久性D** durability

指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。

## 并发事务会有哪些问题？

### 什么是脏读（Dirty read）？

一个事务在处理过程中读取另外一个事务未提交的数据

当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“脏数据”，这种行为就是”脏读“，依据“脏数据”所做的操作可能是会出现问题的。

### 修改丢失（Lost of modify）

指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一次事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就会丢失，这种情况下就被称为修改丢失

### 不可重复读（Unrepeatable Read)

指在一个事务内多次读取同一数据，在这个事务还没结束时，另外一个事务也访问了这个数据并对这个数据进行了修改，那么就可能造成第一个事务两次读取的数据不一致，这种情况被称为不可重复读。

### 幻读（Phantom Read）

指同一个事务内多次查询返回的结果集总数不一样（比如增加了或者减少了行记录）

幻读与不可重复读类似，幻读是指一个事务读取了几行数据，这个事务还没结束，接着另外一个事务插入了一些数据，在随后的查询中，第一个事务读取到的数据就会比原本读取到的多，就好像发生了幻觉一样，所以称为幻读

## MySQL是如何避免事务并发问题的？

### 什么是事物隔离级别？

<img src="MySQL问题整理.assets/image-20221212140751245.png" alt="image-20221212140751245" style="zoom:80%;" />

### 默认的级别是什么？

`MySQL InnoDB` 存储引擎默认的事务隔离级别是 可重复读（REPEATABLE-READ）

### 如何选择事务隔离级别？

隔离级别越低，事务请求的锁越少相应性能也就越高，如没有特殊要求或有错误发生，使用默认的隔离级别即可，如果系统又高频读写并且对一致性要求高那么久需要比较高的事务隔离级别甚至串行化。

### 靠缓存可以提高事务隔离级别的性能吗

提升事务级别的目的本质是提供更高的数据一致性，如果前置有缓存，那么缓存只能提供高效读并不能保证数据及时一致性，相反的我们还需要对缓存管理有额外的开销。

## MySQL事务隔离是如何实现的？

隔离的实现主要是读写锁和MVCC

## 什么是一致性非锁定读和锁定读？

**锁定读**

使用到了读写锁

读写锁是最简单直接的事务隔离实现方式

* 每次读操作需要获取一个共享（读）锁，每次写操作需要获取一个写锁。
* 共享锁之间不会产生互斥，共享锁和写锁之间、以及写锁与写锁之间会产生互斥。
* 当产生锁竞争时，需要等待其中一个操作释放锁后，另一个操作才能获取到锁。

锁机制，解决的就是多个事务同时更新数据，此时必须要有一个加锁的机制

* 行锁（记录锁）：解决的就是**多个事务同时更新一行数据**
* 间隙锁：解决的就是**多个事务同时更新多行数据**

```mysql
select ... lock in share mode
select ... for update
insert、update、delete
```

**非锁定读**

使用mvcc多版本控制实现

## 说一下MVCC内部细节

多版本并发控制，MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据的并发访问

InnoDB是一个多版本的存储引擎。它保存有关已更改行的旧版本的信息，以支持并发和回滚等事务特性。这些信息存储在一个称为回滚段的数据结构中的系统表空间或undo表空间中。InnoDB使用回滚段中的信息来执行事务回滚所需的撤销操作。它还是用这些信息构建行的早期版本，以实现一致的读取

MVCC的实现依赖于：隐藏字段、Read View、undo log

**隐藏字段**

![image-20221212151348807](MySQL问题整理.assets/image-20221212151348807.png)

**Read View**

不同的事务隔离界别中，当有事务在执行过程中修改了数据（更新版本号），在并发事务时需要判断一下版本链中的哪个版本是当前事务可见的。为此InnoDB有了ReadView的概念，使用ReadView来记录和隔离不同事务并发时此记录的哪些版本是对当前访问事务可见的。

**Undo Log**

除了用来回滚数据，还可以读取可见版本的数据。以此实现非锁定读

## MySQL事务一致性，原子性是如何实现的？

首先是通过锁和MVCC实现了执行过程的一致性和原子性

其次是在备灾方面通过Redo Log实现，Redo Log会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。

## MySQL事务的持久性是如何实现的？

使用Redo Log保证了事务的持久性。当事物提交时，必须先将事务的所有日志写入日志文件进行持久化，就是我们常说的WAL（write ahead log）机制，如果出现断电重启便可以从 Redo Log 中恢复，如果 Redo Log 写入失败那么也就意味着修改失败整个事务也就直接回滚了。

## 表级锁和行级锁有什么区别？

表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用

行级锁：除了串行化（serializable）时 InnoDB 使用的都是行级锁，只锁一行数据，其他行数据不影响，并发能力强。

## 什么是行级锁？

行级锁实现比较复杂不是单纯锁住一张数据，是由MVCC完成的。

## 什么是共享锁（读锁）？

共享锁或S锁，其他事务可以继续加共享锁，但不能加排他锁

## 什么是排他锁（写锁/独占锁）？

排他锁或X锁，在进行写操作之前要申请并获得，其他事务不能再获得任何锁。

## 什么是意向锁？

它分为意向共享锁（IS）和意向排他锁（IX）

一个事务对一张表的某行添加共享锁前，必须获得对该表一个IS锁或者优先级更高的锁。

一个事务对一张表的某行添加排他锁之前，它必须对该表获得一个IX锁。

意向锁属于表锁，它不与innodb中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S锁和X锁）产生冲突。

## InnoDB支持哪几种锁？

表锁，行锁，间隙锁，Next-Key锁等

在Serializable中读加共享锁，写加排他锁，读写互斥

两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫二段锁）

## 当前读和快照读分别是什么？

当前读：在锁定读（使用锁隔离事务）的时候读到的最新版本的数据

快照读：可重复读（repeatable_read）下mvcc生效读取的是数据的快照，并不是最新版本的数据（未提交事务的数据）

# 十五、什么是XA协议？

<img src="MySQL问题整理.assets/image-20221212163152470.png" alt="image-20221212163152470" style="zoom:67%;" />

![image-20221212163442391](MySQL问题整理.assets/image-20221212163442391.png)

![image-20221212163547284](MySQL问题整理.assets/image-20221212163547284.png)

## 什么是MySQL XA事务

MySQL的XA事务分为两部分：

1. InnoDB内部本地普通事务操作协调数据写入与log写入两阶段提交
2. 外部分布式事务

![image-20221212163826562](MySQL问题整理.assets/image-20221212163826562.png)

## XA事务与普通事务区别是什么？

XA事务可以跨库或跨服务器，属于分布式事务，同时XA事务还支撑了InnoDB内部日志两阶段记录

普通事务只能再单库中执行

# 十六、是否使用过select for update？会产生哪些操作？

select本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用select for update 会让select语句产生一个排他锁（X），这个锁和update的效果一样，会使两个事物无法同时更新一条记录。

http://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html

http://dev.mysql.com/doc/refman/8.0/en/select.html

![image-20221212164913847](MySQL问题整理.assets/image-20221212164913847.png)

# 十七、说一下MySQL死锁的原因和处理方法

* 死锁和锁等待是两个概念
  * 如未开启事务，多个客户端执行的insert操作

* 当多个事务同时持有和同一资源上的锁而产生循环依赖的时候就会产生死锁。

<img src="MySQL问题整理.assets/image-20221212165055918.png" alt="image-20221212165055918" style="zoom:67%;float:left" />

![image-20221212165146640](MySQL问题整理.assets/image-20221212165146640.png)

# 十八、MySQL日志

## MySQL会产生几种日志？

![image-20221212170058437](MySQL问题整理.assets/image-20221212170058437.png)

<img src="MySQL问题整理.assets/image-20221212170149995.png" alt="image-20221212170149995" style="zoom:50%;float:left" />

## bin log作用是什么？

MySQL的bin log日志是用来记录MySQL中增删改查时的记录日志。

当你的一条sql操作对数据库中的内容进行了更新，就会增加一条bin log日志。查询操作不会记录到bin log中。

bin log最大的用处就是进行**主从复制，以及数据库的恢复。**

## redo log作用是什么？

redo log是一种基于磁盘的数据结构，用来在MySQL宕机情况下将不完整的事务执行数据纠正，redo日志记录事务执行后的状态。

 当事务开始后，redo log就开始产生，并且随着事务的执行不断写入redo log file中。redo log file中记录了xx页做了xx修改的信息，我们都知道数据库的更新操作会在内存中先执行，最后刷入磁盘。

redo log就是为了回复更新了内存但是由于宕机等原因没有刷入磁盘中的那部分数据。

## undo log作用是什么？

undo log主要用来回滚到某一个版本，是一种逻辑日志。

undo log记录的是修改之前的数据，比如：当delete一条记录时，undolog中会记录一条对应的insert记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过undo log中的记录内容并以此进行回滚。

undo log还可以提供多版本并发控制下的读取（MVCC）。

## MySQL日志是否实时写入磁盘？bin log刷盘机制是如何实现的？redo log刷盘机制是如何实现的？undo log刷盘机制是如何实现的？

磁盘写入固然是比较慢的

![image-20221212214134578](MySQL问题整理.assets/image-20221212214134578.png)

<img src="MySQL问题整理.assets/image-20221212214154824.png" alt="image-20221212214154824" style="zoom:80%;" />

![image-20221212214630847](MySQL问题整理.assets/image-20221212214630847.png)

<img src="MySQL问题整理.assets/image-20221212214817884.png" alt="image-20221212214817884" style="zoom:50%;float:left" />

![image-20221212215049288](MySQL问题整理.assets/image-20221212215049288.png)

## MySQL的binlog有几种录入格式？分别有什么区别？

<img src="MySQL问题整理.assets/image-20221212215237272.png" alt="image-20221212215237272" style="zoom:80%;" />

## MySQL集群同步时为什么使用binlog？优缺点是什么？

* binlog是mysql提供的日志，所有存储引擎都可用。
* 支持增量同步
* binlog还可以供其他中间件读取，比如同步到hdfs中
* 如果复制表数据：
  * 不支持某个阶段回放
  * 直接复制数据过程中一旦中断复制（比如断网），很难确定复制的offset

# 十九、MySQL开发

## 可以使用MySQL直接存储文件吗？

可以使用BLOB（binary large object），用来存储二进制大对象的字段类型

TinyBlob 255 值的长度加上用于记录长度的1个字节（8位）

Blob 65K 值的长度加上用于记录长度的2个字节（16位）

MediumBlob 16M 值的长度加上用于记录长度的3个字节（24位）

LongBlob 4G 值的长度加上用于记录长度的4个字节（32位）

## 什么时候存，什么时候不存

存：需要高效查询并且文件很小的时候

不存：文件比较大，数据量多或变更频繁的问题

## 存储的时候有遇到过什么问题吗？

1. 上传数据过大sql执行失败，调整max_allowed_packet
2. 主从同步数据时比较慢
3. 占用线程阻塞
4. 占用网络带宽
5. 高频访问的图片无法使用浏览器缓存

## Emoji乱码怎么办

使用utf8mb4

MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在uft8mb4是utf8的超集，除了将编码改为utf8bm4外不需要做其他转换。当然，一般情况下使用uft8就够了。

## 如何存储ip地址

1. 使用字符串
2. 使用无符号整型

* 四字节即解决问题
* 可以支持范围查询
* INET_ATON() 和 INET_NTOA() ipv6 使用 INET6_ATON() 和 INET6_NTOA()

## 长文本如何存储？

可以使用Text存储

**TINYTEXT(255长度)**

**TEXT(65535)**

**MEDIUMTEXT(int 最大值 16M)**

**LONGTEXT(long最大值4G)**

## 大段文本如何设计表结构

1. 将大段文本同时存储到搜索引擎
2. 分段存储
3. 分段后多段存储

## 大段文本查找时如何建立索引？

1. 全文索引，模糊匹配最好存储到索引引擎中
2. 指定索引长度
3. 分段存储后创建索引

## 有没有在开发中使用过TEXT，BLOB数据类型

BLOB之前做ERP的时候使用过，互联网项目一般不用BLOB

TEXT 文献，文章，小说类，新闻，会议内容等

## 日期，时间如何存取？

使用TIMESTAMP,DATETIME

## TIMESTAMP,DATETIME的区别是什么？

![image-20221212225723841](MySQL问题整理.assets/image-20221212225723841.png)

![image-20221212225829061](MySQL问题整理.assets/image-20221212225829061.png)

## 为什么不适用字符串存储日期？

字符串无法完成数据库内部的范围筛选

在大数据量存储优化索引时，查询必须加上时间范围

## 如果需要使用时间戳timestamp和int该如何选择？

int 存储空间小，存储查询效率高，不受时区影响，精度低

timestamp 存储空间小，可以使用数据库内部时间函数比如更新，精度高，需要注意时区转换，timestamp更易读

一般选择timestamp，这两者性能差异不明显，本质上存储都是使用的Int

## char与varchar的区别？如何选择？

1. char的优点是存储空间固定（最大255），没有碎片，尤其更新比较频繁的时候，方便数据文件指针的操作，所以存储读取速度快。缺点是空间夯余，对于数据量大的表，非固定长度属性使用char字段，空间浪费。
2. varchar字段，存储的控件根据存储的内容变化，空间长度为L+size，存储内容长度加描述存储内容长度信息，有点就是空间借阅，缺点就是读取和存储的时候，需要读取信息计算下标，才能获取完整的内容。

## 财务计算有没有出现过错乱？

<img src="MySQL问题整理.assets/image-20221212230946328.png" alt="image-20221212230946328" style="zoom:67%;float:left" />

## decimal与float,double的区别是什么

<img src="MySQL问题整理.assets/image-20221212231421681.png" alt="image-20221212231421681" style="zoom:80%;" />

## 浮点类型何如选型？为什么？

* 需要不丢失精度的计算使用DECIMAL
* 仅用于展示没有计算的小数存储可以使用字符串存储
* 低价值数据允许计算后丢失精度可以使用float double
* 整型记录不会出现小数的不要使用浮点类型

# 二十、预编译sql是什么？

* 预编译sql会被mysql缓存下来
* 作用域是每个session，对其他session无效，重新连接也会失效
* 提高安全性防止sql注入
* 编译语句有可能被重复调用，也就是说sql相同参数不同在同一session中重复查询执行效率明显比较高
* mysql 8 支持服务器端的预编译

# 二十一、子查询和join哪个效率高？

子查询虽然很灵活，但是执行效率并不高

## 为什么子查询效率低？

在执行子查询的时候，MySQL创建了临时表，查询完毕后再删除这些临时表

子查询的速度慢的原因是多了一个创建和销毁临时表的过程

而join则不需要创建临时表 所以会比子查询快一点

## join查询可以无限叠加吗？MySQL对json查询有什么限制吗？

建议join不超过3张表关联，mysql对内存敏感，关联过多会占用更多内存空间，使性能下降

系统限制最多关联61个表

## join查询算法了解吗？

* Simple Nested-Loop Join: SNLJ，简单嵌套循环连接
* Index Nested-Loop Join: INLJ，索引嵌套循环连接
* Block Nested-Loop Join: BNLJ，缓存块嵌套循环连接

## 如何优化多过的join查询关联

* 适当使用冗余字段减少多表关联查询

* 驱动表和被驱动表（小表join大表）
* 业务允许的话，尽量使用inner join让系统帮忙自动选择驱动表
* 关联字段一定创建索引
* 调整JOIN BUFFER大小

# 二十二、是否有过MySQL调优经验？

调优：

1. sql 调优
2. 表（结构）设计调优
3. 索引调优
4. 慢查询调优
5. 操作系统调优
6. 数据库参数调优

## 开发中使用过哪些调优工具？

官方自带：

* EXPLAIN
* mysqldumpslow
* show profiles
* optimizer_trace

第三方：性能诊断工具，参数扫描提供建议，参数辅助优化

## 如何监控线上环境中执行比较慢的sql？如何分析一条慢sql?

开启慢查询日志，收集sql

默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。

当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能印象。慢查询日志支持将日志记录写入文件。

**查看及开启**

1. 默认关闭

   `SHOW VARIABLES LIKE '%slow_query_log%';`

   默认情况下slow_query_log的值为OFF, 表示慢查询日志是禁用的

2. 开启：`set global slow_query_log = 1;`

   只对窗口生效，重启服务失效

慢查询日志记录long_query_time时间

```mysql
SHOW VARIABLES LIKE '%long_query_log%';
SHOW GLOBAL VARIABLES LIKE 'long_query_time';
```

全局变量设置，对所有客户端有效。但必须是设置后进行登录的客户端

`SET GLOBAL long_query_time = 0.1;`

对当前会话连接立即生效，对其他客户端无效

`SET SESSION long_query_time = 0.1;`

假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里的判断大于long_query_time，而非大于等于。

1. 永久生效

   * 修改配置文件my.cnf（其他系统变量也是如此）
   * [mysqld] 下增加或修改参数
   * slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件

   slow_query_log = 1

   slow_query_log_file=/var/lib/mysql/localhost-slow.log

   long_query_time=3

   log_output=FILE

   * 关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，如果不设置，系统默认文件：[host-name]-slow.log

**case**

记录慢SQL并后续分析

SELECT * FROM emp;

SELECT * FROM emp WHERE deptid > 1;

查询当前系统中有多少条慢查询记录或者直接慢查询日志

/var/lib/mysql/localhost-slow.log

SHOW GLOBAL STATUS LIKE '%Slow_queries%';

**日志分析工具mysqldumpslow**

1. 在生产环境中，如果要手工分析日志，查找，分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow
2. 查看mysqldumpslow的帮助信息

![image-20221213133745476](MySQL问题整理.assets/image-20221213133745476.png)

# 二十三、如何查看当前sql使用了哪个索引？

可以使用EXPLAIN，选择索引过程可以使用optimizer_trace

# 二十四、MySQL数据库cpu飙升的话你会如何分析？

**1. 使用top观察mysqld的cpu利用率**

1. 切换到常用的数据库
2. 使用show full processlist; 查看会话
3. 观察是哪些sql消耗了资源，其中重点观察state指标
4. 定位到具体sql

**2.pidstat**

1. 定位到线程
2. 在PERFORMANCE_SCHEMA. THREADS中记录了thread_os_id找到线程执行的sql
3. 根据操作系统id可以到processlist表找到对应的会话
4. 在会话中即可定位到问题sql

**3. 使用show profile观察sql各个阶段耗时**

**4. 服务器上是否运行了其他程序**

**5. 检查是否有慢查询**

**6. pref top**

使用pref工具分析那个函数引发的cpu过高来追踪定位

![image-20221213135823899](MySQL问题整理.assets/image-20221213135823899.png)

# 二十五、有没有进行过分库分表？

**垂直分库**

一个数据库由很多表构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分不到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：

<img src="MySQL问题整理.assets/image-20221213141320334.png" alt="image-20221213141320334" style="zoom:50%;" />

**水平分库**

把一张表里的内容按照不同的规则，写到不同的库里

相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为按照数据行的切分，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，如图：

<img src="MySQL问题整理.assets/image-20221213142016600.png" alt="image-20221213142016600" style="zoom:50%;" />

## 什么时候进行分库分表？有没有配合ES使用经验？

1. 能不分就不分
2. 单机性能下降明显的时候
3. 增加缓存（通常查询量比较大），细分业务
4. 首先尝试主备集群，读写分离
5. 尝试分库
6. 尝试分表

大数据量下可以配合ES完成高效查询

## 说一下实现分库分表工具的具体思路

1. 伪装成mysql服务器，代理用户请求转发到真实服务器
2. 基于本地AOP实现，拦截sql，改写，路由和结果归集处理。

## 用过哪些分库分表工具

![image-20221213142612507](MySQL问题整理.assets/image-20221213142612507.png)

## 分库分表可能会有哪些问题？

经典的问题

1. 执行效率明显下降
2. 表结构很难再次调整
3. 引发分布式id问题
4. 产生跨库join
5. 代理类中间件网络io成为瓶颈

# 二十六、说一下读写分离的常见方案？

<img src="MySQL问题整理.assets/image-20221213142925956.png" alt="image-20221213142925956" style="zoom:50%;" />

<img src="MySQL问题整理.assets/image-20221213143006441.png" alt="image-20221213143006441" style="zoom:50%;" />

# 二十七、为什么使用视图？什么是视图？

<img src="MySQL问题整理.assets/image-20221213143203979.png" alt="image-20221213143203979" style="zoom:50%;float:left" />

# 二十八、什么是存储过程？有没有使用过？

项目中禁止使用存储过程，存储过程难以调试和扩展，更没有移植性

# 二十九、有没有使用过外键？有什么需要注意的地方

不得使用外键与级联，一切外键概念必须在应用层解决

# 三十、用过processlist吗？

![image-20221213143505802](MySQL问题整理.assets/image-20221213143505802.png)

![image-20221213143523671](MySQL问题整理.assets/image-20221213143523671.png)

![image-20221213143554868](MySQL问题整理.assets/image-20221213143554868.png)

# 三十一、某个表有数千万数据，查询比较慢，如何优化？说一下思路

<img src="MySQL问题整理.assets/image-20221213144331585.png" alt="image-20221213144331585" style="zoom:50%;float:left" />

# 三十二、count(列名)和count(*)有什么区别？

count(\*)是SQL92定义的

标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关

说明：count(\*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行，

# 三十三、如果有超大分页该怎么处理？

![image-20221213145005617](MySQL问题整理.assets/image-20221213145005617.png)

![image-20221213145238809](MySQL问题整理.assets/image-20221213145238809.png)

# 三十四、MySQL服务器毫无规律的异常重启如何排查问题？

![image-20221213145701443](MySQL问题整理.assets/image-20221213145701443.png)

# 三十五、Mysql线上修改表结构有哪些风险？

<img src="MySQL问题整理.assets/image-20221213150628725.png" alt="image-20221213150628725" style="zoom:50%;float:left" />

建议：建个新表，导入数据后重命名

# 三十六、什么是mysql多实例部署？

指的是在一台主机上部署多个实例

主要目的是压榨服务器性能

缺点是项目影响
