# 数据结构模板

## 哈希算法

### 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums==null||nums.length==0) return ans;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp =target-nums[i];
            if(map.containsKey(tmp)) {
                return new int[]{i,map.get(tmp)};
            }
            map.put(nums[i],i);
        }
        return ans;
    }
}
```

### 四数之和II

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2



实际就是化简为两个数之和

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int tmp = i + j;
                map.put(tmp,map.getOrDefault(tmp,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int tmp = i + j;
                // 直接寻找相对的数是否存在，存在就直接可以算作是一组数，几个value就是几组
                if (map.containsKey(0-tmp))
                    ans+=map.get(0-tmp);
            }
        }
        return ans;
    }
}
```

## 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

1. 单调栈里元素是递增呢？ 还是递减呢？

**顺序的描述为 从栈头到栈底的顺序**，从左到右或者从前到后，

```txt
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 
输出: [3,3,5,5,6,7] 
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```

这一题是滑动窗口，所以单调栈的构造需要确定是不是在k的范围内，

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();
        //准备单调队列
        for (int right = 0; right < nums.length; right++) {
//            队首元素就是该窗口内的最大值。
            while (!queue.isEmpty() && nums[right]>=nums[queue.peekLast()]) {
                queue.removeLast();
//            非空的时候，如果信赖的比queue顶部的元素大的话，就移走这个
            }
            queue.addLast(right);
//            如果首部坐标小于left，那么就删除这个
            int left = right-k+1;//此时这个left实际也就是依次递增的
            if (queue.peekFirst()<left){
                queue.removeFirst();
            }
            if (left>=0) {
                ans[left] = nums[queue.peekFirst()];
//                这个first对应就是前k个区间内的大的数值了
            }
        }
    }
}
```

天气：

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]
```

```
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        // 单调栈，遍历递增循序（再强调一下是指从栈头到栈底的顺序），
        // 因为只有递增的时候，栈里要加入一个元素i的时候，
        // 才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        deque.push(0);//就是在队列的左边，头部，加入了初始的0
        for (int i = 1; i < temperatures.length; i++) {
            while (!deque.isEmpty() && temperatures[i]>temperatures[deque.peek()]){
                ans[deque.peek()] = i - deque.peek(); // 最右边的
                deque.pop();
            }
            deque.push(i);
        }
        return ans;
    }
}
```



![739.每日温度6](https://camo.githubusercontent.com/6ed9e572acc674a258e86773a8dd1b2755e85cfce51f1e99e02d98681157fc94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303231393132343730303536372e6a7067)



# 算法模板

## 排序算法

### 选择排序

```java
import java.util.Arrays;
public class Solution {
// 选择排序：每一轮选择最小元素交换到未排定部分的开头

public int[] sortArray(int[] nums) {
    int len = nums.length;
    // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子
    for (int i = 0; i < len - 1; i++) {
        // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        swap(nums, i, minIndex);
    }
    return nums;
}

private void swap(int[] nums, int index1, int index2) {
    int temp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = temp;
	}	

public static void main(String[] args) {
    int[] nums = {5, 2, 3, 1};
    Solution solution = new Solution();
    int[] res = solution.sortArray(nums);
    System.out.println(Arrays.toString(res));
	}
}
```
### 快速排序



```java
class Solution {
    public String minNumber(int[] nums) {
        //参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值
        String[] strs = new String[nums.length];
        for(int i =0;i<nums.length;i++){
            strs[i]=String.valueOf(nums[i]);
        }
      	quickSort(strs,0,strs.length-1);
     	 StringBuilder res = new StringBuilder();
      	for(String s:strs){
        	res.append(s);
      	}
      	return res.toString();
    }
    void quickSort(String[] strs,int left,int right){
        if(left>=right) {
            return;
        }
        int pivotIndex =partition(strs,left,right);
        quickSort(strs,left,pivotIndex-1);
        quickSort(strs,pivotIndex+1,right);
    }
    private int partition(String[] strs,int left,int right) {
        String pivot=strs[left];
        //j是pivot第一个区间最后一个元素所在的位置
        int j=left;
        for(int i=left+1;i<=right;i++) {
            if((strs[i]+pivot).compareTo((pivot+strs[i]))<0) {
                j++;
                swap(strs,i,j);
            }
            
        }
        swap(strs,left,j);
        //此时j处于第一个区间的最后一个位置，实际上就是需要的切分元素现在所在的位置了
        return j;
    }
    private void swap(String[] nums,int i,int j) {
        String temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

}
```

### 插入排序

由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。

```java
public class Solution {

    // 插入排序：稳定排序，在接近有序的情况下，表现优异

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            // 先暂存这个元素，然后之前元素逐个后移，留出空位
            int temp = nums[i];
            int j = i;
            // 注意边界 j > 0
            while (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}


```

### 堆排序

堆就是完全二叉树

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

堆排序的基本思想是：将**待排序序列构造成一个大顶堆**heapify，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```java
import java.util.Arrays;
public class HeapSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i=arr.length/2-1;i>=0;i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j>0;j--){
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr,0,j);//重新对堆进行调整
        }

    }
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i
        for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```



```java
class Solution {
    public int[] sortArray(int[] nums) {
        //实战堆排序
        for(int i = nums.length/2-1;i>=0;i--){
            heapify(nums,i,nums.length);
        }
        for(int i = nums.length-1;i>=1;i--){
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            heapify(nums,0,i);
        }
        return nums;
    }
    void heapify(int[] nums,int i,int length){
        int maxindex = i;
        int leftson = 2*i+1;
        int rightson = 2*i+2;
        if(leftson<length&&nums[leftson]>nums[maxindex]) maxindex =leftson;
        if(rightson<length&&nums[rightson]>nums[maxindex]) maxindex = rightson;//选这三者里面最大的作为naxIndex。
        if(maxindex!=i){
            // 如果发生了交换，那么
            int temp = nums[maxindex];
            nums[maxindex] =nums[i];
            nums[i] = temp;
            heapify(nums,maxindex,length);//交换了最大元素之后的位置继续进行堆排序
        }

    }
}
```

[LeetCode排序堆排序题解](https://leetcode.cn/submissions/detail/410212711/)

## 二分查找法 

**前提是数组为有序数组**，同时题目还强调**数组中无重复元素**

```java
class Solution {
    public int search(int[] nums,int target){
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;//左闭右闭
    }
}
```



```CPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        return right;
    }
};

```

## KMP

```CPP
void kmp(int* next, const string& s){
    next[0] = -1;
    int j = -1;
    for(int i = 1; i < s.size(); i++){
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

## 二叉树 

二叉树的定义：

```CPP
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 前序中序后序遍历

 中序遍历的时候 访问到的元素是从小到大顺序排列的



```java
中序遍历过程模板
public void inorder(TreeNode root){
        if (root == null) return ;    //终止条件
        inorder(root.left);           //访问左子树
        对当前节点进行一些操作          //访问根节点-----在遍历过程中希望实现的操作
        inorder(root.right);          //访问右子树
    }
```



纠正二叉搜索树

输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。



```java
class Solution {
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);
    TreeNode err1 = null;
    TreeNode err2 = null;
    public void recoverTree(TreeNode root) {
        inorder(root);
        int tmp = err1.val;
        err1.val = err2.val;
        err2.val = tmp;
    }
    void inorder(TreeNode root) {
        if(root == null) return;
        inorder(root.left);
        if(pre.val>root.val&&err1==null) err1=pre;//！不相邻，前大后小，第一个错误就要取大的
        if(pre.val>root.val&&err1!=null) err2=root;//哦哦哦哦哦！不相邻，前大后小，第二个错误就要取小的
        pre = root;
        inorder(root.right);

    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //非递归方式实现中序遍历
        List<Integer> res = new LinkedList();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root!=null||!stack.isEmpty()) {
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
    
}
```





### 深度优先遍历（递归） 

前序遍历（中左右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```
中序遍历（左中右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```
后序遍历（左右中）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

### 深度优先遍历（迭代法）

相关题解：[0094.二叉树的中序遍历](https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.二叉树的中序遍历.md)

前序遍历（中左右）
```CPP
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}

```

中序遍历（左中右）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result; // 存放中序遍历的元素
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); 
            if (node->right) st.push(node->right);  // 右
            st.push(node);                          // 中
            st.push(NULL); 
            if (node->left) st.push(node->left);    // 左
        } else {
            st.pop(); 
            node = st.top(); 
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

后序遍历（左右中）
```CPP
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```
### 广度优先遍历（队列）

相关题解：[0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)

```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}

```



可以直接解决如下题目：

* [0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)
* [0199.二叉树的右视图](https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.二叉树的右视图.md)
* [0637.二叉树的层平均值](https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.二叉树的层平均值.md) 
* [0104.二叉树的最大深度 （迭代法）](https://programmercarl.com/0104.二叉树的最大深度.html)

* [0111.二叉树的最小深度（迭代法）](https://programmercarl.com/0111.二叉树的最小深度.html)
* [0222.完全二叉树的节点个数（迭代法）](https://programmercarl.com/0222.完全二叉树的节点个数.html)

### 二叉树深度

```CPP
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

### 二叉树节点数量

```CPP
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

## 回溯算法 

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。







```CPP
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

### 回溯算法：组合



```java
class Solution {
    List<List<Integer>> res= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTrace(n,k,1);//递归函数返回值为void，一般直接就在参数里面修改
        return res;
    }
    void backTrace(int n,int k, int s){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        /*
        已经选择的元素个数：path.size();
        还需要的元素个数为: k - path.size();
        在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
        */
        //可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠s
        for(int i =s;i<=n-(k-path.size())+1;i++ ){
            path.add(i);
            backTrace(n,k,i+1);
            path.removeLast();
        }
    }
}
```



![77.组合1](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67.png)

## 并查集 

```CPP
    int n = 1005; // 根据题意而定 
    int father[1005];

    // 并查集初始化
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
```

## 算数运算

### 进位与非进位

设两数字的二进制形式 ,观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。



![Picture1.png](F:\项目\note\Java篇\assets\56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png)





```java
// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0 
//    1     1         0           1
// 
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
// 
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。

class Solution {
    public int add(int a, int b) {
        // a的二进制表示与b的二进制，
        // 每一位取异或运算，得到无进位和的结果，每一位取与运算，左移<<一位，得到进位，
        // 不用担心整数转二进制，因为他就是默认就是二进制存取的直接去&就可以了
        while(b!=0){
            int c = (a&b)<<1;//进位，左移一位
            a = a ^ b;//非进位和
            b=c;//当进位为0的时候就可以不需要进位，直接非进位和就可以了
        }
        return a;
    }
}
```

### 不用除法的除法：倍增求解

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。



```java
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        //返回完异常值
        //倍增法，每次减去一个2^x倍
        boolean sign = false;
        if((dividend>0&&divisor>0)||(dividend<0&&divisor<0))
            sign = true;//正数标记
        dividend = dividend > 0? -dividend:dividend;
        divisor = divisor > 0? -divisor:divisor;
        int ans = 0;
        //dividend / divisor
        while(dividend<=divisor){
            int tmp = divisor,count =1;
            //tmp + tmp >= dividend
            while(tmp>=dividend-tmp){
                tmp+=tmp;
                count+=count;
            }
            dividend = dividend - tmp;
            ans = ans+count;
        }
        return sign?ans:-ans;
    }
}


```

