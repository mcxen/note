# 数据结构模板

## 链表问题



### [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。



**示例1：**

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626420025-fZfzMX-image.png" alt="img" style="zoom:50%;" />

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```





```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
//        使用两个辅助栈
        ArrayDeque<Integer> stk1 = new ArrayDeque<>();
        ArrayDeque<Integer> stk2 = new ArrayDeque<>();
        while (l1!=null){
            stk1.push(l1.val);
            l1 = l1.next;
        }
        while (l2!=null){
            stk2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;//储存进位
        ListNode res = null;//储存结果
        while (!stk1.isEmpty()||!stk2.isEmpty()||carry!=0) {
            int digit1 = stk1.isEmpty()?0:stk1.pop();
            int digit2 = stk2.isEmpty()?0:stk2.pop();
            int sum = digit1+digit2+carry;
            carry = sum/10;
            sum = sum%10;
            ListNode tmp = new ListNode(sum);
            tmp.next = res;
            res = tmp;
        }
        return res;
    }
}
```





### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

` L0 → L1 → … → Ln-1 → Ln `
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



**示例 1:**

![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        ////将主链表划分为 前一段子链表和后一段子链表，
        // 对于后一段子链表进行翻转，同时对于这两条链表进行重构;
        ArrayDeque<ListNode> deque = new ArrayDeque<ListNode>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        while (head!=null) {
            ListNode next = head.next;
            head.next = null;
            deque.add(head);
            head = next;
        }
        ListNode curr = dummy;
        while (!deque.isEmpty()) {
            ListNode start = deque.pollFirst();
            curr.next = start;
            //循环遍历deque双端，直至队列为空
            if (!deque.isEmpty()){
                ListNode last = deque.pollLast();
                start.next = last;//curr-》start-》last
                curr = last;//curr专程last
            }else {
                start.next = null;
            }
        }
        return;
    }
}
```



## 哈希算法

### 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums==null||nums.length==0) return ans;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp =target-nums[i];
            if(map.containsKey(tmp)) {
                return new int[]{i,map.get(tmp)};
            }
            map.put(nums[i],i);
        }
        return ans;
    }
}
```

### 四数之和II

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2



实际就是化简为两个数之和

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int tmp = i + j;
                map.put(tmp,map.getOrDefault(tmp,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int tmp = i + j;
                // 直接寻找相对的数是否存在，存在就直接可以算作是一组数，几个value就是几组
                if (map.containsKey(0-tmp))
                    ans+=map.get(0-tmp);
            }
        }
        return ans;
    }
}
```



### 哈希法求解不含重复字串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int j = 0;
        // p w w e k
        // j   i
        //找到w上一次的位置设置为最长子串的起始点。
        if (s.length()==1) return 1;
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            ans = Math.max(ans,i-j+1);
        }
        return ans;
    }
}
```



## 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

1. 单调栈里元素是递增呢？ 还是递减呢？

**顺序的描述为 从栈头到栈底的顺序**，从左到右或者从前到后，

```txt
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 
输出: [3,3,5,5,6,7] 
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```

这一题是滑动窗口，所以单调栈的构造需要确定是不是在k的范围内，

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();
        //准备单调队列
        for (int right = 0; right < nums.length; right++) {
//            队首元素就是该窗口内的最大值。
            while (!queue.isEmpty() && nums[right]>=nums[queue.peekLast()]) {
                queue.removeLast();
//            非空的时候，如果信赖的比queue顶部的元素大的话，就移走这个
            }
            queue.addLast(right);
//            如果首部坐标小于left，那么就删除这个
            int left = right-k+1;//此时这个left实际也就是依次递增的
            if (queue.peekFirst()<left){
                queue.removeFirst();
            }
            if (left>=0) {
                ans[left] = nums[queue.peekFirst()];
//                这个first对应就是前k个区间内的大的数值了
            }
        }
    }
}
```

天气：

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]
```

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        // 单调栈，遍历递增循序（再强调一下是指从栈头到栈底的顺序），
        // 因为只有递增的时候，栈里要加入一个元素i的时候，
        // 才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        deque.push(0);//就是在队列的左边，头部，加入了初始的0
        for (int i = 1; i < temperatures.length; i++) {
            while (!deque.isEmpty() && temperatures[i]>temperatures[deque.peek()]){
                ans[deque.peek()] = i - deque.peek(); // 最右边的
                deque.pop();
            }
            deque.push(i);
        }
        return ans;
    }
}
```



![739.每日温度6](https://camo.githubusercontent.com/6ed9e572acc674a258e86773a8dd1b2755e85cfce51f1e99e02d98681157fc94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303231393132343730303536372e6a7067)

### 优先级队列

大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。





# 算法模板

## 排序算法

### 选择排序

```java
import java.util.Arrays;
public class Solution {
// 选择排序：每一轮选择最小元素交换到未排定部分的开头

public int[] sortArray(int[] nums) {
    int len = nums.length;
    // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子
    for (int i = 0; i < len - 1; i++) {
        // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        swap(nums, i, minIndex);
    }
    return nums;
}

private void swap(int[] nums, int index1, int index2) {
    int temp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = temp;
	}	

public static void main(String[] args) {
    int[] nums = {5, 2, 3, 1};
    Solution solution = new Solution();
    int[] res = solution.sortArray(nums);
    System.out.println(Arrays.toString(res));
	}
}
```
### 快速排序

```java
class Solution {
    public int[] sortArray(int[] nums) {
        //快速排序
        quick(nums,0,nums.length-1);
        return nums;
    }
    void quick(int[] nums,int left,int right){
        if (left>=right)
            return;
        int index = partition(nums,left,right);
        quick(nums,left,index-1);
        quick(nums,index+1,right);
    }
    int partition(int[] nums,int left,int right){
        int pivot = nums[left];
        int j = left;
        for (int i = left+1; i <= right; i++) {
            if (nums[i]<=nums[left]) {
                j++;
                int tmp = nums[i];
                nums[i]=nums[j];
                nums[j]=tmp;
            }
        }
        int tmp = nums[left];
        nums[left]=nums[j];
        nums[j]=tmp;
        return j;
    }
}
```



```java
class Solution {
    public String minNumber(int[] nums) {
        //参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值
        String[] strs = new String[nums.length];
        for(int i =0;i<nums.length;i++){
            strs[i]=String.valueOf(nums[i]);
        }
      	quickSort(strs,0,strs.length-1);
     	 StringBuilder res = new StringBuilder();
      	for(String s:strs){
        	res.append(s);
      	}
      	return res.toString();
    }
    void quickSort(String[] strs,int left,int right){
        if(left>=right) {
            return;
        }
        int pivotIndex =partition(strs,left,right);
        quickSort(strs,left,pivotIndex-1);
        quickSort(strs,pivotIndex+1,right);
    }
    private int partition(String[] strs,int left,int right) {
        String pivot=strs[left];
        //j是pivot第一个区间最后一个元素所在的位置
        int j=left;
        for(int i=left+1;i<=right;i++) {
            if((strs[i]+pivot).compareTo((pivot+strs[i]))<0) {
                j++;
                swap(strs,i,j);
            }
            
        }
        swap(strs,left,j);
        //此时j处于第一个区间的最后一个位置，实际上就是需要的切分元素现在所在的位置了
        return j;
    }
    private void swap(String[] nums,int i,int j) {
        String temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

}
```

### 插入排序

由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。

```java
public class Solution {

    // 插入排序：稳定排序，在接近有序的情况下，表现优异

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            // 先暂存这个元素，然后之前元素逐个后移，留出空位
            int temp = nums[i];
            int j = i;
            // 注意边界 j > 0
            while (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}


```

### 堆排序

堆就是完全二叉树

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

堆排序的基本思想是：将**待排序序列构造成一个大顶堆**heapify，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```java
import java.util.Arrays;
public class HeapSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i=arr.length/2-1;i>=0;i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j>0;j--){
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr,0,j);//重新对堆进行调整
        }

    }
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i
        for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```



```java
class Solution {
    public int[] sortArray(int[] nums) {
        //实战堆排序
        for(int i = nums.length/2-1;i>=0;i--){
            heapify(nums,i,nums.length);
        }
        for(int i = nums.length-1;i>=1;i--){
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            heapify(nums,0,i);
        }
        return nums;
    }
    void heapify(int[] nums,int i,int length){
        int maxindex = i;
        int leftson = 2*i+1;
        int rightson = 2*i+2;
        if(leftson<length&&nums[leftson]>nums[maxindex]) maxindex =leftson;
        if(rightson<length&&nums[rightson]>nums[maxindex]) maxindex = rightson;//选这三者里面最大的作为naxIndex。
        if(maxindex!=i){
            // 如果发生了交换，那么
            int temp = nums[maxindex];
            nums[maxindex] =nums[i];
            nums[i] = temp;
            heapify(nums,maxindex,length);//交换了最大元素之后的位置继续进行堆排序
        }

    }
}
```

[LeetCode排序堆排序题解](https://leetcode.cn/submissions/detail/410212711/)

### 归并排序

[链表排序](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
//        归并排序
       if(head == null || head.next == null) return head;
       ListNode fast = head;
       ListNode slow = head;
       while (fast.next!=null && fast.next.next!=null) {
           fast = fast.next.next;
           slow = slow.next;
       }
        ListNode cnt = slow.next;//从中间切开
        slow.next = null;
        ListNode dummy = new ListNode();
        ListNode res = dummy;
        ListNode left = sortList(head);
        ListNode right = sortList(cnt);
        while (left!=null&&right!=null) {
            if(left.val<right.val) {
                res.next = left;
                left = left.next;
            }else {
                res.next = right;
                right=right.next;
            }
            res = res.next;
        }
        res.next = left!=null? left:right;
        return dummy.next;

    }

}
```



统计逆序对：

```java
class Solution {
    int[] nums,tmp;
    public int reversePairs(int[] nums) {
        //归并排序，计算逆序
        this.nums = nums;
        tmp = new int[nums.length];
        return merge(0,nums.length-1);
    }
    int merge(int left,int right){
        if(left>=right) return 0;
        int m = (left+right)/2;
        int res = merge(left,m)+merge(m+1,right);
        //上面是归并拆分
      
        //下面开始归并排序
        int i = left,j=m+1;
        for(int k =left;k<=right;k++){
            tmp[k] = nums[k];//拷贝一份
            //
        }
        for(int k = left;k<=right;k++){
            //左子区间的元素都遍历了，剩下只要把右子区间剩下的元素加入nums即可
            if(i==m+1)
                while(k<=right) nums[k++]=tmp[j++];
             //同上，此时右子区间的元素已经遍历完，只需要添加左子区间的元素到nums
            else if(j==right+1)
                while(k<=right) nums[k++]=tmp[i++];
            else if(tmp[i]<=tmp[j]){
                //往nums添加一个按从小到达排列的元素，不引入逆序对
                nums[k]=tmp[i++];
            }else {
                //对应 tmp[i] > tmp[j]
                res+=m-i+1;//也就是说，在合并左右子区间时，新引入了共m-i+1对 以tmp[j]为右元素的逆序对
                nums[k]=tmp[j++];
            } 
        }
        return res;
    }
}
```



## 二分查找法 

**前提是数组为有序数组**，同时题目还强调**数组中无重复元素**

```java
class Solution {
    public int search(int[] nums,int target){
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;//左闭右闭
    }
}
```



```CPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        return right;
    }
};

```

## KMP

```CPP
void kmp(int* next, const string& s){
    next[0] = -1;
    int j = -1;
    for(int i = 1; i < s.size(); i++){
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

## 二叉树 

二叉树的定义：

```CPP
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 前序中序后序遍历

 中序遍历的时候 访问到的元素是从小到大顺序排列的



```java
中序遍历过程模板
public void inorder(TreeNode root){
        if (root == null) return ;    //终止条件
        inorder(root.left);           //访问左子树
        对当前节点进行一些操作          //访问根节点-----在遍历过程中希望实现的操作
        inorder(root.right);          //访问右子树
    }
```



纠正二叉搜索树

输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。



```java
class Solution {
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);
    TreeNode err1 = null;
    TreeNode err2 = null;
    public void recoverTree(TreeNode root) {
        inorder(root);
        int tmp = err1.val;
        err1.val = err2.val;
        err2.val = tmp;
    }
    void inorder(TreeNode root) {
        if(root == null) return;
        inorder(root.left);
        if(pre.val>root.val&&err1==null) err1=pre;//！不相邻，前大后小，第一个错误就要取大的
        if(pre.val>root.val&&err1!=null) err2=root;//哦哦哦哦哦！不相邻，前大后小，第二个错误就要取小的
        pre = root;
        inorder(root.right);

    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //非递归方式实现中序遍历
        List<Integer> res = new LinkedList();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root!=null||!stack.isEmpty()) {
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
    
}
```





### 深度优先遍历（递归） 

前序遍历（中左右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```
中序遍历（左中右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```
后序遍历（左右中）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

### 深度优先遍历（迭代法）

相关题解：[0094.二叉树的中序遍历](https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.二叉树的中序遍历.md)

前序遍历（中左右）
```CPP
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}

```

中序遍历（左中右）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result; // 存放中序遍历的元素
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); 
            if (node->right) st.push(node->right);  // 右
            st.push(node);                          // 中
            st.push(NULL); 
            if (node->left) st.push(node->left);    // 左
        } else {
            st.pop(); 
            node = st.top(); 
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

后序遍历（左右中）
```CPP
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```
### 广度优先遍历（队列）

相关题解：[0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)

```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}

```



可以直接解决如下题目：

* [0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)
* [0199.二叉树的右视图](https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.二叉树的右视图.md)
* [0637.二叉树的层平均值](https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.二叉树的层平均值.md) 
* [0104.二叉树的最大深度 （迭代法）](https://programmercarl.com/0104.二叉树的最大深度.html)

* [0111.二叉树的最小深度（迭代法）](https://programmercarl.com/0111.二叉树的最小深度.html)
* [0222.完全二叉树的节点个数（迭代法）](https://programmercarl.com/0222.完全二叉树的节点个数.html)

### 二叉树深度

```CPP
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

### 二叉树节点数量

```CPP
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

## 回溯算法 

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。







```CPP
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

### 回溯算法：组合



```java
class Solution {
    List<List<Integer>> res= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTrace(n,k,1);//递归函数返回值为void，一般直接就在参数里面修改
        return res;
    }
    void backTrace(int n,int k, int s){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        /*
        已经选择的元素个数：path.size();
        还需要的元素个数为: k - path.size();
        在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
        */
        //可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠s
        for(int i =s;i<=n-(k-path.size())+1;i++ ){
            path.add(i);
            backTrace(n,k,i+1);
            path.removeLast();
        }
    }
}
```



![77.组合1](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67.png)



### 复原IP地址

[力扣题目链接](https://leetcode.cn/problems/restore-ip-addresses/)

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

示例 1：

* 输入：s = "25525511135"
* 输出：["255.255.11.135","255.255.111.35"]

示例 2：

* 输入：s = "0000"
* 输出：["0.0.0.0"]



```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        //startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。
        //本题我们还需要一个变量pointNum，记录添加逗点的数量。
        if (s.length()>12) return ans;
        backTrace(s,0,0);
        return ans;
    }
    void backTrace(String s, int begin,int pointNumber) {
        if (pointNumber==3){
            //此时已经到达了最后一个阶段，判断begin到最后的一段是否合法，不合法就不添加
            if (isValid(s,begin,s.length()-1))
                ans.add(s);
            return;
        }
        for (int i = begin; i < s.length(); i++) {
            if (isValid(s,begin,i)){
                s=s.substring(0, i + 1) + "." + s.substring(i + 1);
                //插入一个。
                pointNumber++;
                backTrace(s,i+2,pointNumber);
                pointNumber--;
                s=s.substring(0, i + 1) + s.substring(i + 2);
            }else {
                continue;
            }
        }
    }
    boolean isValid(String s,int begin,int end) {
        if (begin>end) return false;
        if (s.charAt(begin)=='0'&&begin!=end){
            return false;
            //0开头的数字不合法，此时begin和end不相等的
        }
        int num =0;

        for (int i = begin; i <= end; i++) {
            if (s.charAt(i)>'9'||s.charAt(i)<'0')
                return false;
            num = num *10 + (s.charAt(i)-'0');
            if (num>255)
                return false;
        }
        return true;
    }
}
```

## 并查集 

```CPP
    int n = 1005; // 根据题意而定 
    int father[1005];

    // 并查集初始化
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
```

## 滑动窗口



### 双指针



判断回文数

```java
boolean isPali(String s,int begin,int end) {
    for (int i = begin, j = end; i < j; i++, j--) {
        if (s.charAt(i)!=s.charAt(j))
            return false;
    }
    return true;
}
```



### 统计连续子数组个数

给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。



**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**示例 2:**

```
输入: nums = [1,2,3], k = 0
输出: 0
```



**提示:**

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`



注意：本题与主站 713 题相同：https://leetcode-cn.com/problems/subarray-product-less-than-k/

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        //滑动窗口
        //使用一个变量 cur 记录当前窗口的乘积，使用两个变量 j 和 i 分别代表当前窗口的左右端点。
        int len = nums.length;
        int ans = 0;
        if (k<=1) return 0;
        for (int i = 0, j = 0, cur = 1; i < len; i++) {
            cur*=nums[i];
            // 当 cur>=k 时，我们考虑将左端点 j 右移，同时消除原来左端点元素 nums[j] 对 cur 的贡献，
            // 直到 cur>=k 不再满足，这样我们就可以得到每个右端点 nums[i] 的最远左端点 nums[j]
            while (cur>=k) cur/=nums[j++];
            ans+=i-j+1;
        }
        return ans;
        //请找出该数组内乘积小于 k 的连续的子数组的个数。
    }
}
```



### offer || 014 是否包含 `s1` 的某个变位词。

给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。



**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```



**提示：**

- `1 <= s1.length, s2.length <= 104`
- `s1` 和 `s2` 仅包含小写字母



注意：本题与主站 567 题相同： https://leetcode-cn.com/problems/permutation-in-string/



```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        int[] list1 = new int[26];
        int[] list2 = new int[26];
        if (l2<l1) return false;
        //// 同时填充两个字符表，其中alpha1填充完毕，alpha2只填充了前面一部分。
        for (int i = 0; i < l1; i++) {
            list1[s1.charAt(i)-'a']++;
            list2[s2.charAt(i)-'a']++;
        }
        if (Arrays.equals(list1,list2)) return true;
        for (int i = l1; i < l2; i++) {
            //窗口右边新来的加加
//            窗口左边要排除的渐渐
            list2[s2.charAt(i)-'a']++;
            list2[s2.charAt(i-l1)-'a']--;//注意这里，因为有i-li所以要额外写一个遍历
            // 判断当前状态下，s2窗口中的字符是否和s1的字符种类和数量都一致。
            // Arrays.equals() 是通过遍历判断的，自己些for也一样。
            if (Arrays.equals(list2,list1)) return true;
        }
        return false;
    }
}
```





### 滑动窗口统计变位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。



**示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (p.length()>s.length()) return ans;
        int[] listp = new int[26];
        int[] lists = new int[26];
        for (int i = 0; i < p.length(); i++) {
            listp[p.charAt(i)-'a']++;
            lists[s.charAt(i)-'a']++;
        }

        if (Arrays.equals(listp,lists)) ans.add(0);
        for (int i = p.length(); i < s.length(); i++) {
            lists[s.charAt(i)-'a']++;
            lists[s.charAt(i-p.length())-'a']--;
            if (Arrays.equals(listp,lists)) ans.add(i-p.length()+1);
        }
        return ans;
    }
}
```

## 前缀和算法



### 和大于等于target的连续子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int left = 0;
        int right = 1;
        int res = Integer.MAX_VALUE;
        while (right<=nums.length) {
            if (preSum[right]-preSum[left]>=target){
                res = Math.min(right-left,res);
                left++;
                right=left;
            }else
                right++;

        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= nums.length; i++) {
            // 前缀和数组下标 [0,i] 范围内找到满足「值小于等于 s−target」
            // 的最大下标，充当子数组左端点的前一个值。
            // 左边的范围小于等于，那么就是说preSum[i]-preSum[left]>=target
            int s = preSum[i],d = s-target;
            int left = 0, right = i;
            while (left<right){
                int mid = (left+right+1)>>1;
                if (preSum[mid]<=d) left=mid;//如果中间的前缀和小于需要的。
                else
                    right = mid -1;
            }
            if (preSum[right]<=d) res = Math.min(res,i-right);
        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



### offer010 和为k的子数组个数

给定一个整数数组和一个整数 `k` **，**请找到该数组中和为 `k` 的连续子数组的个数。



**示例 1：**

```
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
```

**示例 2：**

```
输入:nums = [1,2,3], k = 3
输出: 2
```



**提示:**

- `1 <= nums.length <= 2 * 104`



统计以每一个 *n**u**m**s*[*i*] 为结尾，和为 *k* 的子数组数量即是答案。

我们可以预处理前缀和数组 `sum`（前缀和数组下标默认从 1 开始），对于求解以某一个 *n**u**m**s*[*i*] 为结尾的，和为 *k* 的子数组数量，本质上是求解在 [0,*i*] 中，`sum` 数组中有多少个值为 *s**u**m*[*i*+1]−*k* 的数，这可以在遍历过程中使用「哈希表」进行同步记录。

```JAVA
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length, ans = 0;
        int[] pre = new int[n+1];
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + nums[i];
        }
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        for (int i = 1; i <= n; i++) {
            int tmp = pre[i], d = tmp-k;//求解在 [0,i] 中，
            // pre 数组中有多少个值为 pre[i+1]−k 的数，
            ans+=map.getOrDefault(d,0);//看看有无目标的值
            map.put(tmp,map.getOrDefault(tmp,0)+1);
        }
        return ans;
    }
}
```



### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int len = nums.length;
        int ans = 0;
        int[] pre = new int[len + 1];
        HashMap<Integer, Integer> map = new HashMap<>();
        //「某个前缀和出现的最小下标」
        map.put(0,0);
        for (int i = 0; i < len; i++) {
            pre[i+1] = pre[i]+(nums[i]==0?-1:1);
            //将 nums[i] 为 0 的值当做 −1 处理。
        }
        for (int i = 1; i <= len; i++) {
            int t = pre[i];
            if (map.containsKey(t))
                // get(t)的目的是，是前缀和，所以找到相同的t的时候，
                // 区间之间长度就是0了
                ans = Math.max(ans,i-map.get(t));
//            每遍历一个元素，就用「当前前缀和」去前面已经统计的前缀和
//            中找到一个使得两者之间区间为0的，并计算这个区间长度
            else
                map.put(t,i);
        }
        return ans;
    }
}
```



### 二位前缀和子数组



给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回左上角 `(row1, col1)` 、右下角 `(row2, col2)` 的子矩阵的元素总和。

<img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img" style="zoom:50%;" />



```java
class NumMatrix {
    int[][] matrix = null;
    int[][] sum = null;
    public NumMatrix(int[][] matrix) {
        this.matrix=matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        sum=new int[m +1][n +1];
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j < n; j++) {
                sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+matrix[i][j];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row1][col2+1]-sum[row2+1][col1]+sum[row1][col1];
    }
}
```



## 算数运算

### 进位与非进位

设两数字的二进制形式 ,观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。



![Picture1.png](assets\56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png)





```java
// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0 
//    1     1         0           1
// 
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
// 
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。

class Solution {
    public int add(int a, int b) {
        // a的二进制表示与b的二进制，
        // 每一位取异或运算，得到无进位和的结果，每一位取与运算，左移<<一位，得到进位，
        // 不用担心整数转二进制，因为他就是默认就是二进制存取的直接去&就可以了
        while(b!=0){
            int c = (a&b)<<1;//进位，左移一位
            a = a ^ b;//非进位和
            b=c;//当进位为0的时候就可以不需要进位，直接非进位和就可以了
        }
        return a;
    }
}
```

### 不用除法的除法：倍增求解

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。



```java
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        //返回完异常值
        //倍增法，每次减去一个2^x倍
        boolean sign = false;
        if((dividend>0&&divisor>0)||(dividend<0&&divisor<0))
            sign = true;//正数标记
        dividend = dividend > 0? -dividend:dividend;
        divisor = divisor > 0? -divisor:divisor;
        int ans = 0;
        //dividend / divisor
        while(dividend<=divisor){
            int tmp = divisor,count =1;
            //tmp + tmp >= dividend
            while(tmp>=dividend-tmp){
                tmp+=tmp;
                count+=count;
            }
            dividend = dividend - tmp;
            ans = ans+count;
        }
        return sign?ans:-ans;
    }
}


```



### 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数

```
如果我们是使用「朴素解法」求解的话，无论是从高位进行统计，还是从低位进行统计，最后一位扫描的都是边缘的数（如果是 1 就计数，不是 1 就不计数）。

从低位到高位，最后一步在扫描最高位之前，统计出 1 的个数应该等同于将 i 左移一位，并在最低位补 0，也就是等于 ans[i << 1]，这时候就要求我们在计算 i 的时候 i << 1 已经被算出来（从大到小遍历）
从高位到低位，最后一步在扫描最低位之前，统计出 1 的个数应该等同于将 i 右移一位，并在最高位补 0，也就是等于 ans[i >> 1]，这时候就要求我们在计算 i 的时候 i >> 1 已经被算出来（从小到大遍历）

```





```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for(int i=1;i<n+1;i++)
        //res[i] = 「i >> 1 所包含的 1 的个数」+「i 的最低位是否为 1」
            res[i] = res[i>>1] + (i&1);
        return res;
    }
}
```



### [剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,100]
输出：100
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

哈希表解法的空间复杂度是 *O*(*n*) 的，而题目的【进阶】部分提到应当使用常数空间来做。

其中一个比较容易想到的做法，是利用int类型固定为 32 位。

**使用一个长度为 32 的数组 cnt[] 记录下所有数值的每一位共出现了多少次 1，再对cnt[] 数组的每一位进行mod 3 操作，重新拼凑出只出现一次的数值。**

举个 🌰，考虑样例 `[1,1,1,3]`，1 和 3 对应的二进制表示分别是 `00..001` 和 `00..011`，存入 *c**n**t*[] 数组后得到 `[0,0,...,0,1,4]`。进行 *m**o**d* 3 操作后得到 `[0,0,...,0,1,1]`，再转为十进制数字即可得「只出现一次」的答案 3。

```java
class Solution {
    public int singleNumber(int[] nums) {
//        出现了三次，那么取模3，应该就是等于0；
        int[] cnt = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                if(((num>>i) & 1)==1){
                    cnt[i]++;
//                    如果当前元素右移i个单位是1的话，就在cnt加加
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i]%3==1)
//                mod 3 之后，其实也不会出现2，因为mod 3 就是去掉了重复3次的，
                ans+=(1<<i);
        }
        return ans;
    }
}
```





### [剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/)-位运算

给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。



**示例 1:**

```
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
```

根据题意进行模拟即可，利用每个 *w**or**d**s*[*i*] 只有小写字母，且只需要区分两字符是否有字母重复。

我们可以使用一个 `int` 来代指某个 *w**or**d*[*i*]：低 26 来代指字母 `a-z` 是否出现过。

然后对每个「字符对」所对应的两个 `int` 值执行 `&` 操作（若两字符无重复字符，则结果为 0），并得出最终答案。

位运算：比较两个字符串不相同

```java
class Solution {
    public int maxProduct(String[] words) {
//        位运算，进行&操作，如果两个字符有重复的字符马，那么就是1，无重复的就是0
        int length = words.length;
        int idx = 0;
        int[] masks = new int[length];
        for (String word : words) {
            int t = 0;
            for (int i = 0; i < word.length(); i++) {
                int u = word.charAt(i)-'a';
                t |= (1<<u);
            }
//            对每一个word进行或运算，计算1左移u位的，
//            则 abc 可以表示为 111 def 可以表示为 111000
            masks[idx++] = t;
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < i; j++) {
//         // 如果两个字符串不包含相同元素 那么与运算肯定为 0
                if ((masks[i]&masks[j])==0)
                    ans = Math.max(ans, words[i].length() * words[j].length());
            }
        }
        return ans;
    }
}
```
