# 758、字符串中的加粗单词

给定一个关键词集合 `words` 和一个字符串 `s`。  
要求：在所有 `s` 中出现的关键词前后位置上添加加粗闭合标签 `<b>` 和 `</b>`。如果两个子串有重叠部分，则将它们一起用一对闭合标签包围起来。同理，如果两个子字符串连续被加粗，那么你也需要把它们合起来用一对加粗标签包围。最后返回添加加粗标签后的字符串 `s`。

思路：  
先使用一个数组isBold保存S中的每个字符是否应该加粗，判断的方式是，遍历words中的每个字符串，找出S中有哪些位置和它匹配。  
是否增加标签**的方法是当前字符需要加粗，但是其前面的字符不用加粗，或者当前字符是第一个字符。 是否增加标签**的方法是当前字符需要加粗，但是其后面的字符不用加粗，或者当前字符是最后一个字符。

```java
public class Huawei {
    public static void main(String[] args) {
        String[] words = {"asas","dsw","12"};
        String s = "asasdsdasd12121";
        new Huawei().BoldWords(words,s);
    }
    static void BoldWords(String[] words,String s){
        int len = s.length();
        boolean[] isBold = new boolean[len+1];
        for (String word : words) {
            for (int i = 0; i < len-word.length(); i++) {
                String subs = s.substring(i, i+word.length());
                if (subs.equals(word)){
                    for (int j = i; j < i + word.length(); j++) {
                        isBold[j] = true;
                    }
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len; i++) {
            if (isBold[i]&&(i==0||!isBold[i-1])) sb.append("<br>");
            //如果当前为加醋，前面不是加粗，或者前面是i==0；
            sb.append(s.charAt(i));
            if (isBold[i]&&(i==len-1||!isBold[i+1])) sb.append("</br>");
        }
        System.out.println(sb.toString());
    }
}

```

运行结果：

```latex
<br>asas</br>dsdasd<br>1212</br>1
```

# 

一、数据结构问题

## 

字符串相关问题

> 每隔8个输出一下

```java
String ss = sb.toString();
while (ss.length()>0) {
    System.out.println(ss.substring(0,8));
    ss = ss.substring(8);
}
```

### 

HJ4 字符串分隔

描述  
•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；  
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。  
输入描述：  
连续输入字符串(每个字符串长度小于等于100)  
输出描述：  
依次输出所有分割后的长度为8的新字符串  
示例1  
输入：

```
abc
```

输出：

```
abc00000
```

```java
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            String s = in.next();
            StringBuilder sb = new StringBuilder();
            sb.append(s);
            int addZeroNum = 8-sb.length()%8;
            while (addZeroNum>0&&addZeroNum<8) {
                sb.append('0');
                addZeroNum--;
            }
            String ss = sb.toString();
            while (ss.length()>0) {
                System.out.println(ss.substring(0,8));
                ss = ss.substring(8);
            }
        }
    }
```

## 

数组问题

### 

41. 缺失的第一个正整数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        //最小的正整数，遍历
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            while (nums[i]>0 && nums[i]<=len && nums[i]!=nums[nums[i]-1]){
                //  1 2 3 0 4
                //  - - - ! -
                // 4应该在下标3的位置
                int j = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i]!=i+1){
                return i+1;//如果当前位置不存在对应的合理的值，就返回
            }
        }
        return len+1;
    }
}
```

### 

HJ3.**明明的随机数**

描述

明明生成了�_N_个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。

数据范围： 1≤�≤1000 1≤_n_≤1000 ，输入的数字大小满足 1≤���≤500 1≤_v**a**l_≤500

输入描述：

第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的"示例"。

输出描述：

输出多行，表示输入数据处理后的结果

示例1

输入：

```
3
2
2
1
```

输出：

```
1
2
```

说明：

```
输入解释：
第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：
2
2
1
所以样例的输出为：
1
2
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            int n = in.nextInt();
            int[] nums = new int[501];
            for(int i = 0;i<n;i++){
                int next = in.nextInt();
                // System.out.println(next);
                nums[next] =1 ;
            }
            for(int i = 0;i<501;i++){
                if (nums[i]==1) {
                    System.out.println(i);
                }
            }
            
        }
    }
}
```

## 

链表问题

> LRU缓存：`**int oldestKey = cache.keySet().iterator().next();**`： 这一行代码定义了一个名为`oldestKey`的整型变量，并将其初始化为`cache`键集的第一个键。这里的变量名`oldestKey`暗示着这个键是“最旧”的，可能是按插入顺序来看的第一个元素，特别是在使用`LinkedHashMap`这样可以保持插入顺序的`Map`实现时。不过，如果使用的是`HashMap`，则不能保证这个键是最旧的，因为`HashMap`不保证任何顺序。

### 

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：

1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；

3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。

那么，什么数据结构同时符合上述条件呢？**哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。**所以结合一下，形成一种新的数据结构：`哈希链表 LinkedHashMap`。

```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer,Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)){
            return -1;
        }
        int val = cache.get(key);
        cache.remove(key);
        cache.put(key,val);//再次插入就实现了最新的使用的标记
        return cache.get(key);
    }
    
    public void put(int key, int value) {
        if(cache.containsKey(key)){
            cache.put(key,value);
            int val = cache.get(key);
            cache.remove(key);
            cache.put(key,val);//再次插入
            return;
        }
        if(cache.size()>=cap){
            //使用iterator()方法获取迭代器，可以遍历集合中的元素。next()方法用于返回下一个元素，即获取最早的键。
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        cache.put(key,value);
        return;
    }
}
```

> 用 LinkedHashMap 可以很容易实现 LRU 缓存，不过面试的时候估计这样不好，还是尽量自己实现数据结构吧🤣
> 
> 主要想法是使用 JDK 提供的 HashMap，然后自己写一个 Node 节点类，用来保存 value ，并且通过这个 Node 里面的 prev、next 指针将各个值串联起来，这样就维护了顺序。
> 
> 很重要的一个细节是，Node 里面还要加上 key （尽管 HashMap 本来就存了一份）。
> 
> 原因是当缓存达到容量上限时，就要先移除尾部的节点，这个时候如果只移除链表的 tail 节点，忽略了 HasmMap 也要 remove ，后面再访问这个被移除的 key 就会造成空指针异常！！！
> 
> 所以我们在 Node 节点里面加上 key ，删掉 tail 之前先 remove 掉 HasmMap 的这个 key，就很方便了。
> 
> 不适用LinkedList:  

```java
import java.util.*;
public class Solution {
    private int capacity;
    private Map<Integer,Node> map;
    private Node head;
    private Node tail;
    private int used;
    class Node{
        int key;
        int value;
        Node prev;
        Node next;
        Node(int key,int value,Node prev,Node next){
            this.key = key;
            this.value = value;
            this.prev = prev;
            this.next = next;
        }
    }
 public Solution(int capacity) {
    //构造函数
    this.capacity = capacity;
    this.map =  new HashMap<>();
    this.used= 0;
 }
 public int get(int key) {
 // write code here
    if(!map.containsKey(key)){
        return -1;
    }
    makeRecently(key);
    return map.get(key).value;
 }
 public void set(int key, int value) {
 // write code here
    if(map.containsKey(key)){
        map.get(key).value = value;
        makeRecently(key);
        return;
    }
    if(used==capacity){
        map.remove(tail.key);
        tail = tail.prev;
        tail.next = null;
        used--;
    }
    if(head==null){
        head = new Node(key,value,null,null);
        tail = head;
    }
    else{
        //head不为空
        Node t = new Node(key,value,null,head);
        head.prev = t;
        head = t;
    }
    map.put(key,head);
    used++;
 }
 private void makeRecently(int key){
    Node t = map.get(key);
    if(t!=head){
        if(t==tail){
            tail = tail.prev;
            tail.next = null;
        }else{
            t.prev.next = t.next;//将t跳过了
            t.next.prev = t.prev;//将next的向前指的顺序纠正
        }
        t.prev = null;
        t.next = head;
        head.prev = t;
        head =t;
    }
 }
}
```

### 

实现一个cache，包括LRU算法和在x秒后过期

```java
import java.util.LinkedHashMap;  
import java.util.Map;  
import java.util.concurrent.ScheduledExecutorService;  
import java.util.concurrent.Executors;  
import java.util.concurrent.TimeUnit;  
  
public class LRUCacheWithExpiration<K, V> {  
    // 缓存的最大容量  
    private final int capacity;  
    // 缓存项的过期时间（秒）  
    private final long expirationTimeInSeconds;  
    // 使用LinkedHashMap实现LRU缓存，accessOrder设置为true以启用LRU顺序  
    private final LinkedHashMap<K, CacheEntry<V>> cacheMap;  
    // 定时任务执行器，用于清理过期的缓存项  
    private final ScheduledExecutorService expirationExecutor;  
  
    // 内部类CacheEntry，用于存储缓存值和过期时间  
    private static class CacheEntry<V> {  
        V value;  
        long expirationTime;  
  
        CacheEntry(V value, long expirationTime) {  
            this.value = value;  
            this.expirationTime = expirationTime;  
        }  
    }  
  
    // 构造函数  
    public LRUCacheWithExpiration(int capacity, long expirationTimeInSeconds) {  
        this.capacity = capacity;  
        this.expirationTimeInSeconds = expirationTimeInSeconds;  
        // 初始化LRU缓存，设置accessOrder为true，以便按访问顺序进行LRU操作  
        this.cacheMap = new LinkedHashMap<>(capacity, 0.75f, true) {  
            // 重写removeEldestEntry方法，当Map大小超过指定容量时，删除最老的元素  
            @Override  
            protected boolean removeEldestEntry(Map.Entry<K, CacheEntry<V>> eldest) {  
                return size() > LRUCacheWithExpiration.this.capacity;  
            }  
        };  
        // 初始化定时任务执行器  
        this.expirationExecutor = Executors.newSingleThreadScheduledExecutor();  
        // 安排定时任务，每隔expirationTimeInSeconds秒执行一次清理过期缓存项的操作  
        this.expirationExecutor.scheduleAtFixedRate(this::evictExpiredEntries, expirationTimeInSeconds, expirationTimeInSeconds, TimeUnit.SECONDS);  
    }  
  
    // 获取缓存项  
    public synchronized V get(K key) {  
        CacheEntry<V> entry = cacheMap.get(key);  
        if (entry == null || isExpired(entry.expirationTime)) {  
            // 缓存项不存在或已过期，返回null  
            return null;  
        }  
        // 更新缓存项的访问顺序（移到尾部，表示最近访问）  
        cacheMap.remove(key);  
        cacheMap.put(key, entry);  
        // 返回缓存值  
        return entry.value;  
    }  
  
    // 添加或更新缓存项  
    public synchronized void put(K key, V value) {  
        // 创建新的缓存项，设置过期时间  
        CacheEntry<V> newEntry = new CacheEntry<>(value, System.currentTimeMillis() + (expirationTimeInSeconds * 1000));  
        // 将新的缓存项添加到LRU缓存中，如果缓存已满，则会自动删除最老的元素  
        cacheMap.put(key, newEntry);  
    }  
  
    // 清理过期缓存项的方法  
    private void evictExpiredEntries() {  
        long currentTime = System.currentTimeMillis();  
        // 遍历缓存，移除已过期的缓存项  
        cacheMap.entrySet().removeIf(entry -> isExpired(entry.getValue().expirationTime));  
    }  
  
    // 判断缓存项是否过期  
    private boolean isExpired(long expirationTime) {  
        return expirationTime <= System.currentTimeMillis();  
    }  
  
    // 关闭缓存，停止定时任务执行器  
    public void close() {  
        expirationExecutor.shutdown();  
        try {  
            if (!expirationExecutor.awaitTermination(60, TimeUnit.SECONDS)) {  
                expirationExecutor.shutdownNow();  
            }  
        } catch (InterruptedException e) {  
            expirationExecutor.shutdownNow();  
            Thread.currentThread().interrupt();  
        }  
    }  
}
```

### 

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/rotate1.jpg#id=bmYtW&originHeight=302&originWidth=712&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return head;
        int n = 1;
        ListNode tail = head;
        while(tail.next!=null){
            tail = tail.next;
            n++;// length
        }
        k = k%n;//防止重复移动
        if(k<1) return head;
        ListNode fast = head;
        ListNode slow = head;
        while(k-->0){
            fast = fast.next;
        }
        
        while(fast.next!=null){
            fast= fast.next;
            slow = slow.next;
        }
        ListNode newHead = slow.next;
        slow.next = null;
        tail.next = head;
        return newHead;
    }
}
```

### 

[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 [**深拷贝**](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/e1.png#id=z1UVT&originHeight=386&originWidth=1900&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。

算法流程：

- 若头节点 head 为空节点，直接返回 null 。
- 初始化： 哈希表 dic ， 节点 cur 指向头节点。
- 复制链表：  
    建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） 。  
    cur 遍历至原链表下一节点。
- 构建新链表的引用指向：  
    构建新节点的 next 和 random 引用指向。  
    cur 遍历至原链表下一节点。
- 返回值： 新链表的头节点 dic[cur] 。

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node cur = head;
        Map<Node,Node> map = new HashMap<>();
        while(cur!=null){
            //map storage the new Node
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        while(cur!=null){
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```

### 

[剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1715474951264-007e6f63-e6f1-4523-be84-8beadab56301.png#averageHue=%23f3f3f3&clientId=u3a18be3a-46a6-4&id=dKGpc&originHeight=342&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32741&status=done&style=none&taskId=ue2088a6f-5d0d-4adf-a1e6-650ab01b41b&title=)

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
//        使用两个辅助栈
        ArrayDeque<Integer> stk1 = new ArrayDeque<>();
        ArrayDeque<Integer> stk2 = new ArrayDeque<>();
        while (l1!=null){
            stk1.push(l1.val);
            l1 = l1.next;
        }
        while (l2!=null){
            stk2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;//储存进位
        ListNode res = null;//储存结果
        while (!stk1.isEmpty()||!stk2.isEmpty()||carry!=0) {
            int digit1 = stk1.isEmpty()?0:stk1.pop();
            int digit2 = stk2.isEmpty()?0:stk2.pop();
            int sum = digit1+digit2+carry;
            carry = sum/10;
            sum = sum%10;
            ListNode tmp = new ListNode(sum);
            tmp.next = res;
            res = tmp;
        }
        return res;
    }
}
```

### 

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。  
`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。  
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。  
**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/reverse_ex1.jpg#id=WF3kZ&originHeight=222&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head==null||head.next ==null) return head;
        ListNode tail = head;
        for(int i = 0;i<k;i++){
            if(tail==null) return head;
            tail = tail.next;
        }
        ListNode newHead = reverse(head,tail);
        head.next = reverseKGroup(tail,k);//这个时候的head就是反转好的队尾了
        return newHead;
    }
    private ListNode reverse(ListNode head,ListNode tail){
        ListNode prev = null;
        ListNode next = null;
        while(head!=tail){
            next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;//返回头部，就是反转的头部了
    }
}
```

![](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/image-20240320134441671.png#id=o3Znu&originHeight=474&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### 

[剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

`L0 → L1 → … → Ln-1 → Ln`  
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。  
**示例 1:**

![](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png#id=G9bQk&originHeight=222&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        ////将主链表划分为 前一段子链表和后一段子链表，
        // 对于后一段子链表进行翻转，同时对于这两条链表进行重构;
        ArrayDeque<ListNode> deque = new ArrayDeque<ListNode>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        while (head!=null) {
            ListNode next = head.next;
            head.next = null;
            deque.add(head);
            head = next;
        }
        ListNode curr = dummy;
        while (!deque.isEmpty()) {
            ListNode start = deque.pollFirst();
            curr.next = start;
            //循环遍历deque双端，直至队列为空
            if (!deque.isEmpty()){
                ListNode last = deque.pollLast();
                start.next = last;//curr-》start-》last
                curr = last;//curr专程last
            }else {
                start.next = null;
            }
        }
        return;
    }
}
```

### 

两个链表合并

```java
public ListNode mergeTwoLists(ListNode a, ListNode b) {
    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode(0);
    ListNode tail = head, la = a, lb = b;
    while (la != null && lb != null) {
        if (la.val < lb.val) {
            tail.next = la;
            la = la.next;
        } else {
            tail.next = lb;
            lb = lb.next;
        }
        tail = tail.next;
    }
    tail.next = (la != null ? la : lb);
    return head.next;
}
```

> 多个链表合并可以遍历，  

```java
public ListNode mergeKLists(ListNode[] lists) {
    ListNode ans = null;
    for (ListNode list : lists) {
        ans = mergeTwoLists(ans,list);
    }
    return ans;
}
```

### 

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例 1：**  
![](https://raw.githubusercontent.com/52chen/imagebed2023/main/rev2ex2.jpg#id=bT9HK&originHeight=222&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1,head);
        ListNode prev = dummy;
        ListNode curr = head;

        //直接找到对应的位置，然后再切断再反转再接上
        for (int i = 1; i < left; i++) {
            prev = curr;
            curr = curr.next;
        }
        for (int i = 0; i < right - left; i++) {
            ListNode tmp = curr.next;
            curr.next = tmp.next;//curr指向tmp后面
            tmp.next = prev.next;//把tmp接龙，接到要逆向的prev的后面
            prev.next = tmp;//这三部=部分不能调换顺序，因为curr要用tmp
            //tmp要用prev，最后才可以切换prev的next
        }
        return dummy.next;
    }

}
```

### 

两两交换链表

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。  
**示例 1：**  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1714876109933-7fa8e0af-facf-433a-b974-57769ebd91ba.png#averageHue=%23f5f5f5&clientId=uae8ec878-cd5c-4&from=paste&id=u95f8df60&originHeight=222&originWidth=422&originalType=url&ratio=2&rotation=0&showTitle=false&size=36253&status=done&style=none&taskId=ufbe88286-0066-4003-a348-0e7f34819b2&title=)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**  
![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1714876219992-f689ea3c-7742-4ce9-958a-1cb17d403f3b.jpeg)

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummy = new ListNode(-1,head);
    ListNode prev = dummy;
    ListNode cur = head;
    while (cur!=null&&cur.next!=null){
        ListNode tmp = cur.next.next;
        prev.next = cur.next;
        cur.next.next = cur;
        cur.next = tmp;
        cur = cur.next;
        prev = prev.next.next;
    }
    return dummy.next;
}
```

## 

栈的使用

### 

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**  
![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1715474899367-71184728-ce12-4bf7-9eaf-e7d33f12156f.png#averageHue=%23bfbfbf&clientId=u3a18be3a-46a6-4&id=rSlo6&originHeight=161&originWidth=412&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9617&status=done&style=none&taskId=ue7976eb9-b30a-4462-b96b-c3dcbedd872&title=)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

```java
class Solution {
    public int trap(int[] height) {
        int count = 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        //维持一个递减的栈，递增了显然就是有一个坑
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[stack.peek()]<height[i]){
                //出现递增的时候
                int popped = stack.pop();
                while (!stack.isEmpty() && height[popped]==height[stack.peek()])
                    stack.pop();//继续弹出去
                //Att:如果此时stack为空了，说明当前凹槽没有左边边界，不得行
                if (!stack.isEmpty()){
                    int min = Math.min(height[stack.peek()], height[i]);
                    //stack可以一直往左边吐，吐到和当前凹槽不相等的地方，所以计算宽度用的peek-1；
                    count+=(min-height[popped])*(i- stack.peek()-1);
                }
            }
            stack.push(i);
        }
        return count;
    }
}
```