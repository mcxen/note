### 大数相乘算法

编写两个任意位数的大数相乘的程序，给出计算结果。比如：

> 题目描述： 输出两个不超过100位的大整数的乘积。
> 输入： 输入两个大整数，如1234567 和 123
> 输出： 输出乘积，如：151851741

```javascript
求 1234567891011121314151617181920 * 2019181716151413121110987654321 的乘积结果
```

所谓大数相乘（Multiplication algorithm），就是指数字比较大，相乘的结果超出了基本类型的表示范围，所以这样的数不能够直接做乘法运算。

#### 模拟乘法累加 - 改进

简单来说，就是先不算任何的进位，也就是说，**将每一位相乘，相加的结果保存到同一个位置，到最后才计算进位**。


```sql
        9  8
×       2  1
-------------
       (9)(8)  <---- 第1趟: 98×1的每一位结果 
  (18)(16)     <---- 第2趟: 98×2的每一位结果 
-------------
  (18)(25)(8)  <---- 这里就是相对位的和，还没有累加进位
```

这里唯一要注意的便是进位问题，我们可以先不考虑进位，当所有位对应相加，产生结果之后，再考虑。从右向左依次累加，如果该位的数字大于10，那么我们用取余运算，在该位上只保留取余后的个位数，而将十位数进位（通过模运算得到）累加到高位便可，循环直到累加完毕。


```java
public class Main {
    public static void main(String[] args) {
        Main sol = new Main();
        // 测试案例1
        String s1 = "0";
        String t1 = "0";
        System.out.println(sol.solve(s1, t1)); // 输出: "56088"
    }
    public String solve (String s, String t) {
        if (s==null||s.length()==0) return t;
        if (t==null||t.length()==0) return s;
        //数组实现大数乘法
        int m = s.length();
        int n = t.length();
        int[] ans = new int[m + n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans[i+j+1]+=(s.charAt(i)-'0')*(t.charAt(j)-'0');
            }
        }
        int c = 0;
        for (int i = m+n-1;i>=0;i--){
            ans[i]+=c;
            c = ans[i]/10;
            ans[i]%=10;
        }
        StringBuilder sb = new StringBuilder();
        int cur = 0 ;
        while (cur<m+n&&ans[cur]==0) cur++;
        while (cur<m+n){
            sb.append(ans[cur++]);
        }
        return sb.length()==0?"0":sb.toString();
    }

}
```

注意：这里为啥设计为`ans[i+j+1]` 而不是i+j

因为`ans[]`数组是从左到右记录相对位的和（还没有进位），而最后的进位是从右向左累加进位，这样的话，如果最高位，也就是最左侧那一位的累加结果需要进位的话，`ans[]`数组就没有空间存放了。

而正好如果是从左到右的记录的话，而且也不用i+j+1，那么m+n的ans大小，(m-1)+(n-1)是最后一个需要记录的位置，`ans[]`数组的最后一位空置，不可能被占用。因此把**num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上**的这个结果往后顺移一位（`放到第i+j+1位`），最后从右向左累加时就多了一个空间，也就是ans[0]位置最后用于进位。
