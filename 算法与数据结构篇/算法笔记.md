---
author: MCXW
shortTitle: 算法笔记
---
Copy自：[算法笔记](算法笔记.md) 重新修订

该文档作为算法题题录，做过的比较好的都收录于此。

# 758、字符串中的加粗单词
给定一个关键词集合 `words` 和一个字符串 `s`。
要求：在所有 `s` 中出现的关键词前后位置上添加加粗闭合标签 `<b>` 和 `</b>`。如果两个子串有重叠部分，则将它们一起用一对闭合标签包围起来。同理，如果两个子字符串连续被加粗，那么你也需要把它们合起来用一对加粗标签包围。最后返回添加加粗标签后的字符串 `s`。

思路：
先使用一个数组isBold保存S中的每个字符是否应该加粗，判断的方式是，遍历words中的每个字符串，找出S中有哪些位置和它匹配。
是否增加标签<b>的方法是当前字符需要加粗，但是其前面的字符不用加粗，或者当前字符是第一个字符。 是否增加标签</b>的方法是当前字符需要加粗，但是其后面的字符不用加粗，或者当前字符是最后一个字符。

```java
public class Huawei {
    public static void main(String[] args) {
        String[] words = {"asas","dsw","12"};
        String s = "asasdsdasd12121";
        new Huawei().BoldWords(words,s);
    }
    static void BoldWords(String[] words,String s){
        int len = s.length();
        boolean[] isBold = new boolean[len+1];
        for (String word : words) {
            for (int i = 0; i < len-word.length(); i++) {
                String subs = s.substring(i, i+word.length());
                if (subs.equals(word)){
                    for (int j = i; j < i + word.length(); j++) {
                        isBold[j] = true;
                    }
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len; i++) {
            if (isBold[i]&&(i==0||!isBold[i-1])) sb.append("<br>");
            //如果当前为加醋，前面不是加粗，或者前面是i==0；
            sb.append(s.charAt(i));
            if (isBold[i]&&(i==len-1||!isBold[i+1])) sb.append("</br>");
        }
        System.out.println(sb.toString());
    }
}

```
运行结果：
```latex
<br>asas</br>dsdasd<br>1212</br>1
```


# 一、数据结构问题
## 字符串相关问题
> 每隔8个输出一下

```java
String ss = sb.toString();
while (ss.length()>0) {
    System.out.println(ss.substring(0,8));
    ss = ss.substring(8);
}
```

### HJ4 字符串分隔
描述
•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。
输入描述：
连续输入字符串(每个字符串长度小于等于100)
输出描述：
依次输出所有分割后的长度为8的新字符串
示例1
输入：
```
abc
```

输出：
```
abc00000
```

```java
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            String s = in.next();
            StringBuilder sb = new StringBuilder();
            sb.append(s);
            int addZeroNum = 8-sb.length()%8;
            while (addZeroNum>0&&addZeroNum<8) {
                sb.append('0');
                addZeroNum--;
            }
            String ss = sb.toString();
            while (ss.length()>0) {
                System.out.println(ss.substring(0,8));
                ss = ss.substring(8);
            }
        }
    }
```

## 数组问题

### 41. 缺失的第一个正整数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        //最小的正整数，遍历
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            while (nums[i]>0 && nums[i]<=len && nums[i]!=nums[nums[i]-1]){
                //  1 2 3 0 4
                //  - - - ! -
                // 4应该在下标3的位置
                int j = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i]!=i+1){
                return i+1;//如果当前位置不存在对应的合理的值，就返回
            }
        }
        return len+1;
    }
}
```

### HJ3.**明明的随机数**

描述

明明生成了�_N_个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。

数据范围： 1≤�≤1000 1≤_n_≤1000 ，输入的数字大小满足 1≤���≤500 1≤_v**a**l_≤500

输入描述：

第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的"示例"。

输出描述：

输出多行，表示输入数据处理后的结果

示例1

输入：

```
3
2
2
1
```

输出：

```
1
2
```

说明：

```
输入解释：
第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：
2
2
1
所以样例的输出为：
1
2
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNext()) { // 注意 while 处理多个 case
            int n = in.nextInt();
            int[] nums = new int[501];
            for(int i = 0;i<n;i++){
                int next = in.nextInt();
                // System.out.println(next);
                nums[next] =1 ;
            }
            for(int i = 0;i<501;i++){
                if (nums[i]==1) {
                    System.out.println(i);
                }
            }
            
        }
    }
}
```

## 链表问题

> LRU缓存：`**int oldestKey = cache.keySet().iterator().next();**`： 这一行代码定义了一个名为`oldestKey`的整型变量，并将其初始化为`cache`键集的第一个键。这里的变量名`oldestKey`暗示着这个键是“最旧”的，可能是按插入顺序来看的第一个元素，特别是在使用`LinkedHashMap`这样可以保持插入顺序的`Map`实现时。不过，如果使用的是`HashMap`，则不能保证这个键是最旧的，因为`HashMap`不保证任何顺序。


### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：

1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；

3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。

那么，什么数据结构同时符合上述条件呢？**哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。**所以结合一下，形成一种新的数据结构：`哈希链表 LinkedHashMap`。

```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer,Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)){
            return -1;
        }
        int val = cache.get(key);
        cache.remove(key);
        cache.put(key,val);//再次插入就实现了最新的使用的标记
        return cache.get(key);
    }
    
    public void put(int key, int value) {
        if(cache.containsKey(key)){
            cache.put(key,value);
            int val = cache.get(key);
            cache.remove(key);
            cache.put(key,val);//再次插入
            return;
        }
        if(cache.size()>=cap){
            //使用iterator()方法获取迭代器，可以遍历集合中的元素。next()方法用于返回下一个元素，即获取最早的键。
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        cache.put(key,value);
        return;
    }
}
```

> 用 LinkedHashMap 可以很容易实现 LRU 缓存，不过面试的时候估计这样不好，还是尽量自己实现数据结构吧🤣
>  
> 主要想法是使用 JDK 提供的 HashMap，然后自己写一个 Node 节点类，用来保存 value ，并且通过这个 Node 里面的 prev、next 指针将各个值串联起来，这样就维护了顺序。
>  
> 很重要的一个细节是，Node 里面还要加上 key （尽管 HashMap 本来就存了一份）。
>  
> 原因是当缓存达到容量上限时，就要先移除尾部的节点，这个时候如果只移除链表的 tail 节点，忽略了 HasmMap 也要 remove ，后面再访问这个被移除的 key 就会造成空指针异常！！！
>  
> 所以我们在 Node 节点里面加上 key ，删掉 tail 之前先 remove 掉 HasmMap 的这个 key，就很方便了。
>  
> 不适用LinkedList:
>  

```java
import java.util.*;
public class Solution {
    private int capacity;
    private Map<Integer,Node> map;
    private Node head;
    private Node tail;
    private int used;
    class Node{
        int key;
        int value;
        Node prev;
        Node next;
        Node(int key,int value,Node prev,Node next){
            this.key = key;
            this.value = value;
            this.prev = prev;
            this.next = next;
        }
    }
 public Solution(int capacity) {
    //构造函数
    this.capacity = capacity;
    this.map =  new HashMap<>();
    this.used= 0;
 }
 public int get(int key) {
 // write code here
    if(!map.containsKey(key)){
        return -1;
    }
    makeRecently(key);
    return map.get(key).value;
 }
 public void set(int key, int value) {
 // write code here
    if(map.containsKey(key)){
        map.get(key).value = value;
        makeRecently(key);
        return;
    }
    if(used==capacity){
        map.remove(tail.key);
        tail = tail.prev;
        tail.next = null;
        used--;
    }
    if(head==null){
        head = new Node(key,value,null,null);
        tail = head;
    }
    else{
        //head不为空
        Node t = new Node(key,value,null,head);
        head.prev = t;
        head = t;
    }
    map.put(key,head);
    used++;
 }
 private void makeRecently(int key){
    Node t = map.get(key);
    if(t!=head){
        if(t==tail){
            tail = tail.prev;
            tail.next = null;
        }else{
            t.prev.next = t.next;//将t跳过了
            t.next.prev = t.prev;//将next的向前指的顺序纠正
        }
        t.prev = null;
        t.next = head;
        head.prev = t;
        head =t;
    }
 }
}
```

### 实现一个cache，包括LRU算法和在x秒后过期

```java
import java.util.LinkedHashMap;  
import java.util.Map;  
import java.util.concurrent.ScheduledExecutorService;  
import java.util.concurrent.Executors;  
import java.util.concurrent.TimeUnit;  
  
public class LRUCacheWithExpiration<K, V> {  
    // 缓存的最大容量  
    private final int capacity;  
    // 缓存项的过期时间（秒）  
    private final long expirationTimeInSeconds;  
    // 使用LinkedHashMap实现LRU缓存，accessOrder设置为true以启用LRU顺序  
    private final LinkedHashMap<K, CacheEntry<V>> cacheMap;  
    // 定时任务执行器，用于清理过期的缓存项  
    private final ScheduledExecutorService expirationExecutor;  
  
    // 内部类CacheEntry，用于存储缓存值和过期时间  
    private static class CacheEntry<V> {  
        V value;  
        long expirationTime;  
  
        CacheEntry(V value, long expirationTime) {  
            this.value = value;  
            this.expirationTime = expirationTime;  
        }  
    }  
  
    // 构造函数  
    public LRUCacheWithExpiration(int capacity, long expirationTimeInSeconds) {  
        this.capacity = capacity;  
        this.expirationTimeInSeconds = expirationTimeInSeconds;  
        // 初始化LRU缓存，设置accessOrder为true，以便按访问顺序进行LRU操作  
        this.cacheMap = new LinkedHashMap<>(capacity, 0.75f, true) {  
            // 重写removeEldestEntry方法，当Map大小超过指定容量时，删除最老的元素  
            @Override  
            protected boolean removeEldestEntry(Map.Entry<K, CacheEntry<V>> eldest) {  
                return size() > LRUCacheWithExpiration.this.capacity;  
            }  
        };  
        // 初始化定时任务执行器  
        this.expirationExecutor = Executors.newSingleThreadScheduledExecutor();  
        // 安排定时任务，每隔expirationTimeInSeconds秒执行一次清理过期缓存项的操作  
        this.expirationExecutor.scheduleAtFixedRate(this::evictExpiredEntries, expirationTimeInSeconds, expirationTimeInSeconds, TimeUnit.SECONDS);  
    }  
  
    // 获取缓存项  
    public synchronized V get(K key) {  
        CacheEntry<V> entry = cacheMap.get(key);  
        if (entry == null || isExpired(entry.expirationTime)) {  
            // 缓存项不存在或已过期，返回null  
            return null;  
        }  
        // 更新缓存项的访问顺序（移到尾部，表示最近访问）  
        cacheMap.remove(key);  
        cacheMap.put(key, entry);  
        // 返回缓存值  
        return entry.value;  
    }  
  
    // 添加或更新缓存项  
    public synchronized void put(K key, V value) {  
        // 创建新的缓存项，设置过期时间  
        CacheEntry<V> newEntry = new CacheEntry<>(value, System.currentTimeMillis() + (expirationTimeInSeconds * 1000));  
        // 将新的缓存项添加到LRU缓存中，如果缓存已满，则会自动删除最老的元素  
        cacheMap.put(key, newEntry);  
    }  
  
    // 清理过期缓存项的方法  
    private void evictExpiredEntries() {  
        long currentTime = System.currentTimeMillis();  
        // 遍历缓存，移除已过期的缓存项  
        cacheMap.entrySet().removeIf(entry -> isExpired(entry.getValue().expirationTime));  
    }  
  
    // 判断缓存项是否过期  
    private boolean isExpired(long expirationTime) {  
        return expirationTime <= System.currentTimeMillis();  
    }  
  
    // 关闭缓存，停止定时任务执行器  
    public void close() {  
        expirationExecutor.shutdown();  
        try {  
            if (!expirationExecutor.awaitTermination(60, TimeUnit.SECONDS)) {  
                expirationExecutor.shutdownNow();  
            }  
        } catch (InterruptedException e) {  
            expirationExecutor.shutdownNow();  
            Thread.currentThread().interrupt();  
        }  
    }  
}
```

### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/rotate1.jpg#id=bmYtW&originHeight=302&originWidth=712&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return head;
        int n = 1;
        ListNode tail = head;
        while(tail.next!=null){
            tail = tail.next;
            n++;// length
        }
        k = k%n;//防止重复移动
        if(k<1) return head;
        ListNode fast = head;
        ListNode slow = head;
        while(k-->0){
            fast = fast.next;
        }
        
        while(fast.next!=null){
            fast= fast.next;
            slow = slow.next;
        }
        ListNode newHead = slow.next;
        slow.next = null;
        tail.next = head;
        return newHead;
    }
}
```

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 [**深拷贝**](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/e1.png#id=z1UVT&originHeight=386&originWidth=1900&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。

算法流程：

- 若头节点 head 为空节点，直接返回 null 。
- 初始化： 哈希表 dic ， 节点 cur 指向头节点。
- 复制链表：
建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） 。
cur 遍历至原链表下一节点。
- 构建新链表的引用指向：
构建新节点的 next 和 random 引用指向。
cur 遍历至原链表下一节点。
- 返回值： 新链表的头节点 dic[cur] 。

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node cur = head;
        Map<Node,Node> map = new HashMap<>();
        while(cur!=null){
            //map storage the new Node
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        while(cur!=null){
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```

### [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1715474951264-007e6f63-e6f1-4523-be84-8beadab56301.png#averageHue=%23f3f3f3&clientId=u3a18be3a-46a6-4&id=dKGpc&originHeight=342&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32741&status=done&style=none&taskId=ue2088a6f-5d0d-4adf-a1e6-650ab01b41b&title=)

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
//        使用两个辅助栈
        ArrayDeque<Integer> stk1 = new ArrayDeque<>();
        ArrayDeque<Integer> stk2 = new ArrayDeque<>();
        while (l1!=null){
            stk1.push(l1.val);
            l1 = l1.next;
        }
        while (l2!=null){
            stk2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;//储存进位
        ListNode res = null;//储存结果
        while (!stk1.isEmpty()||!stk2.isEmpty()||carry!=0) {
            int digit1 = stk1.isEmpty()?0:stk1.pop();
            int digit2 = stk2.isEmpty()?0:stk2.pop();
            int sum = digit1+digit2+carry;
            carry = sum/10;
            sum = sum%10;
            ListNode tmp = new ListNode(sum);
            tmp.next = res;
            res = tmp;
        }
        return res;
    }
}
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。
`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/reverse_ex1.jpg#id=WF3kZ&originHeight=222&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head==null||head.next ==null) return head;
        ListNode tail = head;
        for(int i = 0;i<k;i++){
            if(tail==null) return head;
            tail = tail.next;
        }
        ListNode newHead = reverse(head,tail);
        head.next = reverseKGroup(tail,k);//这个时候的head就是反转好的队尾了
        return newHead;
    }
    private ListNode reverse(ListNode head,ListNode tail){
        ListNode prev = null;
        ListNode next = null;
        while(head!=tail){
            next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;//返回头部，就是反转的头部了
    }
}
```

![](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/image-20240320134441671.png#id=o3Znu&originHeight=474&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

`L0 → L1 → … → Ln-1 → Ln`
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
**示例 1:**

![](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png#id=G9bQk&originHeight=222&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        ////将主链表划分为 前一段子链表和后一段子链表，
        // 对于后一段子链表进行翻转，同时对于这两条链表进行重构;
        ArrayDeque<ListNode> deque = new ArrayDeque<ListNode>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        while (head!=null) {
            ListNode next = head.next;
            head.next = null;
            deque.add(head);
            head = next;
        }
        ListNode curr = dummy;
        while (!deque.isEmpty()) {
            ListNode start = deque.pollFirst();
            curr.next = start;
            //循环遍历deque双端，直至队列为空
            if (!deque.isEmpty()){
                ListNode last = deque.pollLast();
                start.next = last;//curr-》start-》last
                curr = last;//curr专程last
            }else {
                start.next = null;
            }
        }
        return;
    }
}
```

### 两个链表合并

```java
public ListNode mergeTwoLists(ListNode a, ListNode b) {
    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode(0);
    ListNode tail = head, la = a, lb = b;
    while (la != null && lb != null) {
        if (la.val < lb.val) {
            tail.next = la;
            la = la.next;
        } else {
            tail.next = lb;
            lb = lb.next;
        }
        tail = tail.next;
    }
    tail.next = (la != null ? la : lb);
    return head.next;
}
```

> 多个链表合并可以遍历，
>  

```java
public ListNode mergeKLists(ListNode[] lists) {
    ListNode ans = null;
    for (ListNode list : lists) {
        ans = mergeTwoLists(ans,list);
    }
    return ans;
}
```

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例 1：**
![](https://raw.githubusercontent.com/52chen/imagebed2023/main/rev2ex2.jpg#id=bT9HK&originHeight=222&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1,head);
        ListNode prev = dummy;
        ListNode curr = head;

        //直接找到对应的位置，然后再切断再反转再接上
        for (int i = 1; i < left; i++) {
            prev = curr;
            curr = curr.next;
        }
        for (int i = 0; i < right - left; i++) {
            ListNode tmp = curr.next;
            curr.next = tmp.next;//curr指向tmp后面
            tmp.next = prev.next;//把tmp接龙，接到要逆向的prev的后面
            prev.next = tmp;//这三部=部分不能调换顺序，因为curr要用tmp
            //tmp要用prev，最后才可以切换prev的next
        }
        return dummy.next;
    }

}
```

### 两两交换链表
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
**示例 1：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1714876109933-7fa8e0af-facf-433a-b974-57769ebd91ba.png#averageHue=%23f5f5f5&clientId=uae8ec878-cd5c-4&from=paste&id=u95f8df60&originHeight=222&originWidth=422&originalType=url&ratio=2&rotation=0&showTitle=false&size=36253&status=done&style=none&taskId=ufbe88286-0066-4003-a348-0e7f34819b2&title=)
```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```
**示例 2：**
![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1714876219992-f689ea3c-7742-4ce9-958a-1cb17d403f3b.jpeg)
```java
public ListNode swapPairs(ListNode head) {
    ListNode dummy = new ListNode(-1,head);
    ListNode prev = dummy;
    ListNode cur = head;
    while (cur!=null&&cur.next!=null){
        ListNode tmp = cur.next.next;
        prev.next = cur.next;
        cur.next.next = cur;
        cur.next = tmp;
        cur = cur.next;
        prev = prev.next.next;
    }
    return dummy.next;
}
```
## 栈的使用



### 逆波兰算法

### [剑指 Offer II 036. 后缀表达式](https://leetcode.cn/problems/8Zf90G/)

根据[ 逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求该后缀表达式的计算结果。

有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**说明：**

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

**示例 1：**

```shell
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<>();
        for(int i = 0;i<tokens.length;i++){
            String token = tokens[i];
            if(isNumber(token)) {
                stack.push(Integer.parseInt(token));//压入数字到栈厘米
            }else{
                int num2 = stack.pop();
                int num1 = stack.pop();//弹出两个就是数组
                switch(token){
                    case "+":{
                        stack.push(num1+num2);
                        break;
                    }
                    case "-":{
                        stack.push(num1-num2);
                        break;
                    }
                    case "*":{
                        stack.push(num1*num2);
                        break;
                    }
                    case "/":{
                        stack.push(num1/num2);
                        break;
                    }
                }
            }
        }
        return stack.pop();
    }
    public boolean isNumber(String s){
        return !("+".equals(s)||"-".equals(s)||"*".equals(s)||"/".equals(s));
        // 既不是加减乘除就是对的数字了
    }
}
```

> 你想哈，这个数字可能是几百上千的，所以我们不能说用判断0到9就行了


### [32. 最长有效括号-栈存储-以及动态规划](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

遍历字符串：接着，遍历字符串的每个字符：

如果遇到左括号 '('，将它的索引压入栈中。
如果遇到右括号 ')'：
首先弹出栈顶元素，表示匹配了一个左括号。
如果栈变空了，将当前右括号的索引压入栈中。
如果栈不为空，计算当前有效子串的长度，即 当前索引 - 栈顶元素，并更新最大长度。

```java
import java.util.ArrayDeque;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int longestValidParentheses(String s) {
        if (s.length()<1) return 0;
        int ans  = 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        stack.push(-1);
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)=='('){
                stack.push(i);//左边的就存入
            }
            else {
                stack.pop();
                //peek存的是没有配对的最小的元素
                if (!stack.isEmpty()) ans = Math.max(ans,i-stack.peek());
                else stack.push(i);
            }
        }
        return ans;
    }
}
```

动态规划
```java
class Solution {  
    public int longestValidParentheses(String s) {  
        int ans  = 0;  
        int[] dp = new int[s.length()];  
        for (int i = 1; i < s.length(); i++) {  
            if (s.charAt(i)==')'){  
                if (s.charAt(i-1)=='('){  
                    if (i<2) dp[i] = 2;  
                    else dp[i] = dp[i-2]+2;  
                }else{  
                    // ***))  
                    if (dp[i-1]>0){  
                        int left = i-dp[i-1]-1;  
                        // **((***))  
                        if (left>=0&&s.charAt(left)=='('){  
                            dp[i] = dp[i-1]+2;//当前的参数至少是+2；  
                            if (left>1){  
                                //就是left从第3位开始，前面至少还有一对的话  
                                dp[i]+=dp[left-1];  
                            }  
  
                        }  
                    }  
                }  
            }  
            ans = Math.max(ans,dp[i]);  
        }  
        return ans;  
    }  
}
```
## 哈希表问题
### [290. 单词规律](https://leetcode.cn/problems/word-pattern/)
给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。
这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。
**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", s = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
```

**提示:**

- `1 <= pattern.length <= 300`
- `pattern` 只包含小写英文字母
- `1 <= s.length <= 3000`
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随对空格
- `s` 中每个单词都被 **单个空格** 分隔

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        //一个单词就是一个组合
        String[] strings = s.split(" ");
        HashMap<Character, String> map = new HashMap<>();
        if (pattern.length()!=strings.length){
            return false;
        }
        for (int i = 0; i < pattern.length(); i++) {
            char key = pattern.charAt(i);
            if (map.containsKey(key)){
                //如果遇到过这个key
                if (!map.get(key).equals(strings[i])){
                    return false;
                }
            }else {
                //没有遇到过的话，就要看这个s里面是不是有匹配的key了
                if (map.containsValue(strings[i])){
                    return false;//如果有匹配的了，那就罪过了
                }
                map.put(key,strings[i]);
            }
        }
        return true;
    }
}
```

### [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)
请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1：**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1715474540413-40328d8a-1720-418f-bae9-b1c1333cbee5.png#averageHue=%23cecece&clientId=u3a18be3a-46a6-4&id=cB8k0&originHeight=250&originWidth=250&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14520&status=done&style=none&taskId=uae561bab-a1f7-49a7-943a-0597aec8b3e&title=)
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        //给数独编号
        Map<Integer, Set<Integer>> row = new HashMap<>(),col = new HashMap<>(),area = new HashMap<>();
        //加入三个HashMap
        for (int i = 0; i < 9; i++) {
            row.put(i,new HashSet<>());
            col.put(i,new HashSet<>());
            area.put(i,new HashSet<>());
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                //读取9*9的各个
                char c = board[i][j];
                if (c=='.') continue;
                int u = c-'0';
                int areaIdx=i/3 * 3+j/3;
                if (row.get(i).contains(u)||
                col.get(j).contains(u)||
                area.get(areaIdx).contains(u))
                    return false;
                row.get(i).add(u);//给每个元素加上
                col.get(j).add(u);
                area.get(areaIdx).add(u);
            }
        }
        return true;
    }
}
```

### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。


```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums==null||nums.length==0) return ans;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp =target-nums[i];
            if(map.containsKey(tmp)) {
                return new int[]{i,map.get(tmp)};
            }
            map.put(nums[i],i);
        }
        return ans;
    }
}
```

### 四数之和II

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2

实际就是化简为两个数之和

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int tmp = i + j;
                map.put(tmp,map.getOrDefault(tmp,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int tmp = i + j;
                // 直接寻找相对的数是否存在，存在就直接可以算作是一组数，几个value就是几组
                if (map.containsKey(0-tmp))
                    ans+=map.get(0-tmp);
            }
        }
        return ans;
    }
}
```

### 哈希法求解不含重复字串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int j = 0;
        // p w w e k
        // j   i
        //找到w上一次的位置设置为最长子串的起始点。
        if (s.length()==1) return 1;
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            ans = Math.max(ans,i-j+1);
        }
        return ans;
    }
}
```

给定一个字符串数组 `strs` ，将 **变位词** 组合在一起。 可以按任意顺序返回结果列表。

**注意：**若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> map = new HashMap<>();
//        map存放排好序了的string的数组
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String s = new String(chars);//将排好序的重新转化成string
            List<String> path = map.getOrDefault(s, new ArrayList<>());//取出来s对应的list，
            path.add(str);
            map.put(s,path);//重新再放回去
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

### [249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)

给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：`"abc" -> "bcd"`。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：

```
"abc" -> "bcd" -> ... -> "xyz"
```

给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。

**示例：**

```
输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]
输出：
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]
解释：可以认为字母表首尾相接，所以 'z' 的后续为 'a'，所以 ["az","ba"] 也满足 “移位” 操作规律。
az 0 25
bz
```

```java
class Solution {
    public List<List<String>> groupStrings(String[] strings) {
         if (strings==null || strings.length==0) return new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();//存储
        for (String string : strings) {
            StringBuilder sb = new StringBuilder();
            for (char c : string.toCharArray()) {
                sb.append("#");
                int shift = (c-string.charAt(0)+26)%26;
                sb.append(shift);
            }
            String key = sb.toString();
            if (!map.containsKey(key)) map.put(key,new ArrayList<String>());
            map.get(key).add(string);
        }
        return new ArrayList<>(map.values());
    }
}
```

```java
HashMap<String,List<String>> map = new HashMap<>();
for(String s:strings){
    StringBuilder sb = new StringBuilder();
    for(char c:s.toCharArray()){
        sb.append("#");
        int shift = (c-s.charAt(0)+26)%26;
    }
}
```

> 记录移动的位置的时候，存储有一个循环的 时候我们可以加一个26再对26取一个模
>  
> `int shift = (c-string.charAt(0)+26)%26;` 就可以实现循环了，比如az就是ba的相似的

## 单调栈

```
/**
 *  单调栈分为单调递增栈和单调递减栈，通过使用单调栈我们可以访问到最近一个比它大（小）的元素。
 *     单调递增栈：单调递增栈就是从栈底到栈顶数据是依次递增，通常是寻找某方向第一个比它小的元素。
 *     单调递减栈：单调递减栈就是从栈底到栈顶数据是依次递减，通常是寻找某方向第一个比它大的元素。
 */
```

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，**如果需要使用对应的元素，直接T[i]就可以获取。**

1. 单调栈里元素是递增呢？ 还是递减呢？

**顺序的描述为 从栈头到栈底的顺序**，从左到右或者从前到后，

这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。

即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。

文字描述理解起来有点费劲，接下来我画了一系列的图，来讲解单调栈的工作过程，大家再去思考，本题为什么是递增栈。

使用单调栈主要有三个判断条件。

- 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
- 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

### LCR 083 天气：
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
```
示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]
```
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        // 单调栈，遍历递增循序（再强调一下是指从栈头到栈底的顺序），
        // 因为只有递增的时候，栈里要加入一个元素i的时候，
        // 才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        //也可以不用额外考虑0；//2024/5/21
        deque.push(0);//就是在队列的左边，头部，加入了初始的0
        for (int i = 1; i < temperatures.length; i++) {
          //这里是及时去掉无用元素。
            while (!deque.isEmpty() && temperatures[i]>temperatures[deque.peek()]){
                ans[deque.peek()] = i - deque.peek(); // 最右边的
                deque.pop();
            }
            deque.push(i);
        }
        return ans;
    }
}
```
![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303231393132343730303536372e6a7067.jpeg#height=347&id=NJpVS&originHeight=676&originWidth=1098&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=563)
就是当前遍历的元素如果比stack peek的大，说明stack peek第一个比他大的找到了，就不用管了。

### [剑指 Offer II 039. 直方图最大矩形面积](https://leetcode.cn/problems/0ynMMM/)
给定非负整数数组 `heights` ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 `1` 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
**示例 1:**

![](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg#id=CsHDI&originHeight=242&originWidth=522&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] temp = new int[heights.length+2];//存储单调栈
        System.arraycopy(heights,0,temp,1,heights.length);
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        int area = 0;
        for(int i= 0;i<temp.length;i++){
            while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
                //如果当前位置的高度比stack的小，那么就会漏水
                int h = temp[stack.pop()];
                // 比如： 2 1 
                // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
                // 所以stack里面一直有元素
                area = Math.max(area,h*(i-stack.peek()-1));
                // 当stack为 1 5 6 时
                // 2 小于 6 ，所以area更新为 6
                // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
            }
            stack.push(i);
        }
        return area;
    }
}
```

### [剑指 Offer II 040. 矩阵中最大的矩形](https://leetcode.cn/problems/PLYXKQ/)

难度困难76收藏分享切换为英文接收动态反馈

给定一个由 `0` 和 `1` 组成的矩阵 `matrix` ，找出只包含 `1` 的最大矩形，并返回其面积。

**注意：**此题 `matrix` 输入格式为一维 `01` 字符串数组。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg#id=GACmW&originHeight=322&originWidth=402&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：matrix = ["10100","10111","11111","10010"]
输出：6
解释：最大矩形如上图所示。
```

看下边的橙色的部分，这完全就是上一道题呀！
![](https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png#id=s3u8A&originHeight=438&originWidth=437&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

算法有了，就是求出每一层的 heights[] 然后传给上一题的函数就可以了。

```java
class Solution {
    public int maximalRectangle(String[] matrix) {
        if(matrix.length==0) return 0;
        int n = matrix[0].length();
        int[] heights = new int[n];
        int maxArea = 0;
        for(int i = 0;i<matrix.length;i++){
            for(int j = 0;j<n;j++){
                if(matrix[i].charAt(j) == '1'){
                    heights[j] +=1;
                }else{
                    heights[j] = 0;
                }
            }
            maxArea = Math.max(maxArea,largestRectangleArea(heights));
        }
        return maxArea;
    }

    public int largestRectangleArea(int[] heights) {
    int[] temp = new int[heights.length+2];//存储单调栈
    System.arraycopy(heights,0,temp,1,heights.length);
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    int area = 0;
    for(int i= 0;i<temp.length;i++){
        while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
            //如果当前位置的高度比stack的小，那么就会漏水
            int h = temp[stack.pop()];
            // 比如： 2 1 
            // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
            // 所以stack里面一直有元素
            area = Math.max(area,h*(i-stack.peek()-1));
            // 当stack为 1 5 6 时
            // 2 小于 6 ，所以area更新为 6
            // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
        }
        stack.push(i);
    }
    return area;
    }
}
```

## 单调队列

### 239.滑动窗口局部最大值

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 
输出: [3,3,5,5,6,7] 
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

这一题是滑动窗口，所以单调栈的构造需要确定是不是在k的范围内，

![239.滑动窗口最大值-2](https://code-thinking.cdn.bcebos.com/gifs/239.滑动窗口最大值-2.gif)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();
        //准备单调队列
        for (int right = 0; right < nums.length; right++) {
//            队首元素就是该窗口内的最大值。
            while (!queue.isEmpty() && nums[right]>=nums[queue.peekLast()]) {
                queue.removeLast();
//            非空的时候，如果信赖的比queue顶部的元素大的话，就移走这个
            }
            queue.addLast(right);
//            如果首部坐标小于left，那么就删除这个
            int left = right-k+1;//此时这个left实际也就是依次递增的
            if (queue.peekFirst()<left){
                queue.removeFirst();
            }
            if (left>=0) {
                ans[left] = nums[queue.peekFirst()];
//                这个first对应就是前k个区间内的大的数值了
            }
        }
    }
}
```



> ```java
> // 2024/6/29 实际就是一个单调队列，先更新入队列，然后出队列不符合要求的。
> class Solution {
>     public int[] maxSlidingWindow(int[] nums, int k) {
>         LinkedList<Integer> list = new LinkedList<>();
>         int n = nums.length;
>         int[] ans = new int[n-k+1];
>         for (int i = 0; i < n; i++) {
>             //入队列
>             while (!list.isEmpty()&&nums[list.getLast()]<=nums[i]){
>                 list.removeLast();//单调递减的队列，新来的元素必须比当前元素小，如果是大于等于队尾的话
>                 //直接移走队尾。
>             }
>             list.addLast(i);
>             //出队列
>             if (i-list.getFirst()>=k) list.removeFirst();
>             //记录
>             if (i>=k-1){
>                 ans[i-k+1] = nums[list.getFirst()];
>             }
>         }
>         return ans;
>     }
> }
> ```

## 优先级队列

### PriorityQueue的作用

PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。

在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。

Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。

Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。

Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。

由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。

这里牵涉到了大小关系，**元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器**（_Comparator_，或者元素自身实现 Comparable 接口）来决定。

在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。

### [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/)

设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。

请实现 `KthLargest` 类：

- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

示例：

```shell
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```

其实就是优先级队列，做一个小丁队

```java
class KthLargest {
    PriorityQueue<Integer> queue;
    int k;
    public KthLargest(int k, int[] nums) {
        queue = new PriorityQueue<>();
        // 默认是从小到达的顺序，小顶堆
        for(int num: nums){
            queue.add(num);
        }
        this.k = k;
    }
    
    public int add(int val) {
        queue.offer(val);
        while(queue.size()>k){
            queue.poll();
        }
        return queue.peek();
    }
}
```

### [剑指 Offer II 060. 出现频率最高的 k 个数字](https://leetcode.cn/problems/g5c51o/)

> 关键： 优先级存储了频率和数字，直接定一个PriorityQueue<int[ ] >


给定一个整数数组 `nums` 和一个整数 `k` ，请返回其中出现频率前 `k` 高的元素。可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        PriorityQueue<int[]> queue= new PriorityQueue<>(new Comparator<>(){
            public int compare(int[] a,int[] b){
                return a[1]-b[1];
            }
        });
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            // 遍历每一个map的元素
            int num = entry.getKey(), count = entry.getValue();
            
            if(queue.size()==k){
                if(queue.peek()[1]<count){
                    queue.poll();
                    queue.offer(new int[]{num,count});
                }
            }else{
                queue.offer(new int[]{num,count});
            }
            /*也可以全部都加进去，之后再判断队列大小，大了的部分就poll出去。
            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                Integer num = entry.getKey();
                Integer value = entry.getValue();
                queue.offer(new int[]{num,value});
            }
            while (queue.size()>k){
                queue.poll();
            }
            */
            
        }
        int[] res = new int[k];
        for(int i = 0;i<k;i++){
            res[i] = queue.poll()[0];
        }
        return res;
    }
}
```

### [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`, `(u2,v2)` ...  `(uk,vk)` 。

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->nums1[a[0]] + nums2[a[1]] - nums1[b[0]] - nums2[b[1]]);
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]));
        for(int i = 0;i<Math.min(k,nums1.length);i++){
            heap.offer(new int[]{i,0});
            //nums1的索引都放到heap里面，
            
        }
        List<List<Integer>> ans = new ArrayList<>();
        // 最多弹出 k 次
        while(k-- >0 && !heap.isEmpty()){
            //其实就是吧heap整理一下
            //卧槽，就是说弹出k次heap堆的堆顶，肯定就是最小值
            int[] pos = heap.poll();
            ans.add(Arrays.asList(nums1[pos[0]],nums2[pos[1]]));
            // 将 index2 加 1 之后继续入队
            if(++pos[1]<nums2.length){
                heap.offer(pos);
            }
        }
        return ans;
    }
}
```

## TreeSet

Java中 TreeMap和TreeSet算是java集合类里面比较有难度的数据结构。和普通的HashMap不一样，普通的HashMap元素存取的时间复杂度一般是O(1)的范围，而TreeMap内部对元素的操作复杂度为O(logn)。

虽然在元素的存取方面TreeMap并不占优，但是它内部的元素都是排序的，当需要查找某些元素以及顺序输出元素的时候它能够带来比较理想的结果。可以说，**TreeMap是一个内部元素排序版的HashMap。**同样，TreeSet是一个封装了一个HashSet的成员变量来实现的，底层运用了红黑树的数据结构。

### TreeSet Vs. HashSet

TreeSet和HashSet都实现了Set接口。然而，它们之间存在着一些区别。

- 与HashSet不同，TreeSet中的元素是以某种顺序存储的。这是因为TreeSet还实现了SortedSet接口。
- TreeSet提供了一些易于导航的方法。 例如first()，last()，headSet()，tailSet()等。这是因为TreeSet还实现了NavigableSet接口。
- 对于添加、删除、包含和大小等基本操作，HashSet比TreeSet更快。

### 使用

为了创建树集，我们必须首先导入java.util.TreeSet包。

导入包之后，下面是如何在Java中创建TreeSet。

```
TreeSet<Integer> numbers = new TreeSet<>();
```

在这里，我们创建了一个没有任何参数的TreeSet。在本示例中，TreeSet中的元素自然排序(升序)。

但是，我们可以使用Comparator接口自定义元素的排序。

### [剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/)

给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。

如果存在则返回 `true`，不存在返回 `false`。

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

```java
class Solution {

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        // 滑动窗口，窗口大小为k，窗口内两个数字的大小相差为t
        TreeSet<Long> set =  new TreeSet<>();
        for(int i = 0;i<nums.length;i++){
            Long item = nums[i]*1L;
            Long floor = set.floor(item);
            Long ceil = set.ceiling(item);
            // 比较ceil和floor一个是刚大于一点点item，一个是稍小一点点item的元素
            if(floor!=null && (item-floor<=t)) return true;
            if(ceil!=null && ceil-item<=t)  return true;
            set.add(item);
            //移除大于窗口的元素
            if(i>=k) set.remove(nums[i-k]*1L);
        }
        return false;
    }
}
```

### Method

### first()和last()方法

- first() - 返回集合的第一个元素
- last() - 返回集合的最后一个元素

例如，

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 first() 方法
        int first = numbers.first();
        System.out.println("第一个数字: " + first);

        // 使用 last() 方法
        int last = numbers.last();
        System.out.println("最后一个数字: " + last);
    }
}
```

**输出结果**

```
TreeSet: [2, 5, 6]
第一个数字: 2
最后一个数字: 6
```

### ceiling()，floor()，higher()和lower()方法

- **Higher(element)** - 返回大于指定元素(element)的最小元素。
- **lower(element)** - 返回小于指定元素(element)的最大元素。
- **ceiling(element)** - 返回大于指定元素(element)的那些元素中的最小元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。
- **floor(element)** - 返回小于指定元素(element)的元素中最大的元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(4);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 higher()
        System.out.println("使用 higher: " + numbers.higher(4));

        // 使用 lower()
        System.out.println("使用 lower: " + numbers.lower(4));

        // 使用 ceiling()
        System.out.println("使用 ceiling: " + numbers.ceiling(4));

        // 使用 floor()
        System.out.println("使用 floor: " + numbers.floor(3));

    }
}
```

**输出结果**

```
TreeSet: [2, 4, 5, 6]
使用 higher: 5
使用 lower: 2
使用 ceiling: 4
使用 floor: 2
```

> 当然作为基础的set也可以实现set的方法，执行集合的各种操作


> **TreeMap**
>  
>  

```shell
输入:
["MyCalendar","book","book","book"]
[[],[10,20],[15,25],[20,30]]
输出: [null,true,false,true]
解释: 
MyCalendar myCalendar = new MyCalendar();
MyCalendar.book(10, 20); // returns true 
MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了
MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20
```
```java

class MyCalendar {
     TreeMap<Integer,Integer> map =null;
    public MyCalendar() {
        map =   new TreeMap<>();
    }
    
    public boolean book(int start, int end) {
        // 查找刚刚好大于等于start时间的条目；
        Map.Entry<Integer,Integer> event = map.ceilingEntry(start);
        if(event!=null && event.getKey()<end){
            // 如果刚大于start，但是开始的比要添加进去的end还要早，就错了
            return false;
        }
        // 查找刚刚好小于等于start时间的条目；
        event = map.floorEntry(start);
        // 结束的时间不能比要插入的开始的晚，
        if(event!=null && event.getValue()>start){
            return false;
        }
        map.put(start,end);
        return true;

    }
}

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar obj = new MyCalendar();
 * boolean param_1 = obj.book(start,end);
 */
```

## 图论

参考笔记是 [[图论详解]]

### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

解题思路：这是一个有向图的搜索问题。本质上就是求两个节点之间的距离。

首先定义邻接节点，里面有两个字段，分表表示邻接节点的名称和当前节点到达邻接节点所需的倍数；
然后构造一个map来存储图，map的键就是节点名称，map的值就是节点的邻接节点列表；
遍历给定所有算式，将节点和值都存到map当中；
遍历需要求的问题，深搜每个节点，为了防止进入环绕圈，用一个集合来存储已经搜索过的节点。

```java
class Node{
    public String id;
    public double num;
    public Node(String i,double n){
        id = i;
        num = n;
    }
}
class Solution {
    Map<String, List<Node>> map;
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int n = equations.size();
        map = new HashMap<>();
        double[] ans = new double[queries.size()];
        for (int i = 0; i < n; i++) {
            String divided = equations.get(i).get(0);//被除的数
            String divisor = equations.get(i).get(1);//除数
            if (!map.containsKey(divided)) map.put(divided,new ArrayList<>());
            if (!map.containsKey(divisor)) map.put(divisor,new ArrayList<>());
            map.get(divided).add(new Node(divisor,values[i]));
            map.get(divisor).add(new Node(divided,1/values[i]));//保存和另一个节点的倍数的关系
        }
        int cnt = 0;
        for (List<String> query : queries) {
            ans[cnt] = dfs(query.get(0),query.get(1),1.0,new HashSet<>());
            cnt++;
        }
        return ans;
    }

    /**
     * 深搜
     * @param cur 表示当前节点
     * @param tar 表示目标节点
     * @param k 计算的倍数
     * @param set 保存已经走过的节点
     * @return
     */
    double dfs(String cur,String tar,double k,Set<String> set){
        if (!map.containsKey(cur)||set.contains(cur)) return -1.0;
        if (cur.equals(tar)) return k;
        set.add(cur);
        for (Node node : map.get(cur)) {
            //遍历当前的cur的相邻的边的节点
            double t = dfs(node.id, tar, k * node.num, set);
            if (t!=-1.0) return t;
        }
        return -1.0;
    }
}
```

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

> 解法：

方法一，有环就不可能完成：[[图论详解]]

方法二，主要是理解邻接表。

例如，`numCourses = 5, prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]` 时：

邻接表如下：

- 节点 1 能到节点 2 和节点 4，节点 2 能到节点 3 和节点 4；
- 这就表明节点 2，4 的前置节点都为 1，节点 3，4 的前置节点都为 2。

```java
前置节点        
    1     |2|  ——>  |4|

    2     |3|  ——>  |4|

    3     |5|

    4     |5|

    5
```

在每次 pre 出队时，执行 numCourses--；
若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 000。
因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //入度表
        int[] inDegrees = new int[numCourses];//记录节点的入度的数
        List<List<Integer>> adjacency = new ArrayList<>();//邻接表
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }
        for (int[] pre : prerequisites) {
            //节点的入度等于将以该节点为目标节点的边的数量。
            inDegrees[pre[0]]++;//统计每个节点的入度
            adjacency.get(pre[1]).add(pre[0]);//记录从pre[1]指向出去的值
        }
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                //统计入度为0的值，存入queue
                queue.add(i);//入度为0，说明没有前提预修课程
            }
        }
        // numCourses = 5
        // prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]
        while (!queue.isEmpty()){
            //遍历所有没有以该节点为目标节点的节点，入度为0；
            Integer pre = queue.poll();
            numCourses--;
            for (Integer cur : adjacency.get(pre)) {
                //遍历以该节点为预修课程的节点
                //相当于本来机械设计 需要材料力学和理论力学，汽车设计需要理论力学，理论力学是入度为0的课程
                // 现在的pre等于理论力学，adjacency里面存储的就是 材料力学和理论力学，
                inDegrees[cur]--;//消除掉当前预科对应的这个入度，也就是材料力学和理论力学的入度都--；
                if (inDegrees[cur]==0){ //当入度为0的时候，完成了所有的潜质的课程
                    queue.add(cur);
                }
            }
        }
        return numCourses==0;
    }
}
```


### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2：**

```
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**示例 3：**

```
输入：numCourses = 1, prerequisites = []
输出：[0]
```

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        //入度表
        int[] inDegrees = new int[numCourses];//记录节点的入度的数
        List<List<Integer>> adjacency = new ArrayList<>();//邻接表
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }
        for (int[] pre : prerequisites) {
            //节点的入度等于将以该节点为目标节点的边的数量。
            inDegrees[pre[0]]++;//统计每个节点的入度
            adjacency.get(pre[1]).add(pre[0]);//记录从pre[1]指向出去的值
        }
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                //统计入度为0的值，存入queue
                queue.add(i);//入度为0，说明没有前提预修课程
            }
        }
        int idx = 0;
        int[] ans = new int[numCourses];
        // numCourses = 5
        // prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]
        while (!queue.isEmpty()){
            //遍历所有没有以该节点为目标节点的节点，入度为0；
            Integer pre = queue.poll();
            ans[idx++] = pre;
            for (Integer cur : adjacency.get(pre)) {
                //遍历以该节点为预修课程的节点
                //相当于本来机械设计 需要材料力学和理论力学，汽车设计需要理论力学，理论力学是入度为0的课程
                // 现在的pre等于理论力学，adjacency里面存储的就是 材料力学和理论力学，
                inDegrees[cur]--;//消除掉当前预科对应的这个入度，也就是材料力学和理论力学的入度都--；
                if (inDegrees[cur]==0){ //当入度为0的时候，完成了所有的潜质的课程
                    queue.add(cur);
                }
            }
        }
        if (idx==numCourses) return ans;
        return new int[0];
    }
}
```

### PRIM算法-最小生成树

题目描述：

在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。你是一名探险者，决定前往这些岛屿，但为了节省时间和资源，你希望规划一条最短的路径，以便在探索这些岛屿时尽量减少旅行的距离。

给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。每个岛屿都需要被至少访问一次，你的目标是规划一条最短路径，以最小化探索路径的总距离，同时确保访问了所有岛屿。

输入描述：

第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。

接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。

输出描述：

输出联通所有岛屿的最小路径总距离

输入示例：

```
7 11
1 2 1
1 3 1
1 5 2
2 6 1
2 4 2
2 3 2
3 4 1
4 5 1
5 6 2
5 7 1
6 7 1
```

输出示例：

6

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/640.jpg#id=GWALR&originHeight=499&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**解答：**

最小生成树是所有节点的最小连通子图， 即：以最小的成本（边的权值）将图中所有节点链接到一起。

图中有n个节点，那么一定可以用 n - 1 条边将所有节点连接到一起。

那么如何选择 这 n-1 条边 就是 最小生成树算法的任务所在。

（图中为n为7，即7个节点，那么只需要 n-1 即 6条边就可以讲所有顶点连接到一起）

prim算法 是从节点的角度 采用贪心的策略 每次寻找距离 最小生成树最近的节点 并加入到最小生成树中。

prim算法核心就是三步，我称为**prim三部曲**，大家一定要熟悉这三步，代码相对会好些很多：

1. 第一步，选距离生成树最近节点
2. 第二步，最近节点加入生成树
3. 第三步，更新非生成树节点到生成树的距离（即更新minDist数组）

在prim算法中，有一个数组特别重要，这里起名为：minDist。

（**示例中节点编号是从1开始，所以为了让大家看的不晕，minDist数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混**）

minDist 数组 里的数值初始化为 最大数，因为本题 节点距离不会超过 10000，所以 初始化最大数为 10001就可以。

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/640-20240407155813334.jpg#id=nQhR3&originHeight=664&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int v = scanner.nextInt();
        int e = scanner.nextInt();

        int x, y, k;
        int[][] grid = new int[v + 1][v + 1];
        for (int i = 0; i <= v; i++) {
            Arrays.fill(grid[i], 10001);
        }

        while (e-- > 0) {
            x = scanner.nextInt();
            y = scanner.nextInt();
            k = scanner.nextInt();
            grid[x][y] = k;
            grid[y][x] = k;
        }

        int[] minDist = new int[v + 1];
        Arrays.fill(minDist, 10001);

        boolean[] isInTree = new boolean[v + 1];

        for (int i = 1; i < v; i++) {
            int cur = -1;
            for (int j = 1; j <= v; j++) // 1 - v，顶点编号，这里下标从1开始
              //  选取最小生成树节点的条件：
              //  （1）不在最小生成树里
              //  （2）距离最小生成树最近的节点
              //  （3）只要不在最小生成树里，先默认选一个节点 ，在比较 哪一个是最小的
              //  理解条件3 很重要，才能理解这段代码：(cur == -1 || minDist[j] < minDist[cur])
                if (!isInTree[j] && (cur == -1 || minDist[j] < minDist[cur])) {
                    cur = j;
                }
            }

            isInTree[cur] = true;

            for (int j = 1; j <= v; j++) {
                if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                    minDist[j] = grid[cur][j];
                }
            }
        }

        int result = 0;
        for (int i = 2; i <= v; i++) {
            result += minDist[i];
        }
        
        System.out.println(result);
    }
}
```

### [743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/931_example_1.png#id=coVl1&originHeight=239&originWidth=217&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```

**示例 2：**

```
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
```

**示例 3：**

```
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
```

```java
int N = 110,M = 6010;
int[][] w = new int[N][N];
int INF = 0x3f3f3f;
int n,k;
public int networkDelayTime(int[][] times, int n, int k) {
    this.n = n;
    this.k = k;
    for (int i = 1; i < n + 1; i++) {
        for (int j = 1; j < n + 1; j++) {
            w[i][j]=w[j][i]=i==j?0:INF;
        }
    }
    for (int[] time : times) {
        w[time[0]][time[1]]=time[2];
    }
    floyd();
    int ans = 0;
    for (int i = 1; i < n + 1; i++) {
        ans = Math.max(ans,w[k][i]);
    }
    return ans>=INF/2?-1:ans;

}
void floyd(){
    // floyd 基本流程为三层循环：
    // 枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作   
    for (int p = 1; p < n + 1; p++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < n + 1; j++) {
                //先枚举的中转点，再枚举起点i，终点j
                w[i][j]=Math.min(w[i][j],w[i][p]+w[p][j]);
            }
        }
    }
}
```

## 多叉树

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

[**Trie**](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

Trie 树
TrieTrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。

其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1618369228-slAfrQ-IMG_1659.png#id=rsOnW&originHeight=583&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
class Trie {
    class TrieNode{
        // Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。
        boolean end;
        TrieNode[] tns = new TrieNode[26];
    }
    TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        /**
         * 首先从根结点的子结点开始与 word 第一个字符进行匹配，
         * 一直匹配到前缀链上没有对应的字符，
         * 这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，
         * 同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。
         */
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u] = new TrieNode();
            p = p.tns[u];//26叉树
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        /**
         * 从根结点的子结点开始，一直向下匹配即可，
         * 如果出现结点值为空就返回 false，
         * 如果匹配到了最后一个字符，那我们只需判断 node->isEnd即可。
         */
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) return false;
            p = p.tns[u];//26叉树
        }
        return p.end;
    }

    /**
     * 判断 Trie 中是或有以 prefix 为前缀的单词
     * @param prefix
     * @return
     */
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char c : prefix.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) return false;
            p = p.tns[u];//26叉树
        }
        return true;
    }
}
```

### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。

**示例：**

```
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // 返回 False
wordDictionary.search("bad"); // 返回 True
wordDictionary.search(".ad"); // 返回 True
wordDictionary.search("b.."); // 返回 True
```

```java
class WordDictionary {
    class TrieNode{
        boolean isWord;
        TrieNode[] tns = new TrieNode[26];
    }
    TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void addWord(String word) {
        TrieNode p = root;
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u]= new TrieNode();
            p = p.tns[u];//就是插入一个u的下标的元素
        }
        p.isWord = true;
    }
    
    public boolean search(String word) {
        return dfs(word,root,0);
    }
  //dfs深度搜索
    boolean dfs(String s,TrieNode p,int idx){
        if (idx==s.length()) return p.isWord;
        char c = s.charAt(idx);
        if (c=='.'){
            for (int i = 0; i < 26; i++) {
                //遍历一下所有的26个字母，如果不等于null，继续回溯遍历
                if (p.tns[i]!=null && dfs(s,p.tns[i],idx+1)) return true;
            }
            return false;
        }else {
            if (p.tns[c-'a']==null) return false;
            return dfs(s,p.tns[c-'a'],idx+1);//继续遍历下一个。
        }
    }
}
```

### [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， _返回所有二维网格上的单词_ 。

单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg#id=kSK9o&originHeight=322&originWidth=322&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

**示例 2：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/search2.jpg#id=WlrhK&originHeight=162&originWidth=162&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]
```

**提示：**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` 是一个小写英文字母
- `1 <= words.length <= 3 * 104`
- `1 <= words[i].length <= 10`

```java
class Solution {
    class TrieNode{
        String s;
        TrieNode[] tns= new TrieNode[26];
    }
    void insert(String s){
        TrieNode p = root;
        for (char c : s.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u] = new TrieNode();
            p = p.tns[u];
        }
        p.s = s;//存储当前的单词
    }
    Set<String> set = new HashSet<>();
    char[][] board;
    int m,n;//方块的大小小于 12
    TrieNode root = new TrieNode();
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    boolean[][] vis = new boolean[15][15];//15够用了
    public List<String> findWords(char[][] board, String[] words) {
        this.board = board;
        m = board.length;
        n = board[0].length;
        for (String word : words) {
            insert(word);//将所有的单词存进去字典树里面，如果遍历到有单词的时候，就直接添加到结果
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int u = board[i][j] - 'a';
                if (root.tns[u]!=null){
                    //当前棋盘当前位置能够在字典树找到对应的字母就继续开始寻找
                    vis[i][j]=true;
                    dfs(i,j,root.tns[u]);
                    vis[i][j] = false;
                }
            }
        }
        List<String> ans = new ArrayList<>();
        for (String s : set) {
            ans.add(s);
        }
        return ans;
    }
    void dfs(int i,int j,TrieNode node){
        if (node.s!=null) set.add(node.s);
        for (int[] dir : dirs) {
            int dx = i+dir[0],dy = j+dir[1];
            if (dx<0||dx>=m||dy<0||dy>=n) continue;//超限的就不遍历了
            if (vis[dx][dy]) continue;//遍历过的就不遍历了。
            int u = board[dx][dy] - 'a';
            if (node.tns[u]!=null){
                vis[dx][dy]=true;
                dfs(dx,dy,node.tns[u]);
                vis[dx][dy] = false;
            }
        }
    }
}
```

## 堆/优先队列

### 方法摘要
| **Modifier and Type** | **Method and Description** |
| --- | --- |
| `**boolean**` | `**add(E e)**`
,**将指定的元素插入到此优先级队列中。** |
| `**void**` | `**clear()**`
,**从此优先级队列中删除所有元素。** |
| `**Comparator<? super E>**` | `**comparator()**`
,**返回用于为了在这个队列中的元素，或比较**`**null**`
**如果此队列根据所述排序 **[**natural ordering**](https://blog.csdn.net/qq_22596931/java/lang/Comparable.html)
** 的元素。** |
| `**boolean**` | `**contains(Object o)**`
,**如果此队列包含指定的元素，则返回 **`**true**`
** 。** |
| `**Iterator<E>**` | `**iterator()**`
,**返回此队列中的元素的迭代器。** |
| `**boolean**` | `**offer(E e)**`
,**将指定的元素插入到此优先级队列中。** |
| `**E**` | `**peek()**`
,**检索但不删除此队列的头，如果此队列为空，则返回 **`**null**`
** 。** |
| `**E**` | `**poll()**`
,**检索并删除此队列的头，如果此队列为空，则返回 **`**null**`
** 。** |
| `**boolean**` | `**remove(Object o)**`
,**从该队列中删除指定元素的单个实例（如果存在）。** |
| `**int**` | `**size()**`
,**返回此集合中的元素数。** |
| `**Spliterator<E>**` | `**spliterator()**`
,**在此队列中的元素上创建 ***[**late-binding**](https://blog.csdn.net/qq_22596931/article/details/Spliterator.html#binding)
*** 和*失败快速* **`[**Spliterator**](https://blog.csdn.net/qq_22596931/java/util/Spliterator.html)`
** 。** |
| `**Object[]**` | `**toArray()**`
,**返回一个包含此队列中所有元素的数组。**元素没有特定的顺序。返回的数组将是 “安全的”，因为该队列不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 因此，调用者可以自由地修改返回的数组。此方法充当基于阵列和基于集合的 API 之间的桥梁。 |
| `**<T> T[]**` | `**toArray(T[] a)**`
,**返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。** |


不指定 Comparator 时默认为最小堆, 通过传入自定义的 Comparator 函数可以实现大顶堆。

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(); //小顶堆，默认容量为11
PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(new Comparator<Integer>(){ //大顶堆，容量11
    @Override
    public int compare(Integer i1,Integer i2){
        return i2-i1;
    }
});
PriorityQueue<String> priorityQueue = new PriorityQueue<>(Comparator.reverseOrder());
```

这是一颗包含整数 1, 2, 3, 4, 5, 6, 7 的**小顶堆：**

```latex
      1
     / \
    2   3
   / \ / \
  4  5 6  7
```

这是一颗大顶堆。

```
            8
          /   \
         7     5
        / \   / \
       6   4 2   1
```

```java
//自定义比较器，降序排列
	static Comparator<Integer> cmp = new Comparator<Integer>() {
	      public int compare(Integer e1, Integer e2) {
	        return e2 - e1;  //降序
	      }
	    };
	public static void main(String[] args) {
	        //不用比较器，默认升序排列
	        Queue<Integer> q = new PriorityQueue<>();
	        q.add(8);
	        q.add(5);
	        q.add(13);
	        q.add(2);
	        System.out.println("**,********不使用比较器********************");
	        while(!q.isEmpty())
	        {
	            System.out.print(q.poll()+" ");
	        }
	        System.out.println();
	        System.out.println("**********使用比较器********************");
	        //使用自定义比较器，降序排列
	        Queue qq = new PriorityQueue(cmp);
	        qq.add(8);
	        qq.add(5);
	        qq.add(13);
	        qq.add(2);
	        while(!qq.isEmpty())
	        {
	            System.out.print(qq.poll()+" ");
	        }
	}

**********不使用比较器********************
2 5 8 13 
**********使用比较器********************
13 8 5 2
```

PriorityQueue 的 iterator（）不保证以任何特定顺序遍历队列元素。若想按特定顺序遍历，先将队列转成数组，然后排序遍历

```java
Queue<Integer> q = new PriorityQueue<>(cmp);
        int[] nums= {2,5,3,4,1,6};
        for(int i:nums)
        {
            q.add(i);
        }
        Object[] nn=q.toArray();
        Arrays.sort(nn);
        for(int i=nn.length-1;i>=0;i--)
            System.out.print((int)nn[i]+" ");
        /**
         * 输出结果
         * 6 5 4 3 2 1 
         */
```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        //使用堆的方法
        if (nums==null||nums.length<k ||k==0) return Integer.MIN_VALUE;
        PriorityQueue<Integer> maxQ = new PriorityQueue<>(Collections.reverseOrder());
        for (int num : nums) {
            maxQ.add(num);
        }
        while (k-->1){
            maxQ.poll();
        }
        return maxQ.peek();
    }
}
```

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        //使用堆的方法
        if (nums==null||nums.length<k ||k==0) return Integer.MIN_VALUE;
        PriorityQueue<Integer> maxQueue = new PriorityQueue<>(
            new Comparator<Integer>(){
                @Override
                public int compare(Integer o1,Integer o2){
                    return o2-o1;
                }
            }
        );
        for(int u: nums){
            maxQueue.add(u);
        }
        for(int i = k; i>1;i--){
            maxQueue.poll();
        }
        return maxQueue.peek();

    }
}
```

# 二、算法问题

## 排序算法

[相对路径](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md)

## 双指针算法
### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。

**示例 1：**
![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1714622261324-1a52b70b-56be-4f9d-9722-4721aee20f02.jpeg#averageHue=%234a4b49&clientId=ud7ca9d0f-538b-4&from=paste&id=uf5783842&originHeight=383&originWidth=801&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u76aa2da2-8f22-436d-b9bb-806d071afff&title=)
```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
**示例 2：**
```
输入：height = [1,1]
输出：1
```

这道题目看似简单，做起来才发现不容易。分治法、动态规划都用不上，要想得到 O(n)O(n)O(n) 的解法只有使用双指针一条路。即使看了答案知道了双指针解法，你也可能并不清楚这个解法为什么正确。为什么双指针往中间移动时，不会漏掉某些情况呢？
用一句话概括双指针解法的要点：指针每一次移动，都意味着排除掉了一个柱子。
如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 _d_=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 _h_=3。水的面积就是 3×8=24。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/1389077/1714622419051-4cf9cc23-a95f-4200-8de7-4a4420088e87.png#averageHue=%23e7e4e2&clientId=ud7ca9d0f-538b-4&from=paste&height=250&id=u26337615&originHeight=500&originWidth=1200&originalType=binary&ratio=2&rotation=0&showTitle=false&size=29729&status=done&style=none&taskId=ue8a7337e-ce13-4379-843e-b184d82e692&title=&width=600)
如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：

- 当前柱子是最两侧的柱子，水的宽度 ddd 为最大，其他的组合，水的宽度都比这个小。
- 左边柱子较短，决定了水的高度为 `3`。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。
- 如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 `3`，也就是不会超过现在的水面高度。

![image.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1714622445083-b601c4d3-610f-4df6-be49-4dd24ca4010f.jpeg#averageHue=%23ede9e5&clientId=u9235c46d-065e-4&from=paste&id=ue8a472f3&originHeight=500&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&size=76713&status=done&style=none&taskId=ua2393a4e-5439-4f35-aaf0-fe3d326ccbb&title=)
由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。
这个排除掉左边柱子的操作，就是双指针代码里的 `i++`。`i` 和 `j` 两个指针中间的区域都是还未排除掉的区域。随着不断的排除，`i` 和 `j` 都会往中间移动。当 `i` 和 `j` 相遇，算法就结束了。

```java
public int maxArea(int[] height) {
    //双指针贪心算法
    int left = 0;
    int right = height.length-1;
    int res  =0;
    while (left<right){
        if (height[left]<height[right]){
            //水是短板效应。
            //这个时候left的柱子就是代表这个宽度里面最大面试的水了
            //无论怎么右边柱子怎么移动，水只能到left这个高度，而且宽度还会降低
            res = Math.max(res,(right-left)*height[left]);
            left++;
        }else {
            res = Math.max(res,(right-left)*height[right]);
            right--;
        }
    }
    return res;
}
```
 
### 34.搜索排序数组第一个和最后一个元素。
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```
**示例 2：**
```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```
**示例 3：**
```
输入：nums = [], target = 0
输出：[-1,-1]
```
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        int s = -1;
        int e = -1;
        while (l<=r){
            //[l,r],所以l《=r是一个合法的区间
            int m = l + (r - l) / 2;
            if (nums[m]==target){
                while (m>=0&&nums[m]==target){
                    m--;
                }
                s = m+1;
                m++;
                while (m< nums.length&&nums[m]==target){
                    m++;
                }
                e = m-1;
                return new int[]{s,e};
            } else if (nums[m] > target) {
                r = m-1;
            }else {
                l = m+1;
            }
        }
        return new int[]{s,e};
    }
}
```
## KMP
参考：[[KMP算法]]

```java
public class kmp {
    public static void main(String[] args) {
        String str1 = "BBCABCDABABCDABCDABDE";
        String str2 = "ABCDABD";
        System.out.println(Arrays.toString(kmpNext(str2)));
        System.out.println(kmpSearch(str1,str2,kmpNext(str2)));
    }
    public static int kmpSearch(String s1,String s2,int[] next){
        for (int i = 0,j=0; i < s1.length(); i++) {
            //不匹配就获取上一次的部分匹配表的上一位
            while (j>0&&s1.charAt(i)!=s2.charAt(j)) j =next[j-1];
            if (s1.charAt(i)==s2.charAt(j)) j++;
            if (j==s2.length()) return i-j+1;
        }
        return -1;
    }
    public static int[] kmpNext(String dest){
        int[] next = new int[dest.length()];
        next[0] = 0;//[ABCDABD],[A]的部分匹配表是0
        int j = 0;
        for (int i = 1; i < dest.length(); i++) {
            while (j>0&&dest.charAt(i)!=dest.charAt(j)){
                j = next[j-1];//看作是j以前的小串去匹配i的大串
            }
            if (dest.charAt(i)==dest.charAt(j)) j++;
            next[i]=j;
        }
        return next;
    }

}
```
## 递归算法

### 257 二叉树的所有路径

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]

```java
    List<TreeNode> path = new ArrayList<>();
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return ans;
        recur(root,"");
        return ans;
    }
    public void recur(TreeNode root,String path) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            ans.add(new StringBuilder(path).append(root.val).toString());
            return;//叶子节点的时候就保存一下
        }
        String tmp = new StringBuilder(path).append(root.val).append("->").toString();
        recur(root.left,tmp);
        recur(root.right,tmp);
    }�
```

## 回溯算法模版

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20210130173631174.png#id=FiBgs&originHeight=736&originWidth=1558&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

如果是求目标target，就是找到target之后是多少层就是多少层。

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }a

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯函数遍历过程伪代码如下：

```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        traverse(candidates,target,0);
        return ans;
    }
    private void traverse(int[] candidates,int target,int idx){
        if (sum==target){
            ans.add(new ArrayList<>(path));
            return;
        }
        if (sum>target) return;
        for (int i = idx; i < candidates.length; i++) {
          //这里是在遍历集合区间，可以理解一个节点有多少个孩子，idx就是保证每一次遍历后
          //孩子节点都会少一个。
            int candidate = candidates[i];
            if (i>idx&&candidates[i-1]==candidate) continue;
            //去除重复的，比如[1,2,2,3,3,4,5] 这样遍历的时候，就会去除重复的2和重复的3
            //wocao,这里确实碉堡了
          //如果不是上这样，结果就是【1 2 6】、【1 2 6】这样会用重复的结果，
          
            if (candidate >target) return;
            sum+=candidate;
            path.add(candidate);
            traverse(candidates, target, i+1);
            sum-=candidate;
            path.remove(path.size()-1);
        }
    }
}
```

### **FZ1** **牛牛的三元组问题**-三元之和为0

动物牛牛是一个勇敢的冒险家，它正在探索一个神秘的岛屿。岛上有许多宝藏，但是宝藏被隐藏在一系列数字中。牛牛找到了一个整数数组 `nums`，它相信这个数组中存在一些特殊的三元组，满足以下条件：

- 三元组的和等于 0。
- 三元组中的元素不能重复。
- 牛牛想按照字典序返回所有满足条件的三元组。

请你帮助牛牛解决这个问题，设计一个函数 `findTriplets`，接收一个整数数组 `nums` 作为参数，并返回一个二维整数数组，表示满足条件的三元组，按照字典序返回所有的三元组。

```java
ArrayList<int[]> list = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    boolean[] used ;
    int sum = 0;
    public int[][] findTriplets (int[] nums) {
        Arrays.sort(nums);
        used = new boolean[nums.length];
        back(nums,0);
        //回溯算法,元素可以重复，但是不可复选
        return list.toArray(new int[list.size()][3]);
    }
    void back(int[] nums,int idx){
        if (path.size()==3&&sum==0) {
            list.add(new int[]{path.get(0),path.get(1),path.get(2)});
            return;
        }
        if (sum>0) {
            return;
        }
        for (int i = idx; i < nums.length; i++) {
            int num = nums[i];
            if (used[i] || (i>0&&nums[i-1]==nums[i]&&!used[i-1])) {
                continue;//如果是使用过的，或者当前和上一个元素相等，并且没使用过上一个
            }
            if (sum>0) {
                return;//
            }
            sum+=num;
            path.add(num);
            used[i]=true;
            back(nums, i+1);
            path.remove(path.size()-1);
            used[i]=false;
            sum-=num;
        }

    }
```

### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

```java

class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();//过程路径
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        //数组元素重复，但是搭配不能重复，
        vertrace(nums,0);
        return ans;
    }
    void vertrace(int[] nums,int idx){
        ans.add(new ArrayList<>(path));//存储
        for (int i = idx; i < nums.length; i++) {
            //回溯算法注意遍历的广度和深度
            if (i>idx&&nums[i-1]==nums[i]){
                continue;//如果同一个树树干上使用过相同的，就跳过
            }
            path.add(nums[i]);
            vertrace(nums,i+1);
            path.remove(path.size()-1);
        }
        return;
    }
}
```

### 47.全排列 II

[力扣题目链接](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

- 输入：nums = [1,1,2]
- 输出：
[[1,1,2],
[1,2,1],
[2,1,1]]

示例 2：

- 输入：nums = [1,2,3]
- 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

提示：

- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10

这道题目和[46.全排列](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)的区别在与**给定一个可包含重复数字的序列**，要返回**所有不重复的全排列**。

这里又涉及到去重了。

在[40.组合总和II](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html) 、[90.子集II](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)我们分别详细讲解了组合问题和子集问题如何去重。

那么排列问题其实也是一样的套路。

**还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201331223-20230802163414885.png#id=qZEW1&originHeight=1098&originWidth=1894&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

如果是按照used[i-1]=true时候：按树枝来减

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/%E5%85%A8%E6%8E%92%E5%88%97%E5%8E%BB%E9%87%8D%E5%A4%8D.drawio.svg#id=LK6bo&originHeight=532&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。

**一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果**。

在[46.全排列](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)中已经详细讲解了排列问题的写法，在[40.组合总和II](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html) 、[90.子集II](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)中详细讲解了去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```

大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 **`**used[i - 1] == true**`**， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201406192.png#id=UKLLl&originHeight=962&originWidth=1534&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

树枝上去重（used[i - 1] == true）的树型结构如下：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201431571-20230802163519118.png#id=AonsF&originHeight=1156&originWidth=2274&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。

总结

这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

和这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

都是可以的，这也是很多同学做这道题目困惑的地方，知道`used[i - 1] == false`也行而`used[i - 1] == true`也行，但是就想不明白为啥。

所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！

是不是豁然开朗了！！

### [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> res= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTrace(n,k,1);//递归函数返回值为void，一般直接就在参数里面修改
        return res;
    }
    void backTrace(int n,int k, int s){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        /*
        已经选择的元素个数：path.size();
        还需要的元素个数为: k - path.size();
        在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
        */
        //可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠s
        for(int i =s;i<=n-(k-path.size())+1;i++ ){
            path.add(i);
            backTrace(n,k,i+1);
            path.removeLast();
        }
    }
}
```

> 如果 `n = 7, k = 4`，**从 5 开始搜索就已经没有意义了**，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。
>  
> 因此在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
>  

```java
        for (int i = begin; i <= n-(k-path.size())+1; i++) {
```

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67.png#id=hmY0J&originHeight=784&originWidth=1360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/200px-telephone-keypad2svg.png#id=Ex3Mq&originHeight=162&originWidth=200&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    HashMap<Integer,String> map = new HashMap<>(){
        {
            put(2,"abc");
            put(3,"def");
            put(4,"ghi");
            put(5,"jkl");
            put(6,"mno");
            put(7,"pqrs");
            put(8,"tuv");
            put(9,"wxyz");
        }
    };
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits.length()==0) return ans;
        back(digits,0,0);
        //回溯算法，就是遍历
        return ans;
    }
    void back(String digits,int idx,int charIdx){
        if (idx==digits.length()){
            ans.add(sb.toString());
            return;
        }
        //遍历数字，
        char c = digits.charAt(idx);
        String s = map.get(c - '0');
        for (int j = 0; j < s.length(); j++) {
            //单个字符的长度
            sb.append(s.charAt(j));
            back(digits,idx+1,j);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

### [剑指 Offer II 084. 含有重复元素集合的全排列 ](https://leetcode.cn/problems/7p8L0Z/)

给定一个可包含重复数字的整数集合 `nums` ，**按任意顺序** 返回它所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);//排列一下
        used = new boolean[nums.length];
        back(nums);
        return ans;
    }
    void back(int[] nums){
        if (path.size() == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        int last = -11;
        for (int i = 0; i < nums.length; i++) {
            if ((used[i] || i>0 && nums[i]==nums[i-1] && used[i-1]))
                continue;//去掉重
            // i>0 && nums[i]==nums[i-1] && used[i-1] 这里应该是说如果当前元素和上一个相同，有可能是可以继续使用的
//            判断为不能使用的话，得加一个判断，判断之前的元素也是用过的，那就可以了
            path.add(nums[i]);
            used[i]= true;
            back(nums);
            used[i]= false;
            path.remove(path.size()-1);
        }
    }
}
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和`"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        //startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。
        //本题我们还需要一个变量pointNum，记录添加逗点的数量。
        if (s.length()>12) return ans;
        backTrace(s,0,0);
        return ans;
    }
    void backTrace(String s, int begin,int pointNumber) {
        if (pointNumber==3){
            //此时已经到达了最后一个阶段，判断begin到最后的一段是否合法，不合法就不添加
            if (isValid(s,begin,s.length()-1))
                ans.add(s);
            return;
        }
        for (int i = begin; i < s.length(); i++) {
            if (isValid(s,begin,i)){
                s=s.substring(0, i + 1) + "." + s.substring(i + 1);
                //插入一个。
                pointNumber++;
                backTrace(s,i+2,pointNumber);
                pointNumber--;
                s=s.substring(0, i + 1) + s.substring(i + 2);
            }else {
                continue;
            }
        }
    }
    boolean isValid(String s,int begin,int end) {
        if (begin>end) return false;
        if (s.charAt(begin)=='0'&&begin!=end){
            return false;
            //0开头的数字不合法，此时begin和end不相等的
        }
        int num =0;

        for (int i = begin; i <= end; i++) {
            if (s.charAt(i)>'9'||s.charAt(i)<'0')
                return false;
            num = num *10 + (s.charAt(i)-'0');
            if (num>255)
                return false;
        }
        return true;
    }
}
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg#id=h7yeP&originHeight=494&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

```java
class Solution {
    HashMap<Long,Integer> map = new HashMap<>();
    public int pathSum(TreeNode root, int targetSum) {
//        回溯算法
        map.put(0L,1);//存储前缀和为0的次数为1；
        return recursion(root,targetSum,0L);
    }
    int recursion(TreeNode root,int targetSum,Long currSum) {
        if (root==null) return 0;
        int res = 0;
        currSum+=root.val;
        // 看看root到当前节点这条路上是否存在[节点前缀和加target] 为currSum的路径
        //currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target
        //因为currSUm是前缀和，也就是前面所有的都加起来，如果之前走过的路上有事currSum-target的位置，那么
        //那个位置到现在，currSum-(curr-target)=target，不就是一个你需要的target吗？
        res+=map.getOrDefault(currSum-targetSum,0);
        // 更新路径上当前节点前缀和的个数
        map.put(currSum,map.getOrDefault(currSum,0)+1);
        res+=recursion(root.left,targetSum,currSum);
        res+=recursion(root.right,targetSum,currSum);
        map.put(currSum,map.getOrDefault(currSum,0)-1);
        return res;
    }

}
```

### ![](https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f31f.svg#height=18&id=T0zVI&originHeight=150&originWidth=150&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=18) [112. 路径总和](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg#id=F89Si&originHeight=421&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsum2-20231026201006343.jpg#id=l32ge&originHeight=181&originWidth=212&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

[https://www.bilibili.com/video/BV19t4y1L7CR/?t=46](https://www.bilibili.com/video/BV19t4y1L7CR/?t=46)

```java
// 标准回溯的写法：

class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        //要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。
        //遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。
        if(root==null) return false;
        return recur(root,targetSum-root.val);
    }
    boolean recur(TreeNode root,int targetSum){
        if(root==null) return false;
//        targetSum-=root.val;
        if(root.left==null&&root.right==null&&targetSum==0) return true;
        if(root.left==null&&root.right==null) return false;
        if(root.left!=null){
//            targetSum-=root.left.val;
//            if (recur(root.left,targetSum)) return true;
//            targetSum+=root.left.val;
            //上面的代码可以缩减为一行，其实你只要穿一个虚幻的树枝下去，不用实际更改targetSum的值就可以回溯
            if (recur(root.left,targetSum-root.left.val)) return true;
        }
        if(root.right!=null){
            targetSum-=root.right.val;
            if (recur(root.right,targetSum)) return true;
            targetSum+=root.right.val;
        }
        return false;
    }
}
```

### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsumii1.jpg#id=I034z&originHeight=421&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsum2.jpg#id=u0Ay8&originHeight=181&originWidth=212&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

```java
class Solution {

    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        //如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。
        recur(root,targetSum);
        return ans;
    }
    void recur(TreeNode root,int target){
        if(root==null) return;
        path.add(root.val);
        target-=root.val;
        if (root.left==null&&root.right==null&&target==0){
            ans.add(new ArrayList<>(path));
        }
        recur(root.left,target);
        recur(root.right,target);
        path.remove(path.size()-1);
    }
}
```

```java
// 标准回溯的写法：
class Solution {

    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null) return ans;
        //如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。
        path.add(root.val);
        recur(root,targetSum-root.val);//这里对最开始的处理了，就得在path加上这个val。
        return ans;
    }
    void recur(TreeNode root,int target){

        if (root.left==null&&root.right==null&&target==0){
            ans.add(new ArrayList<>(path));
            return;
        }
        if (root.left==null&&root.right==null){
            return;
        }
        if(root.left!=null){
            path.add(root.left.val);
            target-=root.left.val;
            recur(root.left,target);
            target+=root.left.val;
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            path.add(root.right.val);
            target-=root.right.val;
            recur(root.right,target);
            target+=root.right.val;
            path.remove(path.size()-1);
        }
        return;
    }
}
```

### [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)

给定一个字符串 `s` ，请将 `s` 分割成一些子串，使每个子串都是 **回文串** ，返回 s 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

```
输入：s = "google"
输出：[["g","o","o","g","l","e"],["g","oo","g","l","e"],["goog","l","e"]]
```

```java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();
    private String s;
    public String[][] partition(String s) {
        this.s = s;
        back(0);
        String[][] res = new String[ans.size()][];
        for (int i = 0; i < ans.size(); i++) {
            String[] temp = new String[ans.get(i).size()];
            for (int j = 0; j < ans.get(i).size(); j++) {
                temp[j] = ans.get(i).get(j);
            }
            res[i] = temp;//这里的temp每一个都是不同的。
        }
        return res;
    }
    void back(int idx){
        if (idx == s.length()){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            if (isPali(idx,i)) {
                path.add(s.substring(idx,i+1));
                back(i+1);
                path.remove(path.size()-1);
            }
        }
    }
    boolean isPali(int left,int right){
        while (left < right)
            if (s.charAt(left++) != s.charAt(right--))
                return false;
        return true;
    }
}
```

### 79.单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**输入：**board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED" **输出：**true

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board,word,0,i,j)) return true;
            }
        }
        return false;
    }
    int[] dx = new int[]{-1,0,1,0},dy =  new int[]{0,1,0,-1};
    boolean dfs(char[][] board,String word,int u,int x,int y){
        if (board[x][y]!=word.charAt(u)) return false;
        if (u==word.length()-1) return true;
        char c = board[x][y];
        board[x][y]='.';
        for (int i = 0; i < 4; i++) {
            int a = x+dx[i],b = y+dy[i];
            if (a<0||a>=board.length||b<0||b>=board[0].length||board[a][b]=='.')
                continue;
            if (dfs(board,word,u+1,a,b)) return true;
        }
        board[x][y]=c;
        return false;
    }
}
```

### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1:**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/tree1.jpg#id=oZJe9&originHeight=182&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg#id=PGsiC&originHeight=421&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

```java
class Solution {
    int deepest = Integer.MIN_VALUE;
    int ans = 0;
    public int findBottomLeftValue(TreeNode root) {
        recur(root,1);
        return ans;
    }
    void recur(TreeNode root,int depth){
        if (root==null) return;
        if (root.left==null&&root.right==null&&depth>deepest){
            ans = root.val;
            deepest = Math.max(deepest,depth);
        }
//        if (root.left!=null){
//            recur(root.left,depth+1);
//        }
        recur(root.left,depth+1);//还可以缩减成这样，因为就算是null传进去了，也无所谓
//        if (root.right!=null){
//            recur(root.right,depth+1);
//        }
        recur(root.right,depth+1);
    }
}
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        backtrack(n,n,"");
        return ans;
    }
    void backtrack(int l,int r,String cur){
        if (l==0&&r==0){
            ans.add(cur);
            return;
        }
        if (l>0){
            backtrack(l-1,r,cur+'(');
        }
        if (r>l){
            backtrack(l,r-1,cur+')');
        }
    }
}
```

### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/word2.jpg#id=VEAhq&originHeight=242&originWidth=322&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

```java
class Solution {
    boolean[][] visited = new boolean[15][15];
    int m,n;
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board,i,j,word,0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board,int i,int j, String word,int idx){
        if (board[i][j]!= word.charAt(idx)) return false;
        if (idx==word.length()-1) return true;
        visited[i][j]=true;
        for (int[] dir : dirs) {
            int dx = i+dir[0],dy = j+dir[1];
            if (dx<0||dx>=m||dy<0||dy>=n||visited[dx][dy]) continue;//超限的就不遍历了
            if (dfs(board,dx,dy,word,idx+1)) return true;
        }
        visited[i][j]=false;
        return false;
    }
}
```

## 动态规划

### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/minpath.jpg#id=R7n57&originHeight=242&originWidth=242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

解题

```bash
原始数组
[1, 2, 3]
[2, 5, 6]
[1, 2, 7]
[4, 1, 6]
最小路径和路径： [1, 2, 1, 2, 1, 6]
sum = 13
```

```java
public static void main(String[] args) {
    int[][] grid = {{1,2,3},
                    {2,5,6},
                    {1,2,7},
                    {4,1,6}};
    System.out.println("原始数组");
    for (int i = 0; i < grid.length; i++) {
        System.out.println(Arrays.toString(grid[i]));
    }
    int sum = minPathSum(grid);
    System.out.println("sum = " + sum);
}
public static int minPathSum(int[][] grid) {
    //动态规划
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0]=grid[0][0];
    for (int i = 1; i < m; i++) {
        dp[i][0]=dp[i-1][0]+grid[i][0];
    }
    for (int i = 1;i < n; i++) {
        dp[0][i]=dp[0][i-1]+grid[0][i];
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
        }
    }
  
    // 显示路径
    int r = m - 1;
    int c = n - 1;
    LinkedList<Integer> resultPath = new LinkedList<>();
    resultPath.add(grid[r][c]);
    while (true) {
        if (r - 1 >= 0 && c - 1 >= 0) {
            if (dp[r - 1][c] < dp[r][c - 1]) {
                resultPath.addFirst(grid[r - 1][c]);
                r = r - 1;
            } else {
                resultPath.addFirst(grid[r][c - 1]);
                c = c - 1;
            }
        } else if (r == 0 && c - 1 >= 0) {
            while (c - 1 >= 0) {
                resultPath.addFirst(grid[0][c - 1]);
                c = c - 1;
            }
        } else if (c == 0 && r - 1 >= 0) {
            while (r - 1 >= 0) {
                resultPath.addFirst(grid[r - 1][0]);
                r = r - 1;
            }
        } else {
            break;
        }
    }
    System.out.print("最小路径和路径： ");
    System.out.println(Arrays.toString(resultPath.toArray()));
    return dp[m-1][n-1];
}
```

### [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg#id=M7vWM&originHeight=203&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true
```

我们定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。

状态转换方程也很好写了，如果要求 dp [ i ] [ j ] 。

如果 dp [ i - 1 ] [ j ] == true，并且 s1 [ i - 1] == s3 [ i + j - 1]， dp [ i ] [ j ] = true 。

如果 dp [ i ] [ j - 1 ] == true，并且 s2 [ j - 1] == s3 [ i + j - 1]， dp [ i ] [ j ] = true 。

否则的话，就更新为 dp [ i ] [ j ] = false。

如果 i 为 0，或者 j 为 0，那直接判断 s2 和 s3 对应的字母或者 s1 和 s3 对应的字母即可。

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s3.length()!=(s1.length()+s2.length())) return false;
        int m = s1.length();
        int n = s2.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                int k = i+j-1;
                if (i>0){
                    //向前推进dp数组，新的dp等于原来的是不是true，然后当前的字符是不是相等的
                    dp[i][j] = dp[i-1][j] &&(s1.charAt(i-1)==s3.charAt(k));
                }
                if (j>0){
                    dp[i][j] = dp[i][j] ||(dp[i][j-1]&&s2.charAt(j-1)==s3.charAt(k));
                }
            }
        }
        return dp[m][n];
        //dp[i][j] 表示的是当前是否是s3的i+j的正确的表达式
        //if(s3.chatAt(i+j)==s1.char或者s2.char -》dp[i][j] = dp[i-1][j]

    }
}
```

### II 019回文字符

给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。

**示例 1:**

```
输入: s = "aba"
输出: true
```

**示例 2:**

```
输入: s = "abca"
输出: true
解释: 可以删除 "c" 字符 或者 "b" 字符
```

```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }
        }
        return true;
    }
    private boolean validSub(String s,int le,int ri){
        while (le<ri){
            if (s.charAt(le)!=s.charAt(ri)) return false;
            le++;
            ri--;
        }
        return true;
    }
}
```

### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给定一个字符串 `s` ，请计算这个字符串中有多少个回文子字符串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

注意：本题与主站 647 题相同：[https://leetcode-cn.com/problems/palindromic-substrings/](https://leetcode-cn.com/problems/palindromic-substrings/)

> 注意：⚠️本题其实和动态规划法求解[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) 是一样的方法，只是在得到`dp[i][j]`处理的方法不一样。


```java
class Solution {
    public int countSubstrings(String s) {
        //动态规划，dp[i][j]表示i到j是否是回文串
        int length = s.length();
        boolean[][] dp = new boolean[length][length];
        int count = 0;
        for (int i = 0; i < length; i++) {
            dp[i][i] = true;
            count++;
        }
        /*
        * 当下标 i 和 j 相同时：区间只有一个字母，是回文子串。
        * 当下标 i 和 j 相差为 1 时：区间有两个字母，且这两个字母相同，是回文子串。
        * 当下标 i 和 j 相差大于 1 时：此时有 s[i] == s[j] ，
        要看区间 [i, j] 是不是回文子串，就得看中间夹着的区间 [i + 1, j - 1]
        是不是回文子串，即当 dp[i + 1][j - 1] = true 时，
        区间 [i, j] 是回文子串，否则就不是回文子串。
         */
        for (int i = length-1; i >= 0; i--) {
            for (int j = i+1; j < length; j++) {
                char ci = s.charAt(i);
                char cj = s.charAt(j);
                if (j-1>=i+1){
                    //中间的区间
                    dp[i][j] = (ci==cj) && dp[i+1][j-1];
                }else {
                    dp[i][j] = (ci==cj);//只有一个元素的时候
                }
                if (dp[i][j]) count++;
                //如果上述判断完了之后是true，那么就计数+1；
            }
        }
        return count;
    }
}
```

```java
for (int i = 0; i < n; i++) {
  for (int j = 0; j < i; j++) {
    char ci = s.charAt(i);
    char cj = s.charAt(j);
    if (i>j+1){
      dp[j][i]=(dp[j+1][i-1])&&(ci==cj);
    }else {
      dp[j][i]=(ci==cj);
    }
    if (dp[j][i]) count++;
  }
}
```

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

#### 中心扩散法

本题最容易想到的一种方法应该就是 **中心扩散法**。

中心扩散法怎么去找回文串？

从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。举个例子，_str_=_acdbbdaa_ 我们需要寻找从第一个 b（位置为 3）出发最长回文串为多少。怎么寻找？

首先往左寻找与当期位置相同的字符，直到遇到不相等为止。

然后往右寻找与当期位置相同的字符，直到遇到不相等为止。

最后左右双向扩散，直到左和右不相等。如下图所示：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2f205fcd0493818129e8d3604b2d84d94678fda7708c0e9831f192e21abb1f34.png#id=ca0rr&originHeight=684&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

每个位置向两边扩散都会出现一个窗口大小（`len`）。如果 `len>maxLen`(用来表示最长回文串的长度）。则更新 `maxLen` 的值。
因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 `maxLen` 时的起始位置（`maxStart`），即此时还要 `maxStart=len`。

```java
class Solution {
    public String longestPalindrome(String s) {
        //用中间向两边扩散的方法
        if (s.length()<2) return s;
        int n = s.length();
        int maxLeft=0,maxRight=0;
        int left = 0,right = 0;
        int len = 1;
        int maxLen = 0;
        for (int i = 0; i < n; i++) {
            left = i-1;
            right = i+1;
            while (left>=0 && s.charAt(left)==s.charAt(i)) {
                left--;
                len++;
            }
            while (right<n && s.charAt(right)==s.charAt(i)) {
                right++;
                len++;
            }
            //left 和right都是不和i处相等的了，
            while (left>=0 && right<n && s.charAt(left)==s.charAt(right)) {
                len+=2;
                left--;
                right++;
            }
            if (len>maxLen){
                maxLen=len;
                maxLeft=left;
                maxRight=right;
            }
            len=1;
        }
        return s.substring(maxLeft+1,maxRight);
    }
}
```

```java
class Solution {
    public String longestPalindrome(String s) {
        /**
         * 我们用一个 boolean dp[l][r] 表示字符串从
         * i 到 j 这段是否为回文。试想如果 dp[l][r]=true
         * ，我们要判断 dp[l-1][r+1] 是否为回文。
         * 只需要判断字符串在(l-1)和（r+1)两个位置是否为
         * 相同的字符，是不是减少了很多重复计算。
         */
        if (s==null||s.length()<2) return s;
        int n = s.length();
        int maxStart=0,maxEnd=0,maxLen=1;
        boolean[][] dp = new boolean[n][n];
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < j; i++) {
                //遍历从i到j
                if (s.charAt(i)==s.charAt(j)&&(j-i<=2||dp[i+1][j-1])){
                    dp[i][j]=true;
                    //j-i<=2||dp[i+1][j-1] i和j之间的元素小于等于一个或者中间的为回文
                    if (j-i+1>maxLen){
                        maxStart=i;
                        maxEnd=j;
                        maxLen=j-i+1;
                    }
                }
            }
        }
        return s.substring(maxStart,maxEnd+1);
    }
}
```

```java
class Solution {
    public String longestPalindrome(String s) {
        //用动态规划的方法

        if (s.length()<2) return s;
        String ans= String.valueOf(s.charAt(0));
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i]=true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                char ci = s.charAt(i);
                char cj = s.charAt(j);
                if (i>j+1){
                    //间隔一个以上
                    dp[j][i]=(dp[j+1][i-1])&&(ci==cj);
                }else {
                    dp[j][i]=(ci==cj);
                }
                if (dp[j][i]){
                    if (ans.length()<(i-j+1)) ans = s.substring(j,i+1);
                }
            }
        }
        return ans;
    }
}
```

#### 动态规划法

注意循环♻️的顺序：！！！

```java
public String longestPalindrome(String s) {
        char[] sc = s.toCharArray();
        int n = s.length();
        if (n<2) return s;
        boolean[][] dp = new boolean[n][n];
        String ans = s.substring(0,1);
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (j-i<2){
                    dp[i][j]=(sc[i]==sc[j]);
                }else {
                    dp[i][j]=(sc[i]==sc[j])&&dp[i+1][j-1];
                }
              	
                if (dp[i][j]){
                    if (ans.length()<j-i+1){
                        ans = s.substring(i,j+1);
                    }
                }
            }
        }
        return ans;
    }
```

### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

> **回文子串是要连续的，回文子序列可不是连续的！** 回文子串，回文子序列都是动态规划经典题目。


给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

```
这里就是计算好删除那一个字符还是不删除那个字符。
在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。
如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;
```

如图：![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1631603904-bajQkL-file_1631603903949.jpeg#id=Cc94s&originHeight=514&originWidth=1058&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
如果这里看不懂，回忆一下dp[i][j]的定义
如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。
加入s[j]的回文子序列长度为dp[i + 1][j]。
加入s[i]的回文子序列长度为dp[i][j - 1]。
那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1631603904-sbMuFq-file_1631603903993.jpeg#id=xuzSW&originHeight=584&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
public int longestPalindromeSubseq(String s) {
    //最长的子序列
    int n = s.length();
    char[] sc = s.toCharArray();
    if (n<2) return n;
    int res = 0;
    int[][] dp = new int[n][n];
    for (int i = n-1; i >=0; i--) {
        dp[i][i]=1;
        for (int j = i+1; j <n; j++) {
            //  f[i][j]就是s[i+1]到s[j-1]的最长子序列长度
            // （就是f[i+1][j-1]） 加上s[i]和s[j]两个字符的长度。
            dp[i][j]=sc[i]==sc[j]?dp[i+1][j-1]+2:Math.max(dp[i+1][j],dp[i][j-1]);
            res = Math.max(res,dp[i][j]);
        }
    }
    return res;
}
```

如果是求最长回文子串：

```java
public String longestPalindrome(String s) {
  			//最长回文子串
        char[] sc = s.toCharArray();
        int n = s.length();
        if (n<2) return s;
        boolean[][] dp = new boolean[n][n];
        String ans = s.substring(0,1);
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (j-i<2){
                    dp[i][j]=(sc[i]==sc[j]);
                }else {
                    dp[i][j]=(sc[i]==sc[j])&&dp[i+1][j-1];
                }
                if (dp[i][j]){
                    if (ans.length()<j-i+1){
                        ans = s.substring(i,j+1);
                    }
                }
            }
        }
        return ans;
    }
```

### [剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/)

如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 _斐波那契式_ 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列 `arr` ，找到 `arr` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

_（回想一下，子序列是从原序列 _`_arr_`_ 中派生出来的，它从 _`_arr_`_ 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， _`_[3, 5, 8]_`_ 是 _`_[3, 4, 5, 6, 7, 8]_`_ 的一个子序列）_

```java
class Solution {
    public int lenLongestFibSubseq(int[] arr) {
        //每个斐波那契数列都可以由其最后两位数字精准定位
        int n = arr.length;
        int[][] dp = new int[n][n];
        // dp[2][3]表示数列[1,2,3]、dp[3][5]表示数列[1,2,3,5]、
        // dp[5][8]表示数列[1,2,3,5,8]
        //每个dp元素的值，代表它所定位的数列的长度，
        // 例如上面的 dp[2][3]=3 , dp[3][5]=4 , dp[5][8]=5；
        int max = 0;
        for (int i = 2; i < n; i++) {
            int j = 0, k = i-1;
            //j k 为双指针，
            while (j<k){
                if (arr[j] + arr[k] == arr[i]){
                    //找到
                    if (dp[j][k] == 0){//如果j和k，j之前的长度为0，
                        dp[k][i] = 3;//至少有三个元素了，k和i有3的长度
                        //两个前置元素j、k之前并没有形成斐波那契子数列（即dp[j][k]==0），
                        // 那就将当前位置存储的斐波那契数列长度dp[k][i]修改为3
                    }else {
                        //如果前置元素j、k之前作为某个斐波那契数列的最后两位元素存在
                        // （即dp[j][k]==n，n>=3）
                        dp[k][i] = Math.max(dp[j][k]+1,dp[k][i]);
                        //将当前位置存储的斐波那契数列长度dp[k][i]修改为 n+1 ，
                    }
                    max = Math.max(max,dp[k][i]);
                    j++;k--;
                }else if (arr[j] + arr[k] < arr[i]){
                    j++;
                }else
                    k--;
            }
        }
        return max;

    }
}
```

### [剑指 Offer II 092. 翻转字符](https://leetcode.cn/problems/cyJERH/)

如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是 **单调递增** 的。

我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 s，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。

返回使 s **单调递增** 的最小翻转次数。

**示例 1：**

```
输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.
```

```java
class Solution {
    public int minFlipsMonoIncr(String s) {
        if(s.length() < 2){
            return 0;
        } // 前一位反转成0的最小值和前一位反转成1的最小值
         int [][] dp = new int[s.length()][2];
        if (s.charAt(0)=='1'){
            dp[0][0] = 1;//第一个为1的话，他反转成零就需要变动一下，所以是一，
          		//但如果他反转成一的话，就不用动，所以就最小值变动次数为零
            dp[0][1] = 0;
        }else {
            dp[0][0] = 0;
            dp[0][1] = 1;
        }
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i)=='1'){
                dp[i][0] = dp[i-1][0]+1;//前一个是0的时候，就得多翻一个
                dp[i][1] = Math.min(dp[i-1][0],dp[i-1][1]);
            }else {
                //当前位置为0 的时候。如果前一个为0，那么就不需要变，
//                前一个为1，需要加一
                dp[i][0] = dp[i-1][0];
                dp[i][1] = Math.min(dp[i-1][1],dp[i-1][0])+1;
            }
        }
        return Math.min(dp[s.length()-1][0],dp[s.length()-1][1]);
    }
}
```

### [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2：**

```
输入：s = "aa", p = "*"
输出：true
解释：'*' 可以匹配任意字符串。
```

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        s = " "+s;//char数组就是从1开始的了
        p = " "+p;
        char[] chars = s.toCharArray();
        char[] charp = p.toCharArray();
        //动态规划，dp(i,j)就是1到i的字符和p的1到j的字符是否匹配
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0]=true;
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (charp[j]=='*'){
                    //如果p的此处为*，那么
                    dp[i][j] = dp[i][j-1] || (i-1>=0 && dp[i-1][j]);
                    //此时dp[i][j] 可以是由 dp[i][j-1]匹配传递来 或者(i-1>=0 && dp[i-1][j]);
                    
                }else {
                    dp[i][j] = i-1>=0 
                        && dp[i-1][j-1] && (chars[i]==charp[j] 
                                            || charp[j]=='?');
                // ? 匹配的条件是前面的字符匹配，s 中的第 i 个字符可以是任意字符。
                //   匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。
                }
            }
        }
        return dp[m][n];
    }
}
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， _请返回将 _`_word1_`_ 转换成 _`_word2_`_ 所使用的最少操作数_ 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```java
class Solution {
    public int minDistance(String word1, String word2) {
        //Dynamic Plan
        //二维数组，dp[i][j] 表示前i个word1转化成前j个word2的最少的操作数
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i <= n; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <=m ; i++) {
            for (int j = 1; j <= n; j++) {
                //开始比较了
                if (word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else {
                    //如果是删除i的话：dp[i][j] = dp[i-1][j]+1；
                  //这个增加其实就是两个单词反过来操作的结果，第一个单词增加一个元素变成第二个，
                  //实际上就是第二个元素删除一个元素变成第一个，他们两个的操作步骤次数是一样的。
                    //如果是增加的话：dp[i][j] = dp[i][j-1]+1；
                    //如果是替换那就是dp[i][j] = dp[i-1][j-1]+1;
                    dp[i][j] = Math.min( dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
                }
            }
        }
        return dp[m][n];
    }
}
```

### 718. 最长重复子数组

[力扣题目链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入：

- A: [1,2,3,2,1]
- B: [3,2,1,4,7]
- 输出：3
- 解释：长度最长的公共子数组是 [3, 2, 1] 。

提示：

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**思路**

注意题目中说的子数组，其实就是连续子序列。

要求两个数组中最长重复子数组，如果是暴力的解法 只需要先两层for循环确定两个数组起始位置，然后再来一个循环可以是for或者while，来从两个起始位置开始比较，取得重复子数组的长度。

本题其实是动规解决的经典题目，我们只要想到 **用二维数组可以记录两个字符串的所有比较情况，**这样就比较好推 递推公式了。
动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]` ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。  （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

此时细心的同学应该发现，那`dp[0][0]`是什么含义呢？总不能是以下标-1为结尾的A数组吧。

其实`dp[i][j]` 的定义也就决定着，我们在遍历`dp[i][j]` 的时候i 和 j都要从1开始。

那有同学问了，我就定义`dp[i][j]` 为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？

行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分，在本题解下面的拓展内容里，我给出了 第二种 dp数组的定义方式所对应的代码和讲解，大家比较一下就了解了。

2. 确定递推公式

根据`dp[i][j]` 的定义，`dp[i][j]` 的状态只能由dp[i - 1][j - 1]推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j]`  = dp[i - 1][j - 1] + 1;

根据递推公式可以看出，遍历i 和 j 要从1开始！

3. dp数组如何初始化

根据`dp[i][j]` 的定义，dp[i][0] 和`dp[0][j]`其实都是没有意义的！

但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式`dp[i][j]`  = dp[i - 1][j - 1] + 1;

所以dp[i][0] 和dp[0][j]初始化为0。

举个例子A[0]如果和B[0]相同的话，dp[1][1] = dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。

4. 确定遍历顺序

外层for循环遍历A，内层for循环遍历B。

那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？

也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。

同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]` 的最大值记录下来。

代码如下：

```cpp
for (int i = 1; i <= nums1.size(); i++) {
    for (int j = 1; j <= nums2.size(); j++) {
        if (nums1[i - 1] == nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        if (dp[i][j] > result) result = dp[i][j];
    }
}
```

5. 举例推导dp数组

拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg#id=ctN0m&originHeight=748&originWidth=914&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```cpp
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[][] dp = new int[n1 + 1][n2 + 1];//dp存储相同的长度
        //以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
        int count = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <=nums2.length ; j++) {
                if (nums1[i-1]==nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                if (dp[i][j]>count) count = dp[i][j];
            }
        }
        return count;
    }
}
```

- 时间复杂度：O(n × m)，n 为A长度，m为B长度
- 空间复杂度：O(n × m)

打家劫舍：

### 198.打家劫舍

[力扣题目链接](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

- 示例 1：
- 输入：[1,2,3,1]
- 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

- 示例 2：
- 输入：[2,7,9,3,1]
- 输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

提示：

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 400

决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

```java
class Solution {
    public int rob(int[] nums) {
        //打家劫舍
        //dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        int[] dp = new int[nums.length];
        if (nums.length==1) return nums[0];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
}
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

**动态规划**
s 串能否分解为单词表的单词（前 s.length 个字符的 s 串能否分解为单词表单词）
将大问题分解为规模小一点的子问题：
前`i`个字符的子串，能否分解成单词
剩余子串，是否为单个单词。
`dp[i]`：长度为i的`s[0:i-1]`子串是否能拆分成单词。题目求:`dp[s.length]`

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/70b0957d0086f43cd56b9e311e03deed4e9a77be0ae40ccbaa2f2b006d7caeb5-image.png#id=tmoZw&originHeight=557&originWidth=2017&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**状态转移方程**
类似的，我们用指针 `j` 去划分`s[0:i]` 子串如下图：
`s[0:i]` 子串对应 `dp[i+1]` ，它是否为 true（`s[0:i]`能否 break），取决于两点：
它的前缀子串 `s[0:j-1]` 的 `dp[j]`，是否为 true。
剩余子串 `s[j:i]`，是否是单词表的单词。

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/bcef185f09c72fb525855bd56155f4658793d86b0dc4f3de31cace6bd9398c5b-image.png#id=pTJZe&originHeight=550&originWidth=1170&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**base case**
base case 为`dp[0] = true`。即，长度为 0 的`s[0:-1]`**能**拆分成单词表单词。
这看似荒谬，但这只是为了让边界情况也能套用状态转移方程，而已。
当 j = 0 时（上图黄色前缀串为空串），`s[0:i]`的`dp[i+1]`，取决于`s[0:-1]`的`dp[0]`，和，剩余子串`s[0:i]`是否是单个单词。
只有让`dp[0]`为真，`dp[i+1]`才会只取决于`s[0:i]`是否为单个单词，才能用上这个状态转移方程。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        //dp[i]：长度为i的s[0:i-1]子串是否能拆分成单词。
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0]=true;
        for (int i = 1; i < n + 1; i++) {
            for (int j = i-1; j >=0; j--) {
                String suffix = s.substring(j, i);//后缀部分
                if (wordDict.contains(suffix)&&dp[j]){
                    dp[i]=true;
                    break;//如果找到了就退出
                }
            }
        }
        return dp[n];
    }
}
```

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) LIS

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

-  **状态定义：** 
-  
   - _dp_[_i_] 的值代表 nums 以 _nums_[_i_] 结尾的最长子序列长度。
-  **转移方程：** 设 _j_∈[0,_i_)，考虑每轮计算新 _dp_[_i_] 时，遍历 [0,_i_) 列表区间，做以下判断： 
-  
   - **当** _nums_[_i_]>_nums_[_j_] **时：** _nums_[_i_] 可以接在 _nums_[_j_] 之后（此题要求严格递增），此情况下最长上升子序列长度为 _dp_[_j_]+1 ；
   - **当** _nums_[_i_]<=_nums_[_j_] **时：** _nums_[_i_] 无法接在 _nums_[_j_] 之后，此情况上升子序列不成立，跳过。
   - 上述所有 **1.** **情况** 下计算出的 _dp_[_j_]+1 的最大值，为直到 _i_ 的最长上升子序列长度（即 _dp_[_i_] ）。实现方式为遍历 _j_ 时，每轮执行 _dp_[_i_]=_max_(_dp_[_i_],_dp_[_j_]+1)。
   - **转移方程：** dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。
-  **初始状态：** 
-  
   - _dp_[_i_] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
-  **返回值：** 
-  
   - 返回 _dp_ 列表最大值，即可得到全局最长上升子序列长度。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length==0) return 0;
        int[] dp = new int[nums.length + 1];
        Arrays.fill(dp,1);//每一个都是自己给自己递增的都是 1
        int maxSize=0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                //遍历从0到i，如果有nums[j]<nums[i]
                //dp[i]=math.max(dp[i]+dp[j]+1);
                //也就是上一个的dp[j]加上当前位置，这就是地推
                if (nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            maxSize=Math.max(maxSize,dp[i]);
        }
        return maxSize;
    }
}
```



### [1143. 最长公共子序列 LCS](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```



![CleanShot 2024-07-01 at 22.14.13@2x](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/CleanShot%202024-07-01%20at%2022.14.13@2x.png)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        if (m==0||n==0) return 0;
        int ans = 0;
        int[][] dp = new int[m+1][n+1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (text1.charAt(i)==text2.charAt(j)){
                    //如果当前位置相等的话，就选择
                    //dp[i+1][j+1]=Math.max(dp[i+1][j+1],dp[i][j]+1);
                    dp[i+1][j+1]=dp[i][j]+1;
                }else {
                    dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]);
                    //dp[i+1][j+1] = Math.max(dp[i+1][j+1],Math.max(dp[i][j+1],dp[i+1][j]));
                }
            }
        }
        return dp[m][n];
    }
}
```

怎么优化成一个一维的数组呢？其实是这个DP都是根据左边，左上，上面，得到的。

| `dp[i-1][j-1]` | `dp[i][j-1]` |
| -------------- | ------------ |
| `dp[i-1][j]`   | `dp[i][j]`   |



### HJ.24 合唱团

题目描述
计算最少出列多少位同学，使得剩下的同学排成合唱队形

说明：

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1Ti+1>......>TK。
你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

其实就是最长子序列的变形题

1. 对于题目，所有人都已经站好位，不能再改变位置了，只能从当中去掉人组成合唱队。同时，可以考虑中间的人两边没有人的情况（比如两头的两个人，或者这个人太矮周围的人都比他高的情况），但是这种情况基本被pass掉。
2. 计算出每个人左边能出现的最多的人数：
比如题中所给出的示例：186 186 150 200 160 130 197 200。首先如果第一个数186在中间，左边没有数，就自己一个人，所以是1；第二个数186因为左边那个人跟他一边高，没有比他矮的了，所以也是1；第三个数150，左边的人都比他高，他如果是中间的话左边也他自己一个人，所以还是1；第四个数200，因为不能换位置，所以只能留186或者150，加上自己，就是2...最后再以197为例，左边保留150,160是左边人最多的情况，再加上自己，就是3。所以每个人左边人最多的情况（加上自己）就是（186）1 1 1 2 2 1 3 4（200）。
3. 同理，看一下每个人右边可能出现最多的人，这时我们从后往前看。200在最右面，所以自己一个人，是1；197最右面没有比他矮的，自己，是1...160左边一个比他矮的，所以算上自己是2，以此类推。所以每个人右边人做多的情况（加上自己）就是（186）3 3 2 3 2 1 1 1（200）
4. 所以将上面两个划横线的对应相加，就可以得到自己如果是中间的那个人，可以得到的最大的合唱队人数。当然，自己加了两遍，所以得减掉一个自己。另外题目问的是最少去掉的人，所以最后的结果：
总人数 - 该数所在队列人数 = 需要出队的人数

[Ref](https://www.nowcoder.com/share/jump/1509878261713947848753)

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int n = in.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = in.nextInt();
            }
            int[]  left = new int[n];
            int[]  right = new int[n];
            left[0]=1;
            right[n-1] = 1;
            for (int i = 0; i < n; i++) {
                left[i]=1;
                for (int j = 0; j < i; j++) {
                    if (arr[i]>arr[j]) {
                        //如果左边有一个比当前的小的，那么就直接动态规划
                        left[i]=Math.max(left[j]+1, left[i]);
                        //这里不能是left[i]++;
                        //因为不是所有你比他大你就可以直接说递增的，这里是递增的。
                    }
                }
            }
            for (int i = n-1; i >=0; i--) {
                right[i] = 1;
                for (int j = n-1; j > i; j--) {
                    if (arr[i]>arr[j]) {
                        right[i] = Math.max(right[i],right[j]+1);
                    }
                }
            }
            int max = 1;
            int[] res = new int[n];
            for (int i = 0; i < n; i++) {
                res[i] = left[i]+right[i]-1;
                max = Math.max(max, res[i]);
            }
            System.out.println(n-max);
        }
    }
}
```

### [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

**示例 1：**

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**示例 2：**

```
输入：triangle = [[-10]]
输出：-10
```

**提示：**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

状态定义：`dp[i][j]`表示包含第i行第j列元素的最小路径和

状态分析

1. 初始化：
`dp[0][0]=triangle[0][0]`
2. 常规：
`triangle[i][j]`一定会**经过**`triangle[i-1][j]`或者`triangle[i-1][j-1]`,
所以状态`dp[i][j]`一定等于`dp[i-1][j]`或者`dp[i-1][j-1]`的最小值+`triangle[i][j]`
3. 特殊：
`triangle[i][0]`没有左上角 只能从`triangle[i-1][j]`经过
`triangle[i][row[0].length]`没有上面 只能从`triangle[i-1][j-1]`经过

转换方程：`dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]`

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        //dp[i][j]表示i和j位置的最小的路径之和
        int size = triangle.size();
        int[][] dp = new int[size + 1][size + 1];
        dp[0][0]=triangle.get(0).get(0);
//        if (size==1) return dp[0][0];
        for (int i = 1; i < size; i++) {
            for (int j = 0; j <= i; j++) {
                if (j==0){
                    // triangle[i][0]没有左上角
                    dp[i][0]=dp[i-1][0]+triangle.get(i).get(0);
                } else if (j == i) {
                    //triangle[i][row[0].length]没有上面
                    dp[i][i]=dp[i-1][i-1]+triangle.get(i).get(i);
                }else {
                    //dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]
                    dp[i][j]=Math.min(dp[i-1][j],dp[i-1][j-1])+triangle.get(i).get(j);
                }
            }
        }
        int minPath = Integer.MAX_VALUE;
        for (int i = 0; i < size; i++) {
            minPath=Math.min(minPath,dp[size-1][i]);
        }
        return minPath;
    }
}
```

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg#id=b1GB5&originHeight=322&originWidth=404&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

理解 min(上, 左, 左上) + 1

如题，在其他动态规划方法的题解中，大都会涉及到下列形式的代码：

- []

```java
// 伪代码
if (matrix(i - 1, j - 1) == '1') {
    dp(i, j) = min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1;
}
```

其中，`dp(i, j)` 是以 `matrix(i - 1, j - 1)` 为 **右下角** 的正方形的最大边长。(感谢 @liweiwei1419 提出补充)
等同于：`dp(i + 1, j + 1)` 是以 `matrix(i, j)` 为右下角的正方形的最大边长

翻译成中文

> 若某格子值为 `1`，则以此为**右下角**的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格。


先来阐述简单共识

- 若形成正方形（非单 `1`），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 `1`
- 可以换个角度：当前格、上、左、左上都不能受 `0` 的限制，才能成为正方形

![](https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png#id=hoiy7&originHeight=238&originWidth=728&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

上面详解了 三者取最小 的含义：

- 图 1：受限于左上的 0
- 图 2：受限于上边的 0
- 图 3：受限于左边的 0
- 数字表示：以此为正方形右下角的最大边长
- 黄色表示：格子 `?` 作为右下角的正方形区域

就像 [**木桶的短板理论**](https://baike.baidu.com/item/%E7%9F%AD%E6%9D%BF%E7%90%86%E8%AE%BA) 那样——附近的最小边长，才与 `?` 的最长边长有关。
此时已可得到递推公式

- []

```java
// 伪代码
if (grid[i - 1][j - 1] == '1') {
    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
}
```

从感性理解，到代码实现

-  从上述图解中，我们似乎得到的只是「动态规划 **推进** 的过程」，即「如何从前面的 `dp` 推出后面的 `dp`」，甚至还只是感性理解 
-  距离代码我们还缺：`dp` 具体定义如何，数组多大，初值如何，如何与题目要求的面积相关 
-  `dp` 具体定义：`dp[i + 1][j + 1]` 表示 「以第 `i` 行、第 `j` 列为右下角的正方形的最大边长」 
-  为何不是 `dp[i][j]` 
-  回到图解中，任何一个正方形，我们都「依赖」**当前格** 左、上、左上三个方格的情况 
-  但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 `if` 判断来处理 
-  为了代码简洁，我们 **假设补充** 了多一行全 `'0'`、多一列全 `'0'` 
-  ![](https://pic.leetcode-cn.com/035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png#id=JOFO6&originHeight=226&originWidth=266&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
-  此时 `dp` 数组的大小也明确为 `new dp[height + 1][width + 1]` 
-  初始值就是将第一列 `dp[row][0]` 、第一行 `dp[0][col]` 都赋为 `0`，相当于已经计算了所有的第一行、第一列的 `dp` 值 
-  题目要求面积。根据 「面积 = 边长 x 边长」可知，我们只需求出最大边长
  即可 
   - 定义 `maxSide` 表示最长边长，每次得出一个 `dp`，就 `maxSide = max(maxSide, dp);`
   - 最终返回 `return maxSide * maxSide;`

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix==null||matrix.length<1||matrix[0].length<1) return 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m + 1][n + 1];
        int maxSize = 0;
        //dp就是木桶效应，选择左边，左上，和上边三个最小的那个再加上1，
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j]=='1'){
                    dp[i+1][j+1]=Math.min(Math.min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1;
                    maxSize=Math.max(maxSize,dp[i+1][j+1]);
                }
            }
        }
        return maxSize*maxSize;
    }
}
```

### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        //得买两笔，不能同时买
        int[][] dp = new int[prices.length][5];
        //初始化dp
        dp[0][0]=0;//不操作;
        dp[0][1]=-prices[0];//第一次持有;
        dp[0][2]=0;//第一次卖出;
        dp[0][3]=-prices[0];//第二次买入
        dp[0][4]=0;//第二次卖出;
        for (int i = 1; i < prices.length; i++) {
            dp[i][1]=Math.max(dp[i-1][1],dp[i][0]-prices[i]);//不持有到持有
            dp[i][2]=Math.max(dp[i-1][2],dp[i][1]+prices[i]);//
            dp[i][3]=Math.max(dp[i-1][3],dp[i][2]-prices[i]);//
            dp[i][4]=Math.max(dp[i-1][4],dp[i][3]+prices[i]);//
        }
        return dp[prices.length-1][4];
    }
}
```

### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        //k笔的话，就是2k大小的dp
        int[][] dp = new int[prices.length][2 * k + 1];
        for (int i = 0; i < (2 * k + 1); i++) {
            if (i%2==1){
                //奇数的话就等于price[0];
                dp[0][i]=-prices[0];
            }
        }
        for (int i = 1; i < prices.length; i++) {
            for (int j = 1; j < (2 * k + 1); j++) {
                if (j%2==1){
                    //奇数的话就是要持有;
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]-prices[i]);
                }else {
                    //偶数的话就是要卖;
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]+prices[i]);
                }
            }
        }
        return dp[prices.length-1][2 * k];
    }
}
```

## 背包算法![](https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f6c4.svg#height=18&id=HtUHN&originHeight=18&originWidth=18&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=18)

![](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/20210117171307407-20230310132423205.png#id=cB3tb&originHeight=718&originWidth=2074&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循**序一定是先遍历物品，再遍历背包容量。**

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**完全背包的模版**：

```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```

### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

问装满背包所有物品的最小个数：dp[j] =  min(dp[j - coins[i]] + 1, dp[j]);

### 遍历顺序

### 01背包

二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

一维dp数组01背包**只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历**。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

举例：

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if (sum%2==1) return false;
        int target = sum/2;
        //动态规划 1/背包问题，能不能找到target大小的元素
        // dp[i] = dp[i-nums[j]]
        boolean[] dp = new boolean[target + 1];
        //先遍历物品，再遍历背包，
        dp[0] = true;
        for (int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = dp[j]||dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}
}
```

#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

1. 确定dp数组以及下标的含义

**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。

可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。

相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”

2. 确定递推公式

01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

本题则是：**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。

大家可以再去看 dp[j]的含义。

最后dp[target]里是容量为target的背包所能背的最大重量。

那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。

那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        //粉碎石头，其实就是看两个能不能各分一半
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int target = sum/2; // if achieved target，then result is zero;
        //dp表示装满容量为i的背包所能装的最大的价值也就是重量；
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-2*dp[target];//taget容量的背包最多能装下的
        //一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
        //那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。
    }
}
```

> 本题其实和**[416. 分割等和子集]**几乎是一样的，只是最后对dp[target]的处理方式不同。
>  
> **_[416. 分割等和子集]_**相当于是求背包是否正好装满，而本题是求背包最多能装多少。


#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 01 背包，dp表示放到正数的一遍的方法，
        // p+d=s; p-d = t; p = s+t /2;
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        //如果二者相加小于0，显然是不行的
        if ((sum+target)%2==1 ||(sum+target)/2<0) return 0;
        int plus = (sum+target)/2;
        int[] dp = new int[plus + 1];
        dp[0] =1;
        //找到和为plus的树木有多少种，装满这个plus的背包
        for (int i = 0; i < nums.length; i++) {
            for (int j = plus; j >=nums[i] ; j--) {
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[plus];
    }
}
```

### 完全背包

纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是**纯完全背包**的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。也就是不同的排序都算做新的方法就是求排列数

相关题目如下：

#### [剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/)

给定一个由 **不同** 正整数组成的数组 `nums` ，和一个目标整数 `target` 。请从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```shell
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合
```

dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。

其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。

如果数组[0] ，target = 0，那么 bagSize =  (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。

所以本题我们应该初始化 dp[0] 为 1。

可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。

其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。

dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
//        背包问题，背包总的只能装target大小的东西
//        顺序可以作为不同的组合dp[j] +=dp[j-nums[i]];
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //完全背包（可以重复使用），求排列数（不同的排序都算方法）
        for (int i = 1; i <= target; i++) {
            // 先遍历背包，因为这个容器背包是1的时候，可以每一个nums都去遍历所以是组合
            // 如果先去遍历物品，也就是nums的时候，那不就是没有顺序l
            for (int j = 0; j < nums.length; j++) {
                if (nums[j]<=i){
                    dp[i] += dp[i-nums[j]];
                }
            }
        }
        return dp[target];

    }
}
```

#### [剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/)

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //无线硬币就是完全背包，组合数首先遍历物品，再遍历背包
        int[] dp = new int[amount + 1];
       //完全背包（可以重复使用），求组合（不同的排序不算方法）
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if(dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
                }//最小的数
            }
        }
        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```

## Kadane’s Algorithm / Kadene算法

计算机历史上有一个非常经典的问题叫做Maximum-Subarray-Problem， 求数组的最大子序列，要求该子序列和为最大值，子序列应当连续。

比如 [−2, 1, −3, 4, −1, 2, 1, −5, 4]， 最大应该子序列为 [4, −1, 2, 1]。

暴力的解法是算出所有的子序列，然后求和，该方法的时间复杂度为O(n^2).

Kadane’s Algorithm是求解该类问题的一个通法，原理是利用Dynamic Programming保存所有以i结尾的子序列的最大长度，dp公式为:

如果以i - 1为结尾的子序列最大值为负，那么不管怎么样，dp[i]就应该从头开始计数，因为前面的子序列已经不再有影响了(dp[i - 1] + nums[i]必然小于nums[i])

Leetcode里有两道经典的题目，用到了这个算法，分别为Leetcode53和Leetcode1186，Leetcode 53是这一算法的直接运用，代码如下：

```java
public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int res = dp[0];
    for(int i = 1; i < nums.length; i++){
      //如果前面的比0小，直接就不去取了
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        res = Math.max(dp[i], res);
    }
    return res;  
}
```

> LeetCode 1186
>  
> 给你一个整数数组，返回它的某个 **非空** 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。
>  
> 注意，删除一个元素后，子数组 **不能为空**。
>  
> **示例 1：**
>  

```shell
输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
```

Leetcode 1186是一个变式，基本思路不变，不过我们可以选择是否删除删除一个元素，显然，如果遇到负数，我们可以考虑将其删除，然后计算两头，对于第i个数字，如果它是负数，则计算**以i - 1为结尾的最大子序列**和以**i + 1为开头的最大子序列**，我们分别用dp1，dp2存储这两种状态，原理依旧是Kadane’s Algorithm。

> 从两头开始，分别算好，如果里面有负数，再去计算负数导致的可能存在的删除某个元素的情况。


```java
public int maximumSum(int[] arr) {
    int[] dp1 = new int[arr.length];
    int[] dp2 = new int[arr.length];
    dp1[0] = arr[0];
    int res = arr[0];
    for(int i = 1; i < arr.length; i++){
        dp1[i] = Math.max(dp1[i - 1], 0) + arr[i];
        res = Math.max(res,dp1[i]);
    }
    dp2[arr.length - 1] = arr[arr.length - 1];
    for(int i = arr.length - 2; i > -1; --i){
        dp2[i] = Math.max(dp2[i + 1], 0) + arr[i];
    }
    
    for(int i = 1; i < arr.length - 1; i++){
        if(arr[i] < 0)
            res = Math.max(dp1[i - 1] + dp2[i + 1], res);
    }

    return res;
}
```

> 我的：
>  

```java
class Solution {
    public int maximumSum(int[] arr) {
        int[] dp1 = new int[arr.length];//存储从头开始的连续最大和
        int[] dp2 = new int[arr.length];//存储从尾开始的连续最大和
        int max = arr[0];
        dp1[0]=arr[0];
        for (int i = 1; i < arr.length; i++) {
            dp1[i]=Math.max(dp1[i-1],0)+arr[i];
            max = Math.max(max,dp1[i]);
        }
        System.out.println("dp1 = " + Arrays.toString(dp1));
        dp2[arr.length-1]=arr[arr.length-1];//最后一个位置赋值
        for (int i = arr.length-2; i >0; i--) {
            dp2[i]=Math.max(dp2[i+1],0)+arr[i];
            max = Math.max(max,dp2[i]);
        }
        System.out.println("dp2 = " + Arrays.toString(dp2));
        for (int i = 1; i < arr.length-1; i++) {
            if (arr[i]<0){
                max=Math.max(dp1[i-1]+dp2[i+1],max);
            }
        }
        return max;
    }
}
```


## 滑动窗口

在 Java 中，可以通过双指针的方式来实现滑动窗口算法，这里给出一个示例代码：

```java
public int slidingWindow(int[] nums, int target) {
    int left = 0, right = 0;
    int sum = 0, minLen = Integer.MAX_VALUE;

    while (right < nums.length) {
        sum += nums[right];

        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }

        right++;
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```

以上代码实现了一个求取数组中最短连续子数组长度的问题，其时间复杂度为 ![](https://www.yuque.com/api/services/graph/generate_redirect/latex?O(n)#card=math&code=O%28n%29&id=hd7mM)，其中 `left` 和 `right` 分别代表滑动窗口的左右指针，`sum` 为滑动窗口中元素之和，`minLen` 为最短连续子数组的长度。

在双指针算法中，常常需要使用嵌套循环，其中外层循环为右指针移动，内层循环为左指针移动，直到找到符合要求的结果。在内循环中，要注意移动左指针时的细节处理，此外还需要注意边界条件控制。

### 双指针判断回文数

```java
boolean isPali(String s,int begin,int end) {
    for (int i = begin, j = end; i < j; i++, j--) {
        if (s.charAt(i)!=s.charAt(j))
            return false;
    }
    return true;
}
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长** **子串**的长度。

 **示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int max = 0;
        int j = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) {
                j = Math.max(j, map.get(c) + 1);//最重要的是max
            }
            map.put(c, i);
            max = Math.max(max, i-j+1);
        }
        return max;
    }
}

```



最开始我也是这么想的，直接左边i-dic[s[j]]就完事了，**直到我遇到了“abba”，问题出在当遍历到第二个“a”的时候，左指针根据b重复更新了，到那时第二个a找到第一个为左边的a，**左指针又跳回到左边的a上去了 所以更新左指针这一行i = max(dic[s[j]], i)中的max神来一笔，保证了左指针无论如何不会往左跳。



### 680. 验证回文串 II

**判断回文串时，允许删除 1 个字符。**

给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。

**示例 1:**

```
输入: s = "aba"
输出: true
```

也就是说，在双指针相向遍历时，当

s[left]\=s[right]

我们**有且仅有一次**跳过的机会：

- 可以跳过 left 指针指向的元素，继续 [left+1⟶,right⟵]；
- 也可以跳过 right 指针指向的元素，继续 [left⟶,right−1⟵]。

两种情况中，只要有一个判定被为回文串，那么 s 就是合法的回文串。

```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length()-1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }

        }
        return true;
    }
    boolean validSub(String s,int left,int right) {
        while (left<right){
            if (s.charAt(left)!=s.charAt(right))
                return false;
            left++;
            right--;
        }
        return true;
    }
}
```

> 缩短版:
>  

```java
class Solution {
    public boolean validPalindrome(String s) {
        int start = 0,end=s.length()-1;
        for(int i= start,j=end;i<j;i++,j--){
            if(s.charAt(i)!=s.charAt(j)) 
                return isPali(s,i,j-1)||isPali(s,i+1,j);
        }
        return true;
    }
    private boolean isPali(String s,int start,int end){
        for(int i= start,j=end;i<j;i++,j--){
            if(s.charAt(i)!=s.charAt(j)) return false;
        }
        return true;
    }
}
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你[** 原地**](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //返回不重复的部分的长度，就是可以把重复的放在最后
        int slow = 0;//最后返回这个就可以了
        int fast = 1;
        while (fast<nums.length){
            //fast在前面标记为可以交换的元素
            if (nums[slow] == nums[fast])
                fast++;
            else {//找到不一样的之后再进行slow前进
                slow++;
                nums[slow]=nums[fast];
                fast++;
            }
        }
        return slow+1;
    }
}
```

### 统计连续子数组个数

给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。

**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**示例 2:**

```
输入: nums = [1,2,3], k = 0
输出: 0
```

**提示:**

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`

注意：本题与主站 713 题相同：[https://leetcode-cn.com/problems/subarray-product-less-than-k/](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        //滑动窗口
        //使用一个变量 cur 记录当前窗口的乘积，使用两个变量 j 和 i 分别代表当前窗口的左右端点。
        int len = nums.length;
        int ans = 0;
        if (k<=1) return 0;
        for (int i = 0, j = 0, cur = 1; i < len; i++) {
            cur*=nums[i];
            // 当 cur>=k 时，我们考虑将左端点 j 右移，同时消除原来左端点元素 nums[j] 对 cur 的贡献，
            // 直到 cur>=k 不再满足，这样我们就可以得到每个右端点 nums[i] 的最远左端点 nums[j]
            while (cur>=k) cur/=nums[j++];
            ans+=i-j+1;
        }
        return ans;
        //请找出该数组内乘积小于 k 的连续的子数组的个数。
    }
}
```

### offer || 014 是否包含 `s1` 的某个变位词。

给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

**提示：**

- `1 <= s1.length, s2.length <= 104`
- `s1` 和 `s2` 仅包含小写字母

注意：本题与主站 567 题相同： [https://leetcode-cn.com/problems/permutation-in-string/](https://leetcode-cn.com/problems/permutation-in-string/)

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        int[] list1 = new int[26];
        int[] list2 = new int[26];
        if (l2<l1) return false;
        //// 同时填充两个字符表，其中alpha1填充完毕，alpha2只填充了前面一部分。
        for (int i = 0; i < l1; i++) {
            list1[s1.charAt(i)-'a']++;
            list2[s2.charAt(i)-'a']++;
        }
        if (Arrays.equals(list1,list2)) return true;
        for (int i = l1; i < l2; i++) {
            //窗口右边新来的加加
//            窗口左边要排除的渐渐
            list2[s2.charAt(i)-'a']++;
            list2[s2.charAt(i-l1)-'a']--;//注意这里，因为有i-li所以要额外写一个遍历
            // 判断当前状态下，s2窗口中的字符是否和s1的字符种类和数量都一致。
            // Arrays.equals() 是通过遍历判断的，自己些for也一样。
            if (Arrays.equals(list2,list1)) return true;
        }
        return false;
    }
}
```

### LCR 015.滑动窗口统计变位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。

**示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (p.length()>s.length()) return ans;
        int[] listp = new int[26];
        int[] lists = new int[26];
        for (int i = 0; i < p.length(); i++) {
            listp[p.charAt(i)-'a']++;
            lists[s.charAt(i)-'a']++;
        }

        if (Arrays.equals(listp,lists)) ans.add(0);
        for (int i = p.length(); i < s.length(); i++) {
            lists[s.charAt(i)-'a']++;
            lists[s.charAt(i-p.length())-'a']--;
            if (Arrays.equals(listp,lists)) ans.add(i-p.length()+1);
        }
        return ans;
    }
}
```





### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 

**子数组**

`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口
        int sum = 0;
        int left = 0;
        int ans = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum+=nums[right];
            while (left<nums.length&&sum-nums[left]>=target){
                sum-=nums[left];
                left++;
            }
            if (sum>=target){
                ans = Math.min(ans,right-left+1);
            }
        }
        return ans==Integer.MAX_VALUE?0:ans;
    }
}
```

### [2958. 最多 K 个重复元素的最长子数组](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/)

给你一个整数数组 `nums` 和一个整数 `k` 。

一个元素 `x` 在数组中的 **频率** 指的是它在数组中的出现次数。

如果一个数组中所有元素的频率都 **小于等于** `k` ，那么我们称这个数组是 **好** 数组。

请你返回 `nums` 中 **最长好** 子数组的长度。

**子数组** 指的是一个数组中一段连续非空的元素序列。

 

**示例 1：**

```
输入：nums = [1,2,3,1,2,3,1,2], k = 2
输出：6
解释：最长好子数组是 [1,2,3,1,2,3] ，值 1 ，2 和 3 在子数组中的频率都没有超过 k = 2 。[2,3,1,2,3,1] 和 [3,1,2,3,1,2] 也是好子数组。
最长好子数组的长度为 6 。
```

**示例 2：**

```
输入：nums = [1,2,1,2,1,2,1,2], k = 1
输出：2
解释：最长好子数组是 [1,2] ，值 1 和 2 在子数组中的频率都没有超过 k = 1 。[2,1] 也是好子数组。
最长好子数组的长度为 2 。
```



```java
class Solution {
    public int maxSubarrayLength(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int l = 0;
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            // 新加入元素 x=nums[right] 后，如果 x 的出现次数超过 k，
            // 则不断右移左指针 left，直到窗口内的 x 的出现次数等于 k 为止，
            // 然后用 right−left+1 更新答案的最大值。
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
            while (map.get(nums[i])>k){
                map.merge(nums[l], -1, Integer::sum);
                l++;//l右边移动
            }
            ans = Math.max(ans, i - l+1);
        }
        return ans;
    }
}
```



## 前缀和算法

### 和大于等于target的连续子数组 和下面一样的题

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int left = 0;
        int right = 1;
        int res = Integer.MAX_VALUE;
        while (right<=nums.length) {
            if (preSum[right]-preSum[left]>=target){
                res = Math.min(right-left,res);
                left++;
                right=left;
            }else
                right++;

        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= nums.length; i++) {
            // 前缀和数组下标 [0,i] 范围内找到满足「值小于等于 s−target」
            // 的最大下标，充当子数组左端点的前一个值。
            // 左边的范围小于等于，那么就是说preSum[i]-preSum[left]>=target
            int s = preSum[i],d = s-target;
            int left = 0, right = i;
            while (left<right){
                int mid = (left+right+1)>>1;
                if (preSum[mid]<=d) left=mid;//如果中间的前缀和小于需要的。
                else
                    right = mid -1;
            }
            if (preSum[right]<=d) res = Math.min(res,i-right);
        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```

### offer010. 和为k的子数组个数

给定一个整数数组和一个整数 `k` **，**请找到该数组中和为 `k` 的连续子数组的个数。

**示例 1：**

```
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
```

**示例 2：**

```
输入:nums = [1,2,3], k = 3
输出: 2
```

**提示:**

- `1 <= nums.length <= 2 * 104`

统计以每一个 nums[_i_] 为结尾，和为 _k_ 的子数组数量即是答案。

我们可以预处理前缀和数组 `sum`（前缀和数组下标默认从 1 开始），对于求解以某一个nums[_i_]  为结尾的，和为 _k_ 的子数组数量，本质上是求解在 [0,_i_] 中，`sum` 数组中有多少个值为 _sum_[_i_+1]−_k_ 的数，这可以在遍历过程中使用「哈希表」进行同步记录。

sum是从最左边到当i 的位置的，HashMap存储的是从前到后，的值，看图理解一下：

![](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/image-20240229103908505.png#id=G7niX&originHeight=289&originWidth=279&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length, ans = 0;
        int[] pre = new int[n+1];
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + nums[i];
        }
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        for (int i = 1; i <= n; i++) {
            int tmp = pre[i], d = tmp-k;//求解在 [0,i] 中，
            // pre 数组中有多少个值为 pre[i+1]−k 的数，
            ans+=map.getOrDefault(d,0);//看看有无目标的值
            map.put(tmp,map.getOrDefault(tmp,0)+1);
        }
        return ans;
    }
}
```

### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int len = nums.length;
        int ans = 0;
        int[] pre = new int[len + 1];
        HashMap<Integer, Integer> map = new HashMap<>();
        //「某个前缀和出现的最小下标」
        map.put(0,0);
        for (int i = 0; i < len; i++) {
            pre[i+1] = pre[i]+(nums[i]==0?-1:1);
            //将 nums[i] 为 0 的值当做 −1 处理。
        }
        for (int i = 1; i <= len; i++) {
            int t = pre[i];
            if (map.containsKey(t))
                // get(t)的目的是，是前缀和，所以找到相同的t的时候，
                // 区间之间长度就是0了
                ans = Math.max(ans,i-map.get(t));
//            每遍历一个元素，就用「当前前缀和」去前面已经统计的前缀和
//            中找到一个使得两者之间区间为0的，并计算这个区间长度
            else
                map.put(t,i);
        }
        return ans;
    }
}
```

### [304. 二维区域和检索 - 矩阵不可变-二维前缀和算法](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

二维前缀和算法

给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回左上角 `(row1, col1)` 、右下角 `(row2, col2)` 的子矩阵的元素总和。

![](https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png#id=gUKfy&originHeight=415&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
class NumMatrix {
    int[][] matrix = null;
    int[][] sum = null;
    public NumMatrix(int[][] matrix) {
        this.matrix=matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        sum=new int[m +1][n +1];
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j < n; j++) {
                sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+matrix[i][j];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row1][col2+1]-sum[row2+1][col1]+sum[row1][col1];
    }
}
```

## 算数运算

### 整数转罗马数字
关键是：遍历这个有序HashMap就可以了。

```java
class Solution {
    public String intToRoman(int num) {
        StringBuilder sb = new StringBuilder();
        HashMap<Integer, String> map = new LinkedHashMap<>(){{
            put(1000,"M");
            put(900,"CM");
            put(500,"D");
            put(400,"CD");
            put(100,"C");
            put(90,"XC");
            put(50,"L");
            put(40,"XL");
            put(10,"X");
            put(9,"IX");
            put(5,"V");
            put(4,"IV");
            put(1,"I");
        }};
        for (Integer i : map.keySet()) {
            while (num>=i){
                num-=i;
                sb.append(map.get(i));
            }
        }
        return sb.toString();
    }
}
```

罗马数转整数
```java
class Solution {
    public int romanToInt(String s) {
        //罗马数字转整数
        Map<Character,Integer> map=new HashMap<Character, Integer>(){{
            put('I',1);
            put('V', 5);
            put('X', 10);
            put('L', 50);
            put('C', 100);
            put('D', 500);
            put('M', 1000);
        }};
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            Integer val = map.get(s.charAt(i));
            if (i<n-1&&val<map.get(s.charAt(i+1))){
                ans-=val;
            }else {
                ans+=val;
            }
        }
        return ans;
    }
}
```
### 进位与非进位

设两数字的二进制形式 ,观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。

![](assets%5C56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png#id=Kx3bW&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```java
// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0 
//    1     1         0           1
// 
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
// 
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。

class Solution {
    public int add(int a, int b) {
        // a的二进制表示与b的二进制，
        // 每一位取异或运算，得到无进位和的结果，每一位取与运算，左移<<一位，得到进位，
        // 不用担心整数转二进制，因为他就是默认就是二进制存取的直接去&就可以了
        while(b!=0){
            int c = (a&b)<<1;//进位，左移一位
            a = a ^ b;//非进位和
            b=c;//当进位为0的时候就可以不需要进位，直接非进位和就可以了
        }
        return a;
    }
}
```

### 29.不用除法的除法：倍增求解

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。


我们先来看溢出问题，这个其实只要关注一项就可以了，即被除数为 Integer.MIN_VALUE 而除数为 -1 的情况，因为负数的最小值的绝对值比正数的最大值大 1，所以，直接取反是会溢出，这种情况特殊处理即可。
然后，针对不能不使用 long 的问题，我们可以把两个数都转换成负数来处理，原因同上，负数我们不能轻易转成正数来处理。
我们这里可以考虑使用【倍增乘法】来实现，所谓倍增乘法，简单理解就是每次用被除数减去[除数的最大的2_x_]，这样可以极大地增加处理的速度。
比如，假定被除数为 20，除数为 3，使用倍乘法的过程如下：

1. 计算 3 的 2_x_ 的最大值（不超过 20），为 3∗2^2=12，拿 20−12 得到 8，做为新的被除数。
2. 计算 3 的 2_x_ 的最大值（不超过 8），为 3∗21=6，拿 8−6 得到 2，做为新的被除数。
3. 判断新的被除数 2 小于 3 了，退出计算过程，最后的结果就是 22+21=6。

```java
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        //返回完异常值
        //倍增法，每次减去一个2^x倍
        boolean sign = false;
        if((dividend>0&&divisor>0)||(dividend<0&&divisor<0))
            sign = true;//正数标记
        dividend = dividend > 0? -dividend:dividend;
        divisor = divisor > 0? -divisor:divisor;
        int ans = 0;
        //dividend / divisor
        while(dividend<=divisor){
            int tmp = divisor,count =1;
            //tmp + tmp >= dividend
            while(tmp>=dividend-tmp){
                tmp+=tmp;
                count+=count;
            }
            dividend = dividend - tmp;
            ans = ans+count;
        }
        return sign?ans:-ans;
    }
}
```

### 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数

```
如果我们是使用「朴素解法」求解的话，无论是从高位进行统计，还是从低位进行统计，最后一位扫描的都是边缘的数（如果是 1 就计数，不是 1 就不计数）。

从低位到高位，最后一步在扫描最高位之前，统计出 1 的个数应该等同于将 i 左移一位，并在最低位补 0，也就是等于 ans[i << 1]，这时候就要求我们在计算 i 的时候 i << 1 已经被算出来（从大到小遍历）
从高位到低位，最后一步在扫描最低位之前，统计出 1 的个数应该等同于将 i 右移一位，并在最高位补 0，也就是等于 ans[i >> 1]，这时候就要求我们在计算 i 的时候 i >> 1 已经被算出来（从小到大遍历）
```

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for(int i=1;i<n+1;i++)
        //res[i] = 「i >> 1 所包含的 1 的个数」+「i 的最低位是否为 1」
            res[i] = res[i>>1] + (i&1);
        return res;
    }
}
```

### [剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,100]
输出：100
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

哈希表解法的空间复杂度是 _O_(_n_) 的，而题目的【进阶】部分提到应当使用常数空间来做。

其中一个比较容易想到的做法，是利用int类型固定为 32 位。

**使用一个长度为 32 的数组 cnt[] 记录下所有数值的每一位共出现了多少次 1，再对cnt[] 数组的每一位进行mod 3 操作，重新拼凑出只出现一次的数值。**

举个 🌰，考虑样例 `[1,1,1,3]`，1 和 3 对应的二进制表示分别是 `00..001` 和 `00..011`，存入 _c**n**t_[] 数组后得到 `[0,0,...,0,1,4]`。进行 _m**o**d_ 3 操作后得到 `[0,0,...,0,1,1]`，再转为十进制数字即可得「只出现一次」的答案 3。

```java
class Solution {
    public int singleNumber(int[] nums) {
//        出现了三次，那么取模3，应该就是等于0；
        int[] cnt = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                if(((num>>i) & 1)==1){
                    cnt[i]++;
//                    如果当前元素右移i个单位是1的话，就在cnt加加
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i]%3==1)
//                mod 3 之后，其实也不会出现2，因为mod 3 就是去掉了重复3次的，
                ans+=(1<<i);
        }
        return ans;
    }
}
```

### [剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/)-位运算

给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。

**示例 1:**

```
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
```

根据题意进行模拟即可，利用每个 *w**or**d**s**[_i_] 只有小写字母，且只需要区分两字符是否有字母重复。

我们可以使用一个 `int` 来代指某个 _w**or**d_[_i_]：低 26 来代指字母 `a-z` 是否出现过。

然后对每个「字符对」所对应的两个 `int` 值执行 `&` 操作（若两字符无重复字符，则结果为 0），并得出最终答案。

位运算：比较两个字符串不相同

```java
class Solution {
    public int maxProduct(String[] words) {
//        位运算，进行&操作，如果两个字符有重复的字符马，那么就是1，无重复的就是0
        int length = words.length;
        int idx = 0;
        int[] masks = new int[length];
        for (String word : words) {
            int t = 0;
            for (int i = 0; i < word.length(); i++) {
                int u = word.charAt(i)-'a';
                t |= (1<<u);
            }
//            对每一个word进行或运算，计算1左移u位的，
//            则 abc 可以表示为 111 def 可以表示为 111000
            masks[idx++] = t;
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < i; j++) {
//         // 如果两个字符串不包含相同元素 那么与运算肯定为 0
                if ((masks[i]&masks[j])==0)
                    ans = Math.max(ans, words[i].length() * words[j].length());
            }
        }
        return ans;
    }
}
```

### [剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/)

难度中等61收藏分享切换为英文接收动态反馈

给定一个只包含整数的有序数组 `nums` ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

**示例 1:**

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0;
        
        int right = nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]==nums[mid^1]){
                left = mid+1;
                //如果mid是奇数，那么异或1的结果是mid-1；所以就相当于是比较mid和mid-1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；

                 //如果mid是偶数，那么异或1的结果是mid+1；所以就相当于是比较mid和mid+1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；
            }else right = mid;
        }
        return nums[left];
    }
}
```

### [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        String res = "0";
        for (int i = num2.length()-1; i >=0 ; i--) {
            int carry = 0;//纪录进位
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < num2.length()-1-i; j++) {
                sb.append(0);//sb是逆序的，因此，假如说是第2个num2的数字，那就是sb代表的数字要进10。
            }
            int n2 = num2.charAt(i)-'0';
            //num2的第i位数字与num1想成
            for (int j = num1.length()-1; j >=0 || carry!=0; j--) {
                int n1 = j<0?0:num1.charAt(j)-'0';
                int product = (n1*n2+carry)%10;
                sb.append(product);
                carry = (n1*n2+carry)/10;
            }
            res = addStrings(res,sb.reverse().toString());
        }
        return res;
    }
    private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
    }
}
```

### 实现两个字符串相加

```java
private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
 }
```

### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

```java
class Solution {
    public double myPow(double x, int n) {
        //快速幂，二进制
        //x^9 = (x^1) * (x^0*2) * (x^0*4) * (x^1*8)
        //就是9的二进制 1 0 0 1 然后乘以对应的2^(i-1)
        if (x == 0.0f) return 0.0d;
        long b = n;
        double res = 1.0;
        if (b < 0) {
            x = 1/x;
            b = -b;
        }
        //x^n = (x^2) ^ (n/2),将指数n除以二，如果是偶数则正常，如果是奇数，由于是向下取整，所以后面多乘以x
        while (b > 0) {
            if ((b&1) == 1) res *= x; //对b取余数，b%2 = b&1;
            //当 n 为奇数时，二分后会多出一项 x 。所以要多乘一次x
            x *= x;//x的平方
            b>>=1;
        }
        return res;
    }
}
```

### 66.加一

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int len = digits.length;
        for (int i = len -1; i >= 0; i--) {
            digits[i]++;
            digits[i]%=10;
            if (digits[i]!=0)
                return digits;
        }
        digits = new int[len+1];
//        for (int digit : digits) {
//            System.out.println(digit);//其实此时所有位置都是零了
//        }
        digits[0] = 1;
        return digits;
    }
}ƒ
```

### 求解最大公约数GCD

在Java中，求两个数的最大公约数（Greatest Common Divisor, GCD）可以通过多种方法实现，最常用的是辗转相除法（也称为欧几里得算法）。这种方法基于一个定理：两个整数的最大公约数等于其中较小数和两数相除余数的最大公约数。下面是使用辗转相除法在Java中计算两个数最大公约数的示例代码：

```java
public class Main {
    public static void main(String[] args) {
        int num1 = 60;
        int num2 = 48;
        System.out.println("The GCD of " + num1 + " and " + num2 + " is: " + gcd(num1, num2));
    }

    // 使用辗转相除法求最大公约数
    public static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

## 二进制运算-^

### 位运算 [求只出现一次的两个元素](https://www.nowcoder.com/questionTerminal/389fc1c3d3be4479a154f63f495abff8)

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

数据范围：数组长度 2≤n≤10002\le n \le 10002≤n≤1000，数组中每个数的大小 0<val≤10000000 < val \le 10000000<val≤1000000
要求：空间复杂度 O(1)O(1)O(1)，时间复杂度 O(n)O(n)O(n)

![图片标题](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/53C41BB50881E6B82CA24E9B997CB268.png#id=BphHG&originHeight=490&originWidth=622&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE%E7%89%87%E6%A0%87%E9%A2%98 "图片标题")

如上面例子中的数组，我们每做一次异或运算，最后的1会被消去，只剩下4和6的异或结果xor。
然后我们再找这个xor的最后一个1的位置:xor-xor&(xor-1)
因为根据题目要求有两个数是不重复的，所以最后一个1的位置说明这两个数在这个位置上的二进制的数字是不同的，我们可以根据这个特性给它们分别存放在容量为2的数组的不同的位置中。得到最后的1这个数字之后，用这个数再次与整个数组进行异或运算，重复的数会被消去，只剩下那个唯一的值就是结果。下面给出完整代码:

分组的时候：

```java
// 找到那个可以充当分组去进行与运算的数
        // 从最低位开始找起
        int mask = 1;
        while((tmp&mask) == 0){
            mask <<= 1;
        }
```

这样的话也是可以直接找到最右边的位置的1的

```java
public int[] FindNumsAppearOnce (int[] nums) {
        int[] ans = new int[2];
        int mark = nums[0];
        for (int i = 1; i < nums.length; i++) {
            mark ^= nums[i];
        }
        mark -=mark&(mark-1);
        for(int i:nums){
            if((mark&i) == 0){
                ans[0] ^=i;
            }else{
                ans[1]^=i;
            }
        }
        if(ans[0] > ans[1]) {
            int temp = ans[0];
            ans[0] = ans[1];
            ans[1] = temp;
        }     
        return ans;
    }
```

### TSP旅行商算法

**描述**

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

**输入描述：**

城市个数n（1<n≤20，包括北京）

城市间的车票价钱 n行n列的矩阵` m[n][n]`

**输出描述：**

最小车费花销 s

**示例1**

输入：

```
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0
```

输出：

```
13
```

说明：

```
共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。
```

数字表示旅行商问题


![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/CleanShot%202024-04-13%20at%2020.29.15@2x.png#id=tmSif&originHeight=1258&originWidth=2636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

比如 [1,[]]表示就是从1到0的路费也就是 第一行的1到0的费用就是1.

[2,{1,3}]表示就是从2到经过1和3到0的费用就是2到1的费用加上[1,{3}]，与2到3的费用加上[3,{1}]的费用的最小值。

```
分析：
假设有0,1,2,3四个城市，起点不会影响结果，因此选城市0为起点，创建一个二维数组dp[][]，用二维数组元素的值代表最低花费，用行坐标代表起点城市，列坐标代表接下来要去的城市（注列坐标用二进制表示，如接下来去1,3城市，则使二进制数第一三位为1，即用101表示）。

因此以0为起点的最低花费可表示为dp[0][111];
以0为起点三种情况：
以0为起点，再进一步选定3为起点，最低花费可表示为cost[0][3]+dp[3][011];
以0为起点，再进一步选定2为起点，最低花费可表示为cost[0][2]+dp[2][101];
以0为起点，再进一步选定1为起点，最低花费可表示为cost[0][1]+dp[1][110];
取上面三个式子最小值，假设第一种最小，即cost[0][3]+dp[3][011]最小
以0为起点，再进一步选定3为起点两种情况：
以0为起点，再进一步选定3为起点，再进一步选定2为起点，最低花费可表示为cost[0][3]+cost[3][2]+dp[2][001];
以0为起点，再进一步选定3为起点，再进一步选定1为起点，最低花费可表示为cost[0][3]+cost[3][1]+dp[1][010];
取上面两个式子最小值，假设第一种最小，即cost[0][3]+cost[3][2]+dp[2][001]最小
最低花费可表示为cost[0][3]+cost[3][2]+cost[2][1]+dp[1][000]
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int n = in.nextInt();
            int[][] m = new int[n][n];
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    m[i][j]=in.nextInt();
                }
            }
            int min_cost = tsp(m,n);
            System.out.println(min_cost);
        }
    }
    public static int tsp(int[][] map,int N){
        //比说是4个城市，需要2^3 = 8 = 1000 j的坐标只能是 000,001,010,100,101,110,111 最多是7
        int[][] dp = new int[N][(int)Math.pow(2, N-1)];
        //旅行商问题，就是表示初始点到i位置，需要经过集合V的的可能性。
        //动态规划公式 d(i,V) 表示从顶点 i 出发经过 V(是一个点的集合)
        // 中各个顶点一次且仅一次，最后回到出发点 s 的最短路径长度。
        //根据上述给的测试用例有 4 个城市编号 0,1,2,3。那么访问 n 4 个城市
        //，恰好访问每个城市一次，并最终回到出发城市的嘴短距离可表示为
        // d(0,{1,2,3}), 
        //集合 {1,3} 表示为二进制为 101是从右边到左边 321
        for (int j = 0; j < dp[0].length; j++) {
            // 四个城市 0 1 2 3，
            //外层遍历：j = 000,001,010,100,101,110,111
            for (int i = 0; i < dp.length; i++) {
                //外层循环遍历所有可能的集合 V，内层循环遍历所有可能的终点城市 i。
                // 内层是：i=0 1 2 3,i = 0;
                dp[i][j]=Integer.MAX_VALUE;
                //如果当前状态 V 为空（即 j == 0），j=000,且当前城市不是起始城市，
                //则将 dp[i][j] 设置为从当前城市到起始城市的距离。
                if(j==0&&i!=0) dp[i][j]=map[i][0];
                //i!=0就是不是起始城市，j==0就是空集的时候，1，2，3城市初始化。
                //dp:
                // 0  000,001,010,100,101,110,111
                // 1 初始化
                // 2 初始化
                // 3 初始化
                else{
                    //1 << (i-1) 表示将从右边往左边数，从1开始，第 i 位设置为1，其他位都是0。
                    //对于 i = 3，1 << (i-1) 就是 100。j=1XX都直接跳过，不允许走
                    if((j&(1<<(i-1)))!=0) continue;//因为路径不允许经过自身城市。
                    //如果当前遍历的j的二进制数值《110》包含了自身的城市就直接跳过，只遍历正常的城市。
                    for(int k=1;k<N;k++){
                        if((j>>(k-1)&1)==1){//j右边移动就是遍历从右往左第k个元素，
                            //j=110 往右边移动k-1，比如k=2，移动1位为11，第一位就是1，等于1
                            //j=110，就是经过了2和3城市，当前城市位k=2城市
                            int lastState = j^(1<<(k-1));//110 ^ 10 = 100 
                            //将状态 j 中对应 k 的二进制位取反，从而移除了城市 k 的状态
                            //获得上一个状态的dp[k][lastState]
                            dp[i][j]=Math.min(dp[i][j], map[i][k]+dp[k][lastState]);
                            //当前最大值和上一个状态加上当前城市i到k的距离，选一个最大的。
                            
                            //比如 j=001，也就是集合是第一个城市，那么i=2开始了
                            //那就是只有k=1才能和1与操作等于1，就是第一个城市，就是2要经过1，1回到0，
                            //dp[2][001] = Math.min(map[2][1]+dp[1][000])
                            
                            //比如 j=011，也就是集合是{1,2}城市，i=3开始了
                            //那就是有k=1,k=2,才能和1与操作等于1，就是3要经过{1,2}回到0，
                            //dp[3][011] = Math.min(dp[3][011],dp[1][010]+map[3][1]);
                            //也就是3->1->2->0的花费，也就是dp[1][010]就是1到2到0的花费加上map[3][1]，
                            //3到1的花费之和。
                            
                        }
                    }
                }
            }
            
        }
        ////就是返回dp[0][111];length是8，减去一就是111
        //就是返回dp[0][1111];length是16 10000，减去一就是1111
        return dp[0][dp[0].length-1];//dp[0][15];15 = 1111
    }
}
```

当我们在动态规划解决旅行商问题时，我们需要定义状态以及状态之间的转移关系。在这段代码中，`dp[i][j]` 表示从起始城市到达城市 `i` 并经过集合 `V` 中的每个点（集合 `V` 用二进制位表示）只经过一次的最短路径长度。

让我们用一个简单的例子来说明这个概念。假设我们有四个城市（0，1，2，3），其中城市0是起始城市。我们用一个二维数组 `map` 来表示城市之间的距离。例如，`map[1][2]` 表示从城市1到城市2的距离。

```
城市之间的距离：
  0  1  2  3
0 0  10 15 20
1 10 0  35 25
2 15 35 0  30
3 20 25 30 0
```

在这个例子中，我们需要计算 `dp` 数组。`dp[i][j]` 表示从城市0出发，经过集合 `V` 中的城市到达城市 `i` 的最短路径长度。在这里，集合 `V` 是用二进制位表示的。例如，如果 `V` 为 1100，表示路径经过城市1和城市2，不经过城市0和城市3。

我们来具体看看 `dp[2][6]` 的含义：

- `dp[2][6],dp[2][110]` 表示从城市0出发，经过集合 `{1,2}` 中的每个点到达城市2的最短路径长度。
- 集合 `{1,2}` 用二进制位表示为 110，其中第一位表示是否经过城市1，第二位表示是否经过城市2。
- 因此，`dp[2][6]` 表示从城市0出发，经过城市1和城市2，到达城市2的最短路径长度。

在这个例子中，我们可以计算 `dp` 数组的其他值，以获得从起始城市出发，经过所有城市一次后回到起始城市的最短路径长度。

`if( (j & 1<<(i-1)) !=0 ) continue;` 这行代码的作用是检查当前状态 `j` 是否包含当前城市 `i`。

让我们通过一个例子来解释这行代码：

假设 `i = 3`，表示当前考虑的城市是第三个城市，即城市编号从1开始。假设 `j = 5`，表示当前的状态 `j` 用二进制表示为 `101`，即表示路径经过第一和第三个城市，而不经过第二个城市。

现在，我们想要检查当前状态 `j` 是否包含城市 `i`，即第三个城市。我们可以通过按位与运算来实现。按位与运算可以用来检查某一位是否为1。

1. 首先，我们需要将第 `i` 个城市对应的二进制位置为1，其他位置为0，这样我们可以用它来与 `j` 进行按位与运算。 
   - `1 << (i-1)` 表示将第 `i` 位设置为1，其他位都是0。对于 `i = 3`，`1 << (i-1)` 就是 `100`。
2. 然后，我们将这个二进制数与 `j` 进行按位与运算，如果结果不为0，则表示当前状态 `j` 中包含城市 `i`。 
   - `j & (1 << (i-1))`，在我们的例子中，就是 `101 & 100`，结果是 `100`，不为0。

因此，如果 `j` 中包含城市 `i`**，即 `(j & (1 << (i-1))) != 0` 成立，那么 `continue` 语句会跳过当前循环，不进行后续的计算，因为路径不允许经过自身城市。**

```cmd
array1 = [INF, 4, 12, 12, 10, 11, 13, 13]
array2 = [2, INF, 10, INF, 9, INF, 11, INF]
array3 = [6, 6, INF, INF, 7, 8, INF, INF]
array4 = [5, 6, 8, 8, INF, INF, INF, INF]
```

