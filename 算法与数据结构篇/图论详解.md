# 图论基础知识、常用算法与LeetCode题解

## 基本概念

**图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

使用 `G(V, E)` 表示一个图，V为顶点(Vertex)，E为边(Edge)。图中**不允许没有顶点**，但是可以没有边。

### 有限图与无限图

**有限图**：V, E 都是有限集合。

**无限图**：V 或 E 是无限集合。

### 有向图与无向图

**无向图 (Undirected graph)**：每个边都是无向边。

```
e = (u, v)
```

- e：**无向边 (Undirected edge)**，简称 **边 (Edge)**
- u, v：e的 **端点 (Endpoint)**

**有向图 (Directed graph)**：每个边都是有向边。

```
e = u -> v
```

- e：**有向边 (Directed edge)** ，简称**弧 (Arc)** 或 **边 (Edge)**
- u：e 的 **起点 (Tail)**
- v：e 的 **终点 (Head)**
- u, v：e的 **端点 (Endpoint)**
- u 是 v 的**直接前驱**，v 是 u 的**直接后继**

> 为什么起点是 Tail，终点是 Head？
> 有向边通常用箭头表示，而箭头是从“尾”指向“头”的。

**混合图 (Mixed graph)**：既有有向边，又有无向边。

### 相邻

**关联（Incident)**：顶点 v 是边 e 的一个端点，则称 e 和 v 关联 或 相邻。

**邻接 / 相邻（Adjacent）**：顶点u和v，若存在边 `(u，v)`，则称u和v是邻接或相邻的。

**邻域 (Neighborhood)** ：

- 顶点 v：所有与顶点 v 相邻的顶点集合，记作 `N(v)`。
- 点集 S：与 S 中至少一个点相邻的顶点集合，记作 `N(S)` ，`N(S) = ∪ N(v), v∈S`

### 度

**度（degree）**：顶点相邻边的数目，常用 `deg(V)`, `d(v)` 表示。

- 孤立点 (Isolated vertex) ： `d(v) == 0`
- 叶节点 (Leaf vertex) / 悬挂点 (Pendant vertex) ： `d(v) == 1`
- 偶点 (Even vertex) ： `d(v) % 2 == 0`
- 奇点 (Odd vertex) ：`d(v) % 2 == 1`。奇点的个数是偶数。
- 支配点 (Universal vertex) ：`d(v) = V - 1`，和所有其他点都相邻。

有向图中：

- **入度 (In-degree)**：以该顶点为终点的边的数目，常用 `d+(v)` 表示。
- **出度 (Out-degree)**：以该顶点为起点的边的数目，常用 `d-(v)` 表示。
- 顶点的度 = 入度 + 出度，即 `d(v) = d+(v) + d-(v)`。

### 自环与重边

- 自环 (Loop) ：边 e 的两个端点相同，则 e 称为一个自环。
- 重边 (Multiple edge) ：两个完全相同的边，称作（一组）重边。在无向图中 `(u,v)` 和`(v,u)` 算一组重边，而在有向图中，`u -> v` 和 `v -> u` 不为重边。

### 简单图与多重图

- 简单图 (Simple graph) ：没有自环和重边。非空简单图中一定存在度相同的结点。
- 多重图 (Multigraph) ：有自环或重边 。

### 路径

**途径 (Walk) / 链 (Chain)**：`v0, e1, v1, e2, ... ek, vk`，或简写为 `v0 → v1 → ... → vk`

**迹 (Trail)** ：链，且所有边都不同。

**路径（Path）/ 简单路径 (Simple path)**：迹，且所有点都不同（除了允许 `v0 == vk`）。

**回路 (Circuit)** ：迹，且 `v0 == vk`。

**环 / 圈 (Cycle) / 简单回路 / 简单环 (Simple circuit)**：简单路径，且 `v0 == vk`。

### 连通

无向图

- **连通的 (Connected)** ：从顶点 u 有路径到达 v ，则 `u,v` 是连通的。
- **连通图 (Connected graph)**：任意两点连通。
- **连通分量 / 极大连通子图 (Connected component)**：H是G的连通子图，且不存在连通图F，使得 `H ⊊ F ⊆ G`，则H是G的连通分量。

性质：

- 连通图只有一个连通分量，即图自身。
- 非连通图有多个连通分量。

有向图

- **可达**：从顶点 u 有路径到达 v ，则 u 可达 v。
- **强连通的 (Strongly connected)**：有向图中，所有节点互相可达。
- **弱连通的 (Weakly connected)**：有向图中，边替换为无向边后可以得到连通图（也就是有些节点只能单向可达）。
- **弱连通分量 / 极大弱连通子图 (Weakly connected component)** ， **强连通分量 / 极大强连通子图 (Strongly Connected component)**：与连通分量类似。

### 稀疏图与稠密图

稀疏图 (Sparse graph)：边数远小于点数的平方。

稠密图 (Dense graph) ：边数接近点数的平方。

### 特殊的图

**树 (Tree)** ：不含环的无向连通图。

**森林 (Forest)**：多棵树可以组成一个 森林。

**二分图 (Bipartite graph)**：图的点集分为两部分，每一部分的内部都没有连边（或者说所有边的两个点刚好分别在两部分中）。

**完全二分图 (Complete bipartite graph/Biclique)**：任何两个不在同一部分的点之间都有连边（例如两部分分别有 `x,y` 个点，则图总共有`x*y`个边）。

# 🌟图的表示

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/0.jpg)

### Java代码展示图

参考：

https://labuladong.online/algo/data-structure/graph-traverse/#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86



```java
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

和我们之前说的多叉树节点几乎完全一样：

```java
class TreeNode {
    int val;
    TreeNode[] children;
}
```

图真的没啥高深的，本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。

不过呢，上面的这种实现是**「逻辑上的」，实际上我们很少用这个 `Vertex` 类实现图，而是用常说的邻接表和邻接矩阵来实现。**

```java
List<Integer>[] graph;
boolean[][] matrix;
```

### 邻接表 Adjacency Table

使用一个支持动态增加元素的数据结构构成的数组，例如Java中的 `List[] adj`。

- **领接表**中 `adj[u]` 存储的是点 u 所有出边的信息（终点、边权等）。
- **逆邻接表**中 `adj[u]` 存储的是点 u 所有入边的信息（起点、边权等）。

邻接表很直观，我把每个节点 x 的邻居都存到一个列表里，然后把 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。

### 邻接矩阵 Adjacency Matrix

二维数组 `adj[][]`，`adj[u][v]` 为 1 表示存在 u 到 v 的边，为 0 表示不存在。

如果是带边权的图，可以在 `adj[u][v]` 中存储 u 到 v 的边的边权。

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2.jpeg)

### 邻接矩阵\邻接表区别

邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。
但是，邻接表无法快速判断两个节点是否相邻。
比如说我想判断节点 1 是否和节点 3 相邻，我要去邻接表里 1 对应的邻居列表里查找 3 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3] `就知道了，效率高。
所以说，使用哪一种方式实现图，要看具体情况。

邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。

### 图论的度

最后，我们再明确一个图论中特有的度（degree）的概念，在无向图中，「度」就是每个节点相连的边的条数。
由于有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree），比如下图：

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657368-60303c3a-360f-45f7-9e60-98b32887cb36.jpeg)

其中节点 3 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。
好了，对于「图」这种数据结构，能看懂上面这些就绰绰够用了。
那你可能会问，我们上面说的这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……

如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，不就实现加权有向图了吗？
如果是邻接矩阵，`matrix[x][y] `不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

```java
List<int[]>[] graph;
int[][] matrix;
```

可以参考 207.课程表

```java
class Solution {
    boolean hasCycle = false;
    boolean[] onPath;
    boolean[] visited;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        int[] inDegrees = new int[numCourses];//入度表法
        for (int i = 0; i < prerequisites.length; i++) {
            int from = prerequisites[i][1];
            int to = prerequisites[i][0];
            graph[from].add(to);//graph[s] 是一个列表，存储着节点 s 所指向的节点。
            inDegrees[to]++;
        }
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                queue.push(i);
            }
        }
        while (!queue.isEmpty()){
            Integer pop = queue.pop();
            numCourses--;
            for (Integer i : graph[pop]) {
                inDegrees[i]--;
                if (inDegrees[i]==0) queue.push(i);
            }
        }
        return numCourses==0;
    }

}
```



### 图的遍历-DFS图

- 深度优先搜索 (Depth-First Search, DFS)

![深度优先搜索](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/dfs.png)

多叉树的遍历：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    
    for (TreeNode child : root.children) {
        traverse(child);
    }
    
}
```

图和多叉树最大的区别是，**图是可能包含环的**，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。
所以，如果图包含环，**遍历框架就要一个 visited 数组进行辅助**：

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径
boolean[] onPath;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

注意 visited 数组和 onPath 数组的区别，因为二叉树算是特殊的图，所以用遍历二叉树的过程来理解下这两个数组的区别：

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657880-80ddf295-ecfc-4d18-a7e7-b861bcc244da.gif)

上述 GIF 描述了递归遍历二叉树的过程，在 visited 中被标记为 true 的节点用灰色表示，在 onPath 中被标记为 true 的节点用绿色表示，类比贪吃蛇游戏，visited 记录蛇经过过的格子，而 onPath 仅仅记录蛇身。在图的遍历过程中，onPath 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景，这下你可以理解它们二者的区别了吧。

如果让你处理路径相关的问题，这个 onPath 变量是肯定会被用到的，比如 [拓扑排序](https://labuladong.online/algo/data-structure/topological-sort/) 中就有运用。
 onPath 数组的操作做「做选择」和「撤销选择」，区别在于位置：**回溯算法的「做选择」和「撤销选择」在 for 循环里面**，DFS**对 onPath 数组的操作在 for 循环外面。**
为什么有这个区别呢？回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝。

```java
// DFS 算法，关注点在节点
void traverse(TreeNode root) {
    if (root == null) return;
    printf("进入节点 %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("离开节点 %s", root);
}

// 回溯算法，关注点在树枝
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // 做选择
        printf("从 %s 到 %s", root, child);
        backtrack(child);
        // 撤销选择
        printf("从 %s 到 %s", child, root);
    }
}
```

所以对于这里「图」的遍历，我们应该用 DFS 算法，即把 `onPath` 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。



- 广度优先搜索 (Breadth-First Search, BFS)

![广度优先搜索](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/bfs.png)



## 图的遍历问题

### 797.所有可能路径

题目输入一幅**有向无环图**，这个图包含 `n` 个节点，标号为 `0, 1, 2,..., n - 1`，请你计算所有从节点 `0` 到节点 `n - 1` 的路径。

输入的这个 `graph` 其实就是「邻接表」表示的一幅图，`graph[i]` 存储这节点 `i` 的所有邻居节点。

比如输入 `graph = [[1,2],[3],[3],[]]`，就代表下面这幅图：

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1.jpg)

算法应该返回 `[[0,1,3],[0,2,3]]`，即 `0` 到 `3` 的所有路径。

**解法很简单，以 `0` 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可**。

既然输入的图是无环的，我们就不需要 `visited` 数组辅助了，直接套用图的遍历框架：

```java
class Solution {
    // 记录所有路径
    List<List<Integer>> res = new LinkedList<>();
        
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // 维护递归过程中经过的路径
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* 图的遍历框架 */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
        // 添加节点 s 到路径
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // 到达终点
            res.add(new LinkedList<>(path));
            // 可以在这直接 return，但要 removeLast 正确维护 path
            // path.removeLast();
            // return;
            // 不 return 也可以，因为图中不包含环，不会出现无限递归
        }

        // 递归每个相邻节点
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
        
        // 从路径移出节点 s
        path.removeLast();
    }
}

```

简洁版：

```java
class Solution {
    List<List<Integer>> ans = new LinkedList<>();
    List<Integer> path = new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        dfs(graph,0);
        return ans;
    }
    void dfs(int[][] graph,int s){
        path.addLast(s);
        if (s==graph.length-1){
            ans.add(new LinkedList<>(path));
        }
        for (int i : graph[s]) {
            dfs(graph,i);
        }
        path.removeLast();
    }
}
```



## 环检测算法问题

### 207. 课程表

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

首先我们要把题目的输入转化成一幅有向图，然后再判断图中是否存在环。

如何转换成图呢？我们前文 [图论基础](https://labuladong.github.io/article/fname.html?fname=图) 写过图的两种存储形式，邻接矩阵和邻接表。

以我刷题的经验，常见的存储方式是使用邻接表，比如下面这种结构：

```java
List<Integer>[] graph;
```

**`graph[s]` 是一个列表，存储着节点 `s` 所指向的节点**。

所以我们首先可以写一个建图函数：

```java
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // 图中共有 numCourses 个节点
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 添加一条从 from 指向 to 的有向边
        // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
        graph[from].add(to);
    }
    return graph;
}
```

图建出来了，怎么判断图中有没有环呢？

> tip：类比贪吃蛇游戏，`visited` 记录蛇经过过的格子，而 `onPath` 仅仅记录蛇身。`onPath` 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景。

这样，就可以在遍历图的过程中顺便判断是否存在环了，完整代码如下：

```java
class Solution {
    // 记录一次递归堆栈中的节点
    boolean[] onPath;
    // 记录遍历过的节点，防止走回头路
    boolean[] visited;
    // 记录图中是否有环
    boolean hasCycle = false;

    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }
        // 只要没有循环依赖可以完成所有课程
        return !hasCycle;
    }

    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 出现环
            hasCycle = true;
        }
        
        if (visited[s] || hasCycle) {
            // 如果已经找到了环，也不用再遍历了
            return;
        }
        // 前序代码位置
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序代码位置
        onPath[s] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 图中共有 numCourses 个节点
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }
        return graph;
    }
}
```



附：207. 临街表计算入度法：

```java
class Solution {
    boolean hasCycle = false;
    boolean[] onPath;
    boolean[] visited;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        int[] inDegrees = new int[numCourses];//入度表法
        for (int i = 0; i < prerequisites.length; i++) {
            int from = prerequisites[i][1];
            int to = prerequisites[i][0];
            graph[from].add(to);//graph[s] 是一个列表，存储着节点 s 所指向的节点。
            inDegrees[to]++;
        }
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                queue.push(i);
            }
        }
        while (!queue.isEmpty()){
            Integer pop = queue.pop();
            numCourses--;
            for (Integer i : graph[pop]) {
                inDegrees[i]--;
                if (inDegrees[i]==0) queue.push(i);
            }
        }
        return numCourses==0;
    }

}
```





## 拓扑排序问题（有向无环图、AOV网）

**有向无环图，Directed Acyclic Graph，DAG**

**拓扑排序，Topological sorting**

**AOV网（Activity On Vertex Network)**：将一个工程分为多个小的**活动（Activity)**，在**有向无环图**中，用顶点表示活动，用弧（有向边）表示活动的先后关系，简称为AOV网。

性质：

- 能 拓扑排序 的图，一定是有向无环图
- 有向无环图，一定能拓扑排序

注意：

- B依赖A，一般在图中表示为有向边 `A -> B` ，也就是先完成A，后完成B。

### LeetCode 210. 课程表 II

[210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 n 门课 `0 ~ n-1`。想要学习课程 0，要先完成课程 1，用 `[0,1]` 表示。给定课程总量以及它们的先决条件，返回学完所有课程的顺序（返回一种即可），如果不可能完成所有课程，返回空数组。

这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。

函数签名如下：

```java
int[] findOrder(int numCourses, int[][] prerequisites);
```

这里我先说一下拓扑排序（Topological Sorting）这个名词，网上搜出来的定义很数学，这里干脆用百度百科的一幅图来让你直观地感受下：

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/top.jpg)

> note：图片中拓扑排序的结果有误，`C7->C8->C6` 应该改为 `C6->C7->C8`。

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的**，比如上图所有箭头都是朝右的。

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。

但是我们这道题和拓扑排序有什么关系呢？

**其实也不难看出来，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序**。



#### 代码

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
```

### 深度优先算法 DFS

#### 流程

- 从每个**未访问**的节点开始深度优先遍历。
- 访问完一个节点的所有后继节点后，将该节点添加到栈中（类似树的**后序遍历**）。
- 最后将栈反转即可得到结果。

#### 代码

DFS实现如下，其中：

- `graph` 为邻接表。
- `globalVisited` 用于标记所有访问过的节点，已经访问过的不再重复访问。
- `localVisited` 用于标记本轮DFS访问过的节点，如果某一轮DFS重复访问到了某个节点，说明图中有环。

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
```

## 最短路径问题

对于边权为正的图，任意两个结点之间的最短路：

- 不会经过重复的结点。
- 不会经过重复的边。
- 结点数不超过 n ，边数不会超过 n - 1。

**单源最短路**：指定源点，求它到其余各个结点的最短路。

### LeetCode 743. 网络延迟时间

[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

有 N 个网络节点 `1 ~ N`。给定列表 times，表示信号经过有向边的传递时间。 `times[i] = (u, v, w)`，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。

从节点 K 发送信号，多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。

### 深度优先算法 DFS

流程：

- 使用数组保存到达每个节点的最小耗时。初始化时节点 K 耗时为0，其他节点均为 `-1`，表示未访问。
- 从节点 K 开始深度优先搜索。每当遇到一个节点，且节点**未访问** 或 **新的时间小于节点保存的时间**，就更新这个节点的时间（一方面不需要更新为更大的时间，另一方面避免遇到环，导致死循环）。
- 遍历节点时间数组，如果仍有未访问的节点，说明从节点 K 到该节点不可达，返回 `-1`；否则返回数组中的最大值。

使用DFS解题（489 ms），性能很差。

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // time[i]: node [i] receive time
        int[] time = new int[N+1];
        Arrays.fill(time, -1);
        time[K] = 0;

        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] t : times) {
            int from = t[0], to = t[1], w = t[2];
            graph[from].add(new int[]{to, w});
        }

        dfs(graph, time, K);

        int max = -1;
        for (int i = 1; i <= N; ++i) {
            if (time[i] == -1) return -1;
            max = Math.max(max, time[i]);
        }
        return max;
    }

    public void dfs(List<int[]>[] graph, int[] time, int node) {
        for (int[] t : graph[node]) {
            int to = t[0], w = t[1];
            int newTime = time[node] + w;
            if (time[to] != -1 && newTime >= time[to]) {
                continue;
            }
            time[to] = newTime;
            dfs(graph, time, to);
        }
    }
}
```

### 弗洛伊德算法 Floyd-Warshall Algorithm

特点：

- 可以求任意两个结点之间的最短路。
- 复杂度较高，但容易实现。
- 适用于任何图，不管有向无向，边权正负，但是最短路必须存在（不能有个负环）。

思路：

- 使用矩阵表示节点 `u → v` 之间的最短路径。
- 初始化时，`w[i][i]` 为0， `w[i][j]` 为边 `i → j` 的权重，没有边的元素设置为无穷大。
- 节点 `i → j` 可能通过 `k` 中转而缩短距离，遍历计算点 `i → k → j` 的路径，如果比现有的 `i → j` 小，则更新，即**松弛**操作。

复杂度：

- 时间复杂度 `O( N^3 )`
- 空间复杂度 `O( N^2 )`

使用Floyd算法求解（18ms）。

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
```

### 迪杰斯特拉算法 Dijkstra Algorithm

特点：

- 求单源最短路径。
- 只适用于非负权图。
- 时间复杂度优秀。
- 使用了贪心思想。

步骤：

- 初始：
  - 已确定最短路的节点为集合P，未确定最短路的节点为集合Q。
  - 保存源节点 K 到每个节点的距离，初始化时距离为无穷大。
  - 将源节点 K 放入Q，其距离为0。
- 循环：
  - 从Q取出一个距离最短的节点 u，其最短路径已经确定，因此移到P（贪心思想，因为 K 到其他点的距离更远，不可能找到一个经过其他点再到 u 的更短路径）。
  - 松弛 u 的**未确定最短路的**出节点，即判断经过 u 能否缩短距离。将这些节点放到Q中等待下一轮循环处理。
  - 继续循环，直到Q为空。

具体实现：

1. 可以用 int 数组保存每个节点的距离，boolean 数组表示节点是否已经加入到P。
2. 优化：Java中使用 `PriorityQueue` 实现Q，这样每次取出距离最短节点时性能更好。

图解1，来自 [维基百科](https://zh.wikipedia.org/wiki/戴克斯特拉算法)：

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/Dijkstra_Animation.gif)

图解2，来自 [博客](https://www.cnblogs.com/thousfeet/p/9229395.html)：

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dijkstra.jpg)

图解2的执行步骤分析：

```
第一行为节点，第二行为距离，.表示无穷大∞，加中括号表示已经确定最短路径

 1    2    3    4    5    6
 0    ·    ·    ·    ·    ·
 ↑                             选1，松弛2、3

 1    2    3    4    5    6
[0]   1   12    ·    ·    ·
      ↑                        选2，松弛3、4

 1    2    3    4    5    6
[0]  [1]  10    4    ·    ·
                ↑              选4，松弛3、5、6...
```

使用Dijkstra算法求解（24 ms）：

```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
```

## 并查集 Disjoint Set Union

### 故事：

> 几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。
>
> 为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。

初始化

```java
int[] parent = new int[n];

void init() {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}
```

查找

```java
int findRoot(int x) {
    int x_root = parent[x];
    while (x_root != x) {
        x_root = parent[x_root];
    }
    return x_root;
}
```



路径压缩

查找过程中，同时把每个节点都直接连接到根上。这样可以大大提高效率。

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2005461-20210107163928771-776073883.jpg)

```java
// 迭代写法
int findRoot(int x) {
    while (parent[x] != x) {
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}

// 递归写法
int findRoot(int x) {
  if (x != parent[x])
    parent[x] = find(parent, parent[x]);
  return parent[x];
}
```

合并

> 宴会上，一个家族的祖先突然对另一个家族说：我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。由于并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。

```
boolean union(int x, int y) {
    // x 与 y 所在家族合并
    x = find(x);
    y = find(y);
    if (x == y) {  // 原本就在一个家族里就不管了
        return false;
    }
    parent[x] = y;  // 把 x 的祖先变成 y 的祖先的儿子
    return true;
}
```

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2005461-20210107163946024-115247088.jpg)

启发式合并（按秩合并）

> 一个祖先突然抖了个机灵：“你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。”

路径压缩有时不适用，可以用启发式合并。

```
int[] rank = new int[n]; // initial value: 0

boolean union(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        return false;
    }
    if (rank[x] > rank[y]) {
        parent[x] = y;
    } else if (rank[x] < rank[y]) {
        parent[y] = x;
    } else {
        parent[x] = y;
        rank[y]++;
    }
    return true;
}
```



### 一、动态联通

简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639614-1cd699eb-a256-4785-b7f5-fc8115fe3052.jpeg)

现在我们的 Union-Find 算法主要需要实现这两个 API：  

```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}
```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

**1、自反性**：节点`p`和`p`是连通的。

**2、对称性**：如果节点`p`和`q`连通，那么`q`和`p`也连通。

**3、传递性**：如果节点`p`和`q`连通，`q`和`r`连通，那么`p`和`r`也连通。

比如说之前那幅图，0～9 任意两个**不同**的点都不连通，调用`connected`都会返回 false，连通分量为 10 个，实际就是小单元

如果现在调用`union(0, 1)`，那么 0 和 1 被连通，连通分量降为 9 个。

再调用`union(1, 2)`，这时 0,1,2 都被连通，调用`connected(0, 2)`也会返回 true，连通分量变为 8 个。

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639676-f84b04f7-4572-407e-99a5-971ffd0281dc.jpeg)

判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。  

这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于`union`和`connected`函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？

### 二、基本思路

注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。

怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。

比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：

```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    /* 其他函数 */
}
```

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639709-811dfdba-1506-43d2-84ab-13c48e4cebd6.jpeg)

**如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上**：

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
```

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801639805-15a93d4e-0189-4162-b0bc-5cb08739ddbc.jpeg)

**这样，如果节点**`**p**`**和**`**q**`**连通的话，它们一定拥有相同的根节点**：

```
public boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
```

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801639809-7ffa38e0-2d31-4915-9eef-59d713d9c0bf.jpeg)

至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！

那么这个算法的复杂度是多少呢？我们发现，主要 API`connected`和`union`中的复杂度都是`find`函数造成的，所以说它们的复杂度和`find`一样。

`find`主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是`logN`，但这并不一定。`**logN**`**的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成**`**N**`**。**

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801640025-d750ad3d-7d8b-4514-b50c-afcf42e6e63f.jpeg)

所以说上面这种解法，`find`,`union`,`connected`的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于`union`和`connected`的调用非常频繁，每次调用需要线性时间完全不可忍受。  

**问题的关键在于，如何想办法避免树的不平衡呢**？只需要略施小计即可。

### 三、平衡性优化

我们要知道哪种情况下可能出现不平衡现象，关键在于`union`过程：

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也可以
    count--;
```

我们一开始就是简单粗暴的把`p`所在的树接到`q`所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801640258-4621ac7e-a6dd-454d-9926-570f768dced0.jpeg)

长此以往，树可能生长得很不平衡。**我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些**。==解决方法是额外使用一个`size`数组，记录每棵树包含的节点数，我们不妨称为「重量」：==  

```java
class UF {
    private int count;
    private int[] parent;
    // 新增一个数组记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        // 最初每棵树只有一个节点
        // 重量应该初始化 1
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    /* 其他函数 */
}
```

比如说`size[3] = 5`表示，以节点`3`为根的那棵树，总共有`5`个节点。这样我们可以修改一下`union`方法：

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;

    // 小树接到大树下面，较平衡
    if (size[rootP] > size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ];
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    count--;
}
```

这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在`logN`这个数量级，极大提升执行效率。

此时，`find`,`union`,`connected`的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。

### 四、路径压缩

这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801640148-7476d66f-b8c8-458c-aa60-d586822e8160.jpeg)

这样`find`就能以 O(1) 的时间找到某一节点的根节点，相应的，`connected`和`union`复杂度都下降为 O(1)。  

要做到这一点，非常简单，只需要在`find`中加一行代码：

```java
private int find(int x) {
    while (parent[x] != x) {
        // 进行路径压缩
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}
```

这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：



![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801640694-22b2a899-9b94-451a-8dc4-b2618f3551cf.gif)

可见，调用`find`函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（`union`的时候树高可能达到 3）。

PS：读者可能会问，这个 GIF 图的`find`过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次`find`都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。

### 五、最后总结

我们先来看一下完整代码：

```java
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
}
```

Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；**连通两个节点`union`、判断两个节点的连通性`connected`、计算连通分量`count`所需的时间复杂度均为 O(1)。**

#### 并查集应用

- **求连通分量**：依次对每个边的两个顶点进行并查集合并，可以使得每个连通分量的root相同，从而得出每个连通分量。
- **查找环**：合并过程中，如果发现一条边的两个顶点已经合并过，说明这两个顶点之前已经通过其他路径合并，再加上这条边，图中就出现了环。
- **求最小生成树**：贪心思想，从小到大排序所有边，使用并查集依次合并，并跳过形成环的边，即可得到最小生成树。

### LeetCode 684. 冗余连接

[684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

树可以看成是一个连通且 **无环** 的 **无向** 图。（关键是这一句，剩余部分钥匙联通没有环的）

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626676174-hOEVUL-image.png)

```
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
```

**示例 2：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626676179-kGxcmu-image.png)

```
输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
```



分析

- 依次对每个边的两个顶点进行并查集合并。
- 当遇到一个边的两个顶点已经合并过，发现了环，返回这条边。
- 输出参数只有 `edges` 而没有N。对于有 `N` 个节点的树，应该有 `N-1` 条边，再加上附加的一条边，得到N条边。因此 `edges` 的size即为N。



代码

```java
class Solution {

    int[] parent;

    public int[] findRedundantConnection(int[][] edges) {
        // N = edges.length
        parent = new int[edges.length + 1];
        for (int i = 0; i < parent.length; ++i) {
            parent[i] = i;
        }
      // 2. 遍历二维数组的顶点对
        for (int[] edge : edges) {
          // 如果能加入到并查集返回true，否则返回false
            if (!union(edge[0], edge[1])) {
                return edge;
            }
        }
        return new int[]{-1,-1};
    }

    public int findRoot(int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int x, int y) {
        x = findRoot(x);
        y = findRoot(y);
        if (x == y) {
            return false;
        }
        parent[x] = y;
        return true;
    }
}
```



标准答案：

```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        UF uf = new UF(edges.length + 1);
        for (int[] edge : edges) {
            if (!uf.union(edge[0],edge[1])){
                return edge;
            }
        }
        return new int[]{-1,-1};
    }
    class UF{
        int count;//联通量
        int[] parent;
        // 记录树的“重量”
        private int[] size;
        UF(int n){
            parent = new int[n];
            size = new int[n];
            this.count = n;
            for (int i = 0; i < n; i++) {
                parent[i]=i;//初始化自己的祖先为自己
                size[i]=1;
            }
        }
        boolean union(int p,int q){
            int rootP = find(p);
            int rootQ = find(q);
            if (rootQ==rootP) return false;
            if (size[rootP]>size[rootQ]){
                parent[rootQ]=rootP;
                size[rootP]+=size[rootQ];
                // 小树接到大树下面，较平衡
            }else {
                parent[rootP]=rootQ;
                size[rootQ]+=size[rootP];
            }
            count--;
            return true;
        }
        int find(int p){
            //查找祖先
            while (p!=parent[p]){
                parent[p]=parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
    }
}
```





## 最小生成树

**最小生成树（Minimum Spanning Tree，MST）**：无向连通图中边权和最小的生成树（最短路径连接所有节点）。

注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/mst.jpg)

### LeetCode 1135. 最低成本联通所有城市

[1135. 最低成本联通所有城市](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/)

- 地图上有 N 座城市 `1 ~ N`。
- 给出一些 `conections`，其中 `conections[i] = [city1, city2, cost]` 表示将城市 `city1` 和城市 `city2` 连接所要的成本，连接是双向的。
- 返回连接所有城市的最小成本，如果无法连接所有城市，返回 `-1`。

### Kruskal算法

Kruskal算法 = 贪心 + 并查集

流程：将所有边按cost从小到大排序，然后使用并查集依次尝试合并每个边：

- 如果合并成功，则加入这条边。
- 如果合并失败（边的两个节点已经合并过），说明产生了环，则丢弃这条边。

通过并查集合并后，每个连通分量节点都会有相同的root，因此检查所有节点的root：

- 如果检查到只有一个root，说明这个图只有一个连通分量，是连通图，返回cost。
- 如果检查到超过一个root，说明这个图有多个连通分量，不是一个连通图，返回-1。

```
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
```

### Prim算法

Kruskal算法每次添加一个最小的边，而Prim算法则是每次添加一个距离已选取节点集最近的点。

流程：

1. 集合S表示已选取的节点集。
2. 选任意一个节点作为起始节点 `a`，放到集合S中，并更新其他节点到集合S的最近距离。因为当前S中只有一个节点 `a`，因此更新为到节点 `a` 的距离。
3. 选取距离S最近的一个节点 `b`，放到集合S中，并更新其他节点到集合S的最近距离。也就是节点 `i` 的距离更新为 `min { adj[a][i], adj[b][i] }`。
4. 继续选取、更新，直到N个节点都被选取。

实际提交发现，Prim算法效果远不如Kruskal好。

- 题目给的是边（connections），而使用Prim算法，需要快速得到两个节点之间的距离。如果每次都直接遍历connections，复杂度太高，因此需要先转换成邻接矩阵或邻接表。选择合适的邻接矩阵或邻接表，是解决本题的一个关键。
- 另外一个关键点就是，获取距离最小的节点，可以直接遍历，也可以借助 `PriorityQueue` 实现。

#### 解法1：超出内存限制

最基础的Prim算法实现，使用二维数组保存邻接矩阵，暴力搜索查找距离最小的节点。

代码应该是正确的，在简单的测试用例中运行是正确的。但是由于邻接矩阵太大，导致超出了内存限制，提交未通过。

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
```

#### 解法2：超出时间限制

优化Prim算法，使用HashMap数组保存领接表，借助PriorityQueue选取距离最小的节点。

超出时间限制。

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph[i].get(j):
        //     x: distance
        //     null: not reachable
        Map<Integer, Integer>[] graph = new HashMap[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new HashMap<>();
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u].put(v, w);
            graph[v].put(u, w);
        }

        // heap: candidates
        //     int[0]: distance from added nodes
        //     int[1]: node
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[0] - b[0]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{0, 1});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int dist = min[0];
            int node = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            for (int i = 2; i <= N; ++i) {
                if (added[i]) continue;
                Integer d = graph[node].get(i);
                if (d != null) { // d == null: not reachable
                    heap.offer(new int[]{d, i});
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[1];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

#### 解法3：通过，67 ms

正在怀疑是不是自己写错了Prim算法的时候，借鉴了评论区的思路，重新优化了邻接表的表示方法，使用 `HashMap -> List -> int[]` 的形式。

这样在更新距离时，不需要再进行复杂的遍历，也不需要创建很多数组（HashMap邻接表和PriorityQueue中的元素格式是相同的，都是 `[node, distance]`），大大提高了性能。

终于提交通过，耗时67ms。作为对比，Kruskal算法的耗时是27ms，且写起来更容易。

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph.get(i).get(x):
        //     int[0]: node
        //     int[1]: distance from [i] to [node]
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            List<int[]> list1 = graph.get(u);
            if (list1 == null) {
                list1 = new LinkedList<>();
                graph.put(u, list1);
            }
            list1.add(new int[]{v,w});

            List<int[]> list2 = graph.get(v);
            if (list2 == null) {
                list2 = new LinkedList<>();
                graph.put(v, list2);
            }
            list2.add(new int[]{u,w});
        }

        // heap: candidates
        //     int[0]: node
        //     int[1]: distance from one of added nodes
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[1] - b[1]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{1, 0});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int node = min[0];
            int dist = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            List<int[]> list = graph.get(node);
            if (list != null) {
                for (int[] e : list) {
                    heap.offer(e);
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[0];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

## 二分图 Bipartite graph

**给你一幅「图」，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同，你能做到吗**？

这就是图的「双色问题」，其实这个问题就等同于二分图的判定问题，如果你能够成功地将图染色，那么这幅图就是一幅二分图，反之则不是：

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-2c7cf3ff0aa23b08c7bb2c56a429656d_r.jpg)

  

在具体讲解二分图判定算法之前，我们先来说说计算机大佬们闲着无聊解决双色问题的目的是什么。

首先，二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到。

从简单实用的角度来看，二分图结构在某些场景可以更高效地存储数据。

比如前文 [介绍《算法 4》](https://labuladong.gitee.io/algo/) 文章中的例子，如何存储电影演员和电影之间的关系？

如果用哈希表存储，需要两个哈希表分别存储「每个演员到电影列表」的映射和「每部电影到演员列表」的映射。

但如果用「图」结构存储，将电影和参演的演员连接，很自然地就成为了一幅二分图：

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-5b7aa37d036fc8373fe634cd2217850e_r.jpg)

  

==每个电影节点的相邻节点就是参演该电影的所有演员，每个演员的相邻节点就是该演员参演过的所有电影，非常方便直观。==

类比这个例子，其实生活中不少实体的关系都能自然地形成二分图结构，所以在某些场景下图结构也可以作为存储键值对的数据结构（符号表）。



### 二分图判定思路

判定二分图的算法很简单，就是用代码解决「双色问题」。

**说白了就是遍历一遍图，一边遍历一遍染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同**。

既然说到遍历图，也不涉及最短路径之类的，当然是 DFS 算法和 BFS 皆可了，DFS 算法相对更常用些，所以我们先来看看如何用 DFS 算法判定双色图。

首先，写出图的遍历框架：

```java
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    traverse(root.right);
}

/* 多叉树遍历框架 */
void traverse(Node root) {
    if (root == null) return;
    for (Node child : root.children)
        traverse(child);
}

/* 图遍历框架 */
boolean[] visited;
void traverse(Graph graph, int v) {
    // 防止走回头路进入死循环
    if (visited[v]) return;
    // 前序遍历位置，标记节点 v 已访问
    visited[v] = true;
    for (TreeNode neighbor : graph.neighbors(v))
        traverse(graph, neighbor);
}
```

因为图中可能存在环，所以用 `visited` 数组防止走回头路。

**这里可以看到我习惯把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰**。

其实，如果你愿意，也可以把 if 判断放到其它地方，比如图遍历框架可以稍微改改：

```java
/* 图遍历框架 */
boolean[] visited;
void traverse(Graph graph, int v) {
    // 前序遍历位置，标记节点 v 已访问
    visited[v] = true;
    for (int neighbor : graph.neighbors(v)) {
        if (!visited[neighbor]) {
            // 只遍历没标记过的相邻节点
            traverse(graph, neighbor);
        }
    }
}
```

这种写法把对 `visited` 的判断放到递归调用之前，和之前的写法唯一的不同就是，你需要保证调用 `traverse(v)` 的时候，`visited[v] == false`。

为什么要特别说这种写法呢？因为我们判断二分图的算法会用到这种写法。

**回顾一下二分图怎么判断，其实就是让 `traverse` 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样**。

所以，判定二分图的代码逻辑可以这样写：

```java
/* 图遍历框架 */
void traverse(Graph graph, boolean[] visited, int v) {
    visited[v] = true;
    // 遍历节点 v 的所有相邻节点 neighbor
    for (int neighbor : graph.neighbors(v)) {
        if (!visited[neighbor]) {
            // 相邻节点 neighbor 没有被访问过
            // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色
            traverse(graph, visited, neighbor);
        } else {
            // 相邻节点 neighbor 已经被访问过
            // 那么应该比较节点 neighbor 和节点 v 的颜色
            // 若相同，则此图不是二分图
        }
    }
}
```



BFS

```java
// 从 start 节点开始进行 BFS 遍历
private void bfs(int[][] graph, int start) {
    Queue<Integer> q = new LinkedList<>();
    visited[start] = true;
    q.offer(start);

    while (!q.isEmpty() && ok) {
        int v = q.poll();
        // 从节点 v 向所有相邻节点扩散
        for (int w : graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 标记 w 节点，并放入队列
                visited[w] = true;
                q.offer(w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    }
}
```



### LeetCode 785. 判断二分图

[785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

以二维数组形式的邻接表方式给出无向图，判断是否为二分图。

思路：

1. 对节点进行着色，`color == 0` 表示未着色，`color == 1` 或 `color == -1`表示着色。
2. 从每个未着色的节点开始，将其着色，并进行深度优先搜索（每次深度优先搜索都会遍历完一个连通分量）。
3. 每遇到一条边，判断其另一个点的颜色：
   - 如果没有着色，就设置成相反的颜色，并继续深入搜索。
   - 如果已经着色，并且和当前点颜色相同，说明不是二分图。
   - 如果已经着色，并且和当前点颜色不同，忽略（继续循环）。

结合之前的代码框架，我们可以额外使用一个 `color` 数组来记录每个节点的颜色，从而写出解法代码：

```java
// 记录图是否符合二分图性质
private boolean ok = true;
// 记录图中节点的颜色，false 和 true 代表两种不同颜色
private boolean[] color;
// 记录图中节点是否被访问过
private boolean[] visited;

// 主函数，输入邻接表，判断是否是二分图
public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color =  new boolean[n];
    visited =  new boolean[n];
    // 因为图不一定是联通的，可能存在多个子图
    // 所以要把每个节点都作为起点进行一次遍历
    // 如果发现任何一个子图不是二分图，整幅图都不算二分图
    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }
    return ok;
}

// DFS 遍历框架
private void traverse(int[][] graph, int v) {
    // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
    if (!ok) return;

    visited[v] = true;
    for (int w : graph[v]) {
        if (!visited[w]) {
            // 相邻节点 w 没有被访问过
            // 那么应该给节点 w 涂上和节点 v 不同的颜色
            color[w] = !color[v];
            // 继续遍历 w
            traverse(graph, w);
        } else {
            // 相邻节点 w 已经被访问过
            // 根据 v 和 w 的颜色判断是否是二分图
            if (color[w] == color[v]) {
                // 若相同，则此图不是二分图
                ok = false;
            }
        }
    }
}
```

这就是解决「双色问题」的代码，如果能成功对整幅图染色，则说明这是一幅二分图，否则就不是二分图。

接下来看一下 BFS 算法的逻辑：

```java
// 记录图是否符合二分图性质
private boolean ok = true;
// 记录图中节点的颜色，false 和 true 代表两种不同颜色
private boolean[] color;
// 记录图中节点是否被访问过
private boolean[] visited;

public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color =  new boolean[n];
    visited =  new boolean[n];

    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            // 改为使用 BFS 函数
            bfs(graph, v);
        }
    }

    return ok;
}

// 从 start 节点开始进行 BFS 遍历
private void bfs(int[][] graph, int start) {
    Queue<Integer> q = new LinkedList<>();
    visited[start] = true;
    q.offer(start);

    while (!q.isEmpty() && ok) {
        int v = q.poll();
        // 从节点 v 向所有相邻节点扩散
        for (int w : graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 标记 w 节点，并放入队列
                visited[w] = true;
                q.offer(w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    }
}
```

核心逻辑和刚才实现的 `traverse` 函数（DFS 算法）完全一样，也是根据相邻节点 `v` 和 `w` 的颜色来进行判断的。





### 力扣第 886 题「可能的二分法」

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-59b2765ec902cdf39b758df91a370d2a_r.jpg)

  

函数签名如下：

```java
boolean possibleBipartition(int n, int[][] dislikes);
```

**其实这题考察的就是二分图的判定**：

如果你把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 `dislikes` 数组就可以构成一幅图；

又因为题目说互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组；

那就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么你按照颜色把这些节点分成两组不就行了嘛。

所以解法就出来了，我们把 `dislikes` 构造成一幅图，然后执行二分图的判定算法即可：

```java
private boolean ok = true;
private boolean[] color;
private boolean[] visited;

public boolean possibleBipartition(int n, int[][] dislikes) {
    // 图节点编号从 1 开始
    color = new boolean[n + 1];
    visited = new boolean[n + 1];
    // 转化成邻接表表示图结构
    List<Integer>[] graph = buildGraph(n, dislikes);

    for (int v = 1; v <= n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }

    return ok;
}

// 建图函数
private List<Integer>[] buildGraph(int n, int[][] dislikes) {
    // 图节点编号为 1...n
    List<Integer>[] graph = new LinkedList[n + 1];
    for (int i = 1; i <= n; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : dislikes) {
        int v = edge[1];
        int w = edge[0];
        // 「无向图」相当于「双向图」
        // v -> w
        graph[v].add(w);
        // w -> v
        graph[w].add(v);
    }
    return graph;
}

// 和之前的 traverse 函数完全相同
private void traverse(List<Integer>[] graph, int v) {
    if (!ok) return;
    visited[v] = true;
    for (int w : graph[v]) {
        if (!visited[w]) {
            color[w] = !color[v];
            traverse(graph, w);
        } else {
            if (color[w] == color[v]) {
                ok = false;
            }
        }
    }
}
```
