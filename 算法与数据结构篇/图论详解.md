# å›¾è®ºåŸºç¡€çŸ¥è¯†ã€å¸¸ç”¨ç®—æ³•ä¸LeetCodeé¢˜è§£

## åŸºæœ¬æ¦‚å¿µ

**å›¾ (Graph)** æ˜¯ç”±è‹¥å¹²ç»™å®šçš„é¡¶ç‚¹åŠè¿æ¥ä¸¤é¡¶ç‚¹çš„è¾¹æ‰€æ„æˆçš„å›¾å½¢ï¼Œè¿™ç§å›¾å½¢é€šå¸¸ç”¨æ¥æè¿°æŸäº›äº‹ç‰©ä¹‹é—´çš„æŸç§ç‰¹å®šå…³ç³»ã€‚é¡¶ç‚¹ç”¨äºä»£è¡¨äº‹ç‰©ï¼Œè¿æ¥ä¸¤é¡¶ç‚¹çš„è¾¹åˆ™ç”¨äºè¡¨ç¤ºä¸¤ä¸ªäº‹ç‰©é—´å…·æœ‰è¿™ç§å…³ç³»ã€‚

ä½¿ç”¨ `G(V, E)` è¡¨ç¤ºä¸€ä¸ªå›¾ï¼ŒVä¸ºé¡¶ç‚¹(Vertex)ï¼ŒEä¸ºè¾¹(Edge)ã€‚å›¾ä¸­**ä¸å…è®¸æ²¡æœ‰é¡¶ç‚¹**ï¼Œä½†æ˜¯å¯ä»¥æ²¡æœ‰è¾¹ã€‚

### æœ‰é™å›¾ä¸æ— é™å›¾

**æœ‰é™å›¾**ï¼šV, E éƒ½æ˜¯æœ‰é™é›†åˆã€‚

**æ— é™å›¾**ï¼šV æˆ– E æ˜¯æ— é™é›†åˆã€‚

### æœ‰å‘å›¾ä¸æ— å‘å›¾

**æ— å‘å›¾ (Undirected graph)**ï¼šæ¯ä¸ªè¾¹éƒ½æ˜¯æ— å‘è¾¹ã€‚

```
e = (u, v)
```

- eï¼š**æ— å‘è¾¹ (Undirected edge)**ï¼Œç®€ç§° **è¾¹ (Edge)**
- u, vï¼šeçš„ **ç«¯ç‚¹ (Endpoint)**

**æœ‰å‘å›¾ (Directed graph)**ï¼šæ¯ä¸ªè¾¹éƒ½æ˜¯æœ‰å‘è¾¹ã€‚

```
e = u -> v
```

- eï¼š**æœ‰å‘è¾¹ (Directed edge)** ï¼Œç®€ç§°**å¼§ (Arc)** æˆ– **è¾¹ (Edge)**
- uï¼še çš„ **èµ·ç‚¹ (Tail)**
- vï¼še çš„ **ç»ˆç‚¹ (Head)**
- u, vï¼šeçš„ **ç«¯ç‚¹ (Endpoint)**
- u æ˜¯ v çš„**ç›´æ¥å‰é©±**ï¼Œv æ˜¯ u çš„**ç›´æ¥åç»§**

> ä¸ºä»€ä¹ˆèµ·ç‚¹æ˜¯ Tailï¼Œç»ˆç‚¹æ˜¯ Headï¼Ÿ
> æœ‰å‘è¾¹é€šå¸¸ç”¨ç®­å¤´è¡¨ç¤ºï¼Œè€Œç®­å¤´æ˜¯ä»â€œå°¾â€æŒ‡å‘â€œå¤´â€çš„ã€‚

**æ··åˆå›¾ (Mixed graph)**ï¼šæ—¢æœ‰æœ‰å‘è¾¹ï¼Œåˆæœ‰æ— å‘è¾¹ã€‚

### ç›¸é‚»

**å…³è”ï¼ˆIncident)**ï¼šé¡¶ç‚¹ v æ˜¯è¾¹ e çš„ä¸€ä¸ªç«¯ç‚¹ï¼Œåˆ™ç§° e å’Œ v å…³è” æˆ– ç›¸é‚»ã€‚

**é‚»æ¥ / ç›¸é‚»ï¼ˆAdjacentï¼‰**ï¼šé¡¶ç‚¹uå’Œvï¼Œè‹¥å­˜åœ¨è¾¹ `(uï¼Œv)`ï¼Œåˆ™ç§°uå’Œvæ˜¯é‚»æ¥æˆ–ç›¸é‚»çš„ã€‚

**é‚»åŸŸ (Neighborhood)** ï¼š

- é¡¶ç‚¹ vï¼šæ‰€æœ‰ä¸é¡¶ç‚¹ v ç›¸é‚»çš„é¡¶ç‚¹é›†åˆï¼Œè®°ä½œ `N(v)`ã€‚
- ç‚¹é›† Sï¼šä¸ S ä¸­è‡³å°‘ä¸€ä¸ªç‚¹ç›¸é‚»çš„é¡¶ç‚¹é›†åˆï¼Œè®°ä½œ `N(S)` ï¼Œ`N(S) = âˆª N(v), vâˆˆS`

### åº¦

**åº¦ï¼ˆdegreeï¼‰**ï¼šé¡¶ç‚¹ç›¸é‚»è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `deg(V)`, `d(v)` è¡¨ç¤ºã€‚

- å­¤ç«‹ç‚¹ (Isolated vertex) ï¼š `d(v) == 0`
- å¶èŠ‚ç‚¹ (Leaf vertex) / æ‚¬æŒ‚ç‚¹ (Pendant vertex) ï¼š `d(v) == 1`
- å¶ç‚¹ (Even vertex) ï¼š `d(v) % 2 == 0`
- å¥‡ç‚¹ (Odd vertex) ï¼š`d(v) % 2 == 1`ã€‚å¥‡ç‚¹çš„ä¸ªæ•°æ˜¯å¶æ•°ã€‚
- æ”¯é…ç‚¹ (Universal vertex) ï¼š`d(v) = V - 1`ï¼Œå’Œæ‰€æœ‰å…¶ä»–ç‚¹éƒ½ç›¸é‚»ã€‚

æœ‰å‘å›¾ä¸­ï¼š

- **å…¥åº¦ (In-degree)**ï¼šä»¥è¯¥é¡¶ç‚¹ä¸ºç»ˆç‚¹çš„è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `d+(v)` è¡¨ç¤ºã€‚
- **å‡ºåº¦ (Out-degree)**ï¼šä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹çš„è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `d-(v)` è¡¨ç¤ºã€‚
- é¡¶ç‚¹çš„åº¦ = å…¥åº¦ + å‡ºåº¦ï¼Œå³ `d(v) = d+(v) + d-(v)`ã€‚

### è‡ªç¯ä¸é‡è¾¹

- è‡ªç¯ (Loop) ï¼šè¾¹ e çš„ä¸¤ä¸ªç«¯ç‚¹ç›¸åŒï¼Œåˆ™ e ç§°ä¸ºä¸€ä¸ªè‡ªç¯ã€‚
- é‡è¾¹ (Multiple edge) ï¼šä¸¤ä¸ªå®Œå…¨ç›¸åŒçš„è¾¹ï¼Œç§°ä½œï¼ˆä¸€ç»„ï¼‰é‡è¾¹ã€‚åœ¨æ— å‘å›¾ä¸­ `(u,v)` å’Œ`(v,u)` ç®—ä¸€ç»„é‡è¾¹ï¼Œè€Œåœ¨æœ‰å‘å›¾ä¸­ï¼Œ`u -> v` å’Œ `v -> u` ä¸ä¸ºé‡è¾¹ã€‚

### ç®€å•å›¾ä¸å¤šé‡å›¾

- ç®€å•å›¾ (Simple graph) ï¼šæ²¡æœ‰è‡ªç¯å’Œé‡è¾¹ã€‚éç©ºç®€å•å›¾ä¸­ä¸€å®šå­˜åœ¨åº¦ç›¸åŒçš„ç»“ç‚¹ã€‚
- å¤šé‡å›¾ (Multigraph) ï¼šæœ‰è‡ªç¯æˆ–é‡è¾¹ ã€‚

### è·¯å¾„

**é€”å¾„ (Walk) / é“¾ (Chain)**ï¼š`v0, e1, v1, e2, ... ek, vk`ï¼Œæˆ–ç®€å†™ä¸º `v0 â†’ v1 â†’ ... â†’ vk`

**è¿¹ (Trail)** ï¼šé“¾ï¼Œä¸”æ‰€æœ‰è¾¹éƒ½ä¸åŒã€‚

**è·¯å¾„ï¼ˆPathï¼‰/ ç®€å•è·¯å¾„ (Simple path)**ï¼šè¿¹ï¼Œä¸”æ‰€æœ‰ç‚¹éƒ½ä¸åŒï¼ˆé™¤äº†å…è®¸ `v0 == vk`ï¼‰ã€‚

**å›è·¯ (Circuit)** ï¼šè¿¹ï¼Œä¸” `v0 == vk`ã€‚

**ç¯ / åœˆ (Cycle) / ç®€å•å›è·¯ / ç®€å•ç¯ (Simple circuit)**ï¼šç®€å•è·¯å¾„ï¼Œä¸” `v0 == vk`ã€‚

### è¿é€š

æ— å‘å›¾

- **è¿é€šçš„ (Connected)** ï¼šä»é¡¶ç‚¹ u æœ‰è·¯å¾„åˆ°è¾¾ v ï¼Œåˆ™ `u,v` æ˜¯è¿é€šçš„ã€‚
- **è¿é€šå›¾ (Connected graph)**ï¼šä»»æ„ä¸¤ç‚¹è¿é€šã€‚
- **è¿é€šåˆ†é‡ / æå¤§è¿é€šå­å›¾ (Connected component)**ï¼šHæ˜¯Gçš„è¿é€šå­å›¾ï¼Œä¸”ä¸å­˜åœ¨è¿é€šå›¾Fï¼Œä½¿å¾— `H âŠŠ F âŠ† G`ï¼Œåˆ™Hæ˜¯Gçš„è¿é€šåˆ†é‡ã€‚

æ€§è´¨ï¼š

- è¿é€šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å›¾è‡ªèº«ã€‚
- éè¿é€šå›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ã€‚

æœ‰å‘å›¾

- **å¯è¾¾**ï¼šä»é¡¶ç‚¹ u æœ‰è·¯å¾„åˆ°è¾¾ v ï¼Œåˆ™ u å¯è¾¾ vã€‚
- **å¼ºè¿é€šçš„ (Strongly connected)**ï¼šæœ‰å‘å›¾ä¸­ï¼Œæ‰€æœ‰èŠ‚ç‚¹äº’ç›¸å¯è¾¾ã€‚
- **å¼±è¿é€šçš„ (Weakly connected)**ï¼šæœ‰å‘å›¾ä¸­ï¼Œè¾¹æ›¿æ¢ä¸ºæ— å‘è¾¹åå¯ä»¥å¾—åˆ°è¿é€šå›¾ï¼ˆä¹Ÿå°±æ˜¯æœ‰äº›èŠ‚ç‚¹åªèƒ½å•å‘å¯è¾¾ï¼‰ã€‚
- **å¼±è¿é€šåˆ†é‡ / æå¤§å¼±è¿é€šå­å›¾ (Weakly connected component)** ï¼Œ **å¼ºè¿é€šåˆ†é‡ / æå¤§å¼ºè¿é€šå­å›¾ (Strongly Connected component)**ï¼šä¸è¿é€šåˆ†é‡ç±»ä¼¼ã€‚

### ç¨€ç–å›¾ä¸ç¨ å¯†å›¾

ç¨€ç–å›¾ (Sparse graph)ï¼šè¾¹æ•°è¿œå°äºç‚¹æ•°çš„å¹³æ–¹ã€‚

ç¨ å¯†å›¾ (Dense graph) ï¼šè¾¹æ•°æ¥è¿‘ç‚¹æ•°çš„å¹³æ–¹ã€‚

### ç‰¹æ®Šçš„å›¾

**æ ‘ (Tree)** ï¼šä¸å«ç¯çš„æ— å‘è¿é€šå›¾ã€‚

**æ£®æ— (Forest)**ï¼šå¤šæ£µæ ‘å¯ä»¥ç»„æˆä¸€ä¸ª æ£®æ—ã€‚

**äºŒåˆ†å›¾ (Bipartite graph)**ï¼šå›¾çš„ç‚¹é›†åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæ¯ä¸€éƒ¨åˆ†çš„å†…éƒ¨éƒ½æ²¡æœ‰è¿è¾¹ï¼ˆæˆ–è€…è¯´æ‰€æœ‰è¾¹çš„ä¸¤ä¸ªç‚¹åˆšå¥½åˆ†åˆ«åœ¨ä¸¤éƒ¨åˆ†ä¸­ï¼‰ã€‚

**å®Œå…¨äºŒåˆ†å›¾ (Complete bipartite graph/Biclique)**ï¼šä»»ä½•ä¸¤ä¸ªä¸åœ¨åŒä¸€éƒ¨åˆ†çš„ç‚¹ä¹‹é—´éƒ½æœ‰è¿è¾¹ï¼ˆä¾‹å¦‚ä¸¤éƒ¨åˆ†åˆ†åˆ«æœ‰ `x,y` ä¸ªç‚¹ï¼Œåˆ™å›¾æ€»å…±æœ‰`x*y`ä¸ªè¾¹ï¼‰ã€‚

# ğŸŒŸå›¾çš„è¡¨ç¤º

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/0.jpg)

### Javaä»£ç å±•ç¤ºå›¾

å‚è€ƒï¼š

https://labuladong.online/algo/data-structure/graph-traverse/#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86



```java
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

å’Œæˆ‘ä»¬ä¹‹å‰è¯´çš„å¤šå‰æ ‘èŠ‚ç‚¹å‡ ä¹å®Œå…¨ä¸€æ ·ï¼š

```java
class TreeNode {
    int val;
    TreeNode[] children;
}
```

å›¾çœŸçš„æ²¡å•¥é«˜æ·±çš„ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸ªé«˜çº§ç‚¹çš„å¤šå‰æ ‘è€Œå·²ï¼Œé€‚ç”¨äºæ ‘çš„ DFS/BFS éå†ç®—æ³•ï¼Œå…¨éƒ¨é€‚ç”¨äºå›¾ã€‚

ä¸è¿‡å‘¢ï¼Œä¸Šé¢çš„è¿™ç§å®ç°æ˜¯**ã€Œé€»è¾‘ä¸Šçš„ã€ï¼Œå®é™…ä¸Šæˆ‘ä»¬å¾ˆå°‘ç”¨è¿™ä¸ª `Vertex` ç±»å®ç°å›¾ï¼Œè€Œæ˜¯ç”¨å¸¸è¯´çš„é‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µæ¥å®ç°ã€‚**

```java
List<Integer>[] graph;
boolean[][] matrix;
```

### é‚»æ¥è¡¨ Adjacency Table

ä½¿ç”¨ä¸€ä¸ªæ”¯æŒåŠ¨æ€å¢åŠ å…ƒç´ çš„æ•°æ®ç»“æ„æ„æˆçš„æ•°ç»„ï¼Œä¾‹å¦‚Javaä¸­çš„ `List[] adj`ã€‚

- **é¢†æ¥è¡¨**ä¸­ `adj[u]` å­˜å‚¨çš„æ˜¯ç‚¹ u æ‰€æœ‰å‡ºè¾¹çš„ä¿¡æ¯ï¼ˆç»ˆç‚¹ã€è¾¹æƒç­‰ï¼‰ã€‚
- **é€†é‚»æ¥è¡¨**ä¸­ `adj[u]` å­˜å‚¨çš„æ˜¯ç‚¹ u æ‰€æœ‰å…¥è¾¹çš„ä¿¡æ¯ï¼ˆèµ·ç‚¹ã€è¾¹æƒç­‰ï¼‰ã€‚

é‚»æ¥è¡¨å¾ˆç›´è§‚ï¼Œæˆ‘æŠŠæ¯ä¸ªèŠ‚ç‚¹ x çš„é‚»å±…éƒ½å­˜åˆ°ä¸€ä¸ªåˆ—è¡¨é‡Œï¼Œç„¶åæŠŠ x å’Œè¿™ä¸ªåˆ—è¡¨å…³è”èµ·æ¥ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ä¸€ä¸ªèŠ‚ç‚¹ x æ‰¾åˆ°å®ƒçš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ã€‚

### é‚»æ¥çŸ©é˜µ Adjacency Matrix

äºŒç»´æ•°ç»„ `adj[][]`ï¼Œ`adj[u][v]` ä¸º 1 è¡¨ç¤ºå­˜åœ¨ u åˆ° v çš„è¾¹ï¼Œä¸º 0 è¡¨ç¤ºä¸å­˜åœ¨ã€‚

å¦‚æœæ˜¯å¸¦è¾¹æƒçš„å›¾ï¼Œå¯ä»¥åœ¨ `adj[u][v]` ä¸­å­˜å‚¨ u åˆ° v çš„è¾¹çš„è¾¹æƒã€‚

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2.jpeg)

### é‚»æ¥çŸ©é˜µ\é‚»æ¥è¡¨åŒºåˆ«

é‚»æ¥çŸ©é˜µé‡Œé¢ç©ºç€é‚£ä¹ˆå¤šä½ç½®ï¼Œè‚¯å®šéœ€è¦æ›´å¤šçš„å­˜å‚¨ç©ºé—´ã€‚
ä½†æ˜¯ï¼Œé‚»æ¥è¡¨æ— æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸é‚»ã€‚
æ¯”å¦‚è¯´æˆ‘æƒ³åˆ¤æ–­èŠ‚ç‚¹ 1 æ˜¯å¦å’ŒèŠ‚ç‚¹ 3 ç›¸é‚»ï¼Œæˆ‘è¦å»é‚»æ¥è¡¨é‡Œ 1 å¯¹åº”çš„é‚»å±…åˆ—è¡¨é‡ŒæŸ¥æ‰¾ 3 æ˜¯å¦å­˜åœ¨ã€‚ä½†å¯¹äºé‚»æ¥çŸ©é˜µå°±ç®€å•äº†ï¼Œåªè¦çœ‹çœ‹ `matrix[1][3] `å°±çŸ¥é“äº†ï¼Œæ•ˆç‡é«˜ã€‚
æ‰€ä»¥è¯´ï¼Œä½¿ç”¨å“ªä¸€ç§æ–¹å¼å®ç°å›¾ï¼Œè¦çœ‹å…·ä½“æƒ…å†µã€‚

é‚»æ¥è¡¨çš„ä½¿ç”¨ä¼šæ›´é¢‘ç¹ä¸€äº›ï¼Œä¸»è¦æ˜¯å› ä¸ºæ“ä½œèµ·æ¥è¾ƒä¸ºç®€å•ï¼Œä½†è¿™ä¸æ„å‘³ç€é‚»æ¥çŸ©é˜µåº”è¯¥è¢«è½»è§†ã€‚çŸ©é˜µæ˜¯ä¸€ä¸ªå¼ºæœ‰åŠ›çš„æ•°å­¦å·¥å…·ï¼Œå›¾çš„ä¸€äº›éšæ™¦æ€§è´¨å¯ä»¥å€ŸåŠ©ç²¾å¦™çš„çŸ©é˜µè¿ç®—å±•ç°å‡ºæ¥ã€‚ä¸è¿‡æœ¬æ–‡ä¸å‡†å¤‡å¼•å…¥æ•°å­¦å†…å®¹ï¼Œæ‰€ä»¥æœ‰å…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œæœç´¢å­¦ä¹ ã€‚

### å›¾è®ºçš„åº¦

æœ€åï¼Œæˆ‘ä»¬å†æ˜ç¡®ä¸€ä¸ªå›¾è®ºä¸­ç‰¹æœ‰çš„åº¦ï¼ˆdegreeï¼‰çš„æ¦‚å¿µï¼Œåœ¨æ— å‘å›¾ä¸­ï¼Œã€Œåº¦ã€å°±æ˜¯æ¯ä¸ªèŠ‚ç‚¹ç›¸è¿çš„è¾¹çš„æ¡æ•°ã€‚
ç”±äºæœ‰å‘å›¾çš„è¾¹æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æœ‰å‘å›¾ä¸­æ¯ä¸ªèŠ‚ç‚¹ã€Œåº¦ã€è¢«ç»†åˆ†ä¸ºå…¥åº¦ï¼ˆindegreeï¼‰å’Œå‡ºåº¦ï¼ˆoutdegreeï¼‰ï¼Œæ¯”å¦‚ä¸‹å›¾ï¼š

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657368-60303c3a-360f-45f7-9e60-98b32887cb36.jpeg)

å…¶ä¸­èŠ‚ç‚¹ 3 çš„å…¥åº¦ä¸º 3ï¼ˆæœ‰ä¸‰æ¡è¾¹æŒ‡å‘å®ƒï¼‰ï¼Œå‡ºåº¦ä¸º 1ï¼ˆå®ƒæœ‰ 1 æ¡è¾¹æŒ‡å‘åˆ«çš„èŠ‚ç‚¹ï¼‰ã€‚
å¥½äº†ï¼Œå¯¹äºã€Œå›¾ã€è¿™ç§æ•°æ®ç»“æ„ï¼Œèƒ½çœ‹æ‡‚ä¸Šé¢è¿™äº›å°±ç»°ç»°å¤Ÿç”¨äº†ã€‚
é‚£ä½ å¯èƒ½ä¼šé—®ï¼Œæˆ‘ä»¬ä¸Šé¢è¯´çš„è¿™ä¸ªå›¾çš„æ¨¡å‹ä»…ä»…æ˜¯ã€Œæœ‰å‘æ— æƒå›¾ã€ï¼Œä¸æ˜¯è¿˜æœ‰ä»€ä¹ˆåŠ æƒå›¾ï¼Œæ— å‘å›¾ï¼Œç­‰ç­‰â€¦â€¦

å¦‚æœæ˜¯é‚»æ¥è¡¨ï¼Œæˆ‘ä»¬ä¸ä»…ä»…å­˜å‚¨æŸä¸ªèŠ‚ç‚¹ x çš„æ‰€æœ‰é‚»å±…èŠ‚ç‚¹ï¼Œè¿˜å­˜å‚¨ x åˆ°æ¯ä¸ªé‚»å±…çš„æƒé‡ï¼Œä¸å°±å®ç°åŠ æƒæœ‰å‘å›¾äº†å—ï¼Ÿ
å¦‚æœæ˜¯é‚»æ¥çŸ©é˜µï¼Œ`matrix[x][y] `ä¸å†æ˜¯å¸ƒå°”å€¼ï¼Œè€Œæ˜¯ä¸€ä¸ª int å€¼ï¼Œ0 è¡¨ç¤ºæ²¡æœ‰è¿æ¥ï¼Œå…¶ä»–å€¼è¡¨ç¤ºæƒé‡ï¼Œä¸å°±å˜æˆåŠ æƒæœ‰å‘å›¾äº†å—ï¼Ÿ

```java
List<int[]>[] graph;
int[][] matrix;
```



### å›¾çš„éå†-DFSå›¾

- æ·±åº¦ä¼˜å…ˆæœç´¢ (Depth-First Search, DFS)

![æ·±åº¦ä¼˜å…ˆæœç´¢](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/dfs.png)

å¤šå‰æ ‘çš„éå†ï¼š

```java
void traverse(TreeNode root) {
    if (root == null) return;
    
    for (TreeNode child : root.children) {
        traverse(child);
    }
    
}
```

å›¾å’Œå¤šå‰æ ‘æœ€å¤§çš„åŒºåˆ«æ˜¯ï¼Œ**å›¾æ˜¯å¯èƒ½åŒ…å«ç¯çš„**ï¼Œä½ ä»å›¾çš„æŸä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹éå†ï¼Œæœ‰å¯èƒ½èµ°äº†ä¸€åœˆåˆå›åˆ°è¿™ä¸ªèŠ‚ç‚¹ï¼Œè€Œæ ‘ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µï¼Œä»æŸä¸ªèŠ‚ç‚¹å‡ºå‘å¿…ç„¶èµ°åˆ°å¶å­èŠ‚ç‚¹ï¼Œç»ä¸å¯èƒ½å›åˆ°å®ƒè‡ªèº«ã€‚
æ‰€ä»¥ï¼Œå¦‚æœå›¾åŒ…å«ç¯ï¼Œ**éå†æ¡†æ¶å°±è¦ä¸€ä¸ª visited æ•°ç»„è¿›è¡Œè¾…åŠ©**ï¼š

```java
// è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹
boolean[] visited;
// è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
boolean[] onPath;

/* å›¾éå†æ¡†æ¶ */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå†
    visited[s] = true;
    // åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„
    onPath[s] = false;
}
```

æ³¨æ„ visited æ•°ç»„å’Œ onPath æ•°ç»„çš„åŒºåˆ«ï¼Œå› ä¸ºäºŒå‰æ ‘ç®—æ˜¯ç‰¹æ®Šçš„å›¾ï¼Œæ‰€ä»¥ç”¨éå†äºŒå‰æ ‘çš„è¿‡ç¨‹æ¥ç†è§£ä¸‹è¿™ä¸¤ä¸ªæ•°ç»„çš„åŒºåˆ«ï¼š

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657880-80ddf295-ecfc-4d18-a7e7-b861bcc244da.gif)

ä¸Šè¿° GIF æè¿°äº†é€’å½’éå†äºŒå‰æ ‘çš„è¿‡ç¨‹ï¼Œåœ¨ visited ä¸­è¢«æ ‡è®°ä¸º true çš„èŠ‚ç‚¹ç”¨ç°è‰²è¡¨ç¤ºï¼Œåœ¨ onPath ä¸­è¢«æ ‡è®°ä¸º true çš„èŠ‚ç‚¹ç”¨ç»¿è‰²è¡¨ç¤ºï¼Œç±»æ¯”è´ªåƒè›‡æ¸¸æˆï¼Œvisited è®°å½•è›‡ç»è¿‡è¿‡çš„æ ¼å­ï¼Œè€Œ onPath ä»…ä»…è®°å½•è›‡èº«ã€‚åœ¨å›¾çš„éå†è¿‡ç¨‹ä¸­ï¼ŒonPath ç”¨äºåˆ¤æ–­æ˜¯å¦æˆç¯ï¼Œç±»æ¯”å½“è´ªåƒè›‡è‡ªå·±å’¬åˆ°è‡ªå·±ï¼ˆæˆç¯ï¼‰çš„åœºæ™¯ï¼Œè¿™ä¸‹ä½ å¯ä»¥ç†è§£å®ƒä»¬äºŒè€…çš„åŒºåˆ«äº†å§ã€‚

å¦‚æœè®©ä½ å¤„ç†è·¯å¾„ç›¸å…³çš„é—®é¢˜ï¼Œè¿™ä¸ª onPath å˜é‡æ˜¯è‚¯å®šä¼šè¢«ç”¨åˆ°çš„ï¼Œæ¯”å¦‚ [æ‹“æ‰‘æ’åº](https://labuladong.online/algo/data-structure/topological-sort/) ä¸­å°±æœ‰è¿ç”¨ã€‚
 onPath æ•°ç»„çš„æ“ä½œåšã€Œåšé€‰æ‹©ã€å’Œã€Œæ’¤é”€é€‰æ‹©ã€ï¼ŒåŒºåˆ«åœ¨äºä½ç½®ï¼š**å›æº¯ç®—æ³•çš„ã€Œåšé€‰æ‹©ã€å’Œã€Œæ’¤é”€é€‰æ‹©ã€åœ¨ for å¾ªç¯é‡Œé¢**ï¼ŒDFS**å¯¹ onPath æ•°ç»„çš„æ“ä½œåœ¨ for å¾ªç¯å¤–é¢ã€‚**
ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªåŒºåˆ«å‘¢ï¼Ÿå›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„åŒºåˆ«æ‰€åœ¨ï¼šå›æº¯ç®—æ³•å…³æ³¨çš„ä¸æ˜¯èŠ‚ç‚¹ï¼Œè€Œæ˜¯æ ‘æã€‚

```java
// DFS ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨èŠ‚ç‚¹
void traverse(TreeNode root) {
    if (root == null) return;
    printf("è¿›å…¥èŠ‚ç‚¹ %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("ç¦»å¼€èŠ‚ç‚¹ %s", root);
}

// å›æº¯ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨æ ‘æ
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // åšé€‰æ‹©
        printf("ä» %s åˆ° %s", root, child);
        backtrack(child);
        // æ’¤é”€é€‰æ‹©
        printf("ä» %s åˆ° %s", child, root);
    }
}
```

æ‰€ä»¥å¯¹äºè¿™é‡Œã€Œå›¾ã€çš„éå†ï¼Œæˆ‘ä»¬åº”è¯¥ç”¨ DFS ç®—æ³•ï¼Œå³æŠŠ `onPath` çš„æ“ä½œæ”¾åˆ° for å¾ªç¯å¤–é¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è®°å½•èµ·å§‹ç‚¹çš„éå†ã€‚



- å¹¿åº¦ä¼˜å…ˆæœç´¢ (Breadth-First Search, BFS)

![å¹¿åº¦ä¼˜å…ˆæœç´¢](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/bfs.png)



## å›¾çš„éå†é—®é¢˜

### 797.æ‰€æœ‰å¯èƒ½è·¯å¾„

é¢˜ç›®è¾“å…¥ä¸€å¹…**æœ‰å‘æ— ç¯å›¾**ï¼Œè¿™ä¸ªå›¾åŒ…å« `n` ä¸ªèŠ‚ç‚¹ï¼Œæ ‡å·ä¸º `0, 1, 2,..., n - 1`ï¼Œè¯·ä½ è®¡ç®—æ‰€æœ‰ä»èŠ‚ç‚¹ `0` åˆ°èŠ‚ç‚¹ `n - 1` çš„è·¯å¾„ã€‚

è¾“å…¥çš„è¿™ä¸ª `graph` å…¶å®å°±æ˜¯ã€Œé‚»æ¥è¡¨ã€è¡¨ç¤ºçš„ä¸€å¹…å›¾ï¼Œ`graph[i]` å­˜å‚¨è¿™èŠ‚ç‚¹ `i` çš„æ‰€æœ‰é‚»å±…èŠ‚ç‚¹ã€‚

æ¯”å¦‚è¾“å…¥ `graph = [[1,2],[3],[3],[]]`ï¼Œå°±ä»£è¡¨ä¸‹é¢è¿™å¹…å›¾ï¼š

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1.jpg)

ç®—æ³•åº”è¯¥è¿”å› `[[0,1,3],[0,2,3]]`ï¼Œå³ `0` åˆ° `3` çš„æ‰€æœ‰è·¯å¾„ã€‚

**è§£æ³•å¾ˆç®€å•ï¼Œä»¥ `0` ä¸ºèµ·ç‚¹éå†å›¾ï¼ŒåŒæ—¶è®°å½•éå†è¿‡çš„è·¯å¾„ï¼Œå½“éå†åˆ°ç»ˆç‚¹æ—¶å°†è·¯å¾„è®°å½•ä¸‹æ¥å³å¯**ã€‚

æ—¢ç„¶è¾“å…¥çš„å›¾æ˜¯æ— ç¯çš„ï¼Œæˆ‘ä»¬å°±ä¸éœ€è¦ `visited` æ•°ç»„è¾…åŠ©äº†ï¼Œç›´æ¥å¥—ç”¨å›¾çš„éå†æ¡†æ¶ï¼š

```java
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    List<List<Integer>> res = new LinkedList<>();
        
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // ç»´æŠ¤é€’å½’è¿‡ç¨‹ä¸­ç»è¿‡çš„è·¯å¾„
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.add(new LinkedList<>(path));
            // å¯ä»¥åœ¨è¿™ç›´æ¥ returnï¼Œä½†è¦ removeLast æ­£ç¡®ç»´æŠ¤ path
            // path.removeLast();
            // return;
            // ä¸ return ä¹Ÿå¯ä»¥ï¼Œå› ä¸ºå›¾ä¸­ä¸åŒ…å«ç¯ï¼Œä¸ä¼šå‡ºç°æ— é™é€’å½’
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
        
        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.removeLast();
    }
}

```

ç®€æ´ç‰ˆï¼š

```java
class Solution {
    List<List<Integer>> ans = new LinkedList<>();
    List<Integer> path = new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        dfs(graph,0);
        return ans;
    }
    void dfs(int[][] graph,int s){
        path.addLast(s);
        if (s==graph.length-1){
            ans.add(new LinkedList<>(path));
        }
        for (int i : graph[s]) {
            dfs(graph,i);
        }
        path.removeLast();
    }
}
```



## ç¯æ£€æµ‹ç®—æ³•é—®é¢˜

### 207. è¯¾ç¨‹è¡¨

ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® `numCourses` é—¨è¯¾ç¨‹ï¼Œè®°ä¸º `0` åˆ° `numCourses - 1` ã€‚

åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„ `prerequisites` ç»™å‡ºï¼Œå…¶ä¸­ `prerequisites[i] = [ai, bi]` ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹ `ai` åˆ™ **å¿…é¡»** å…ˆå­¦ä¹ è¯¾ç¨‹ `bi` ã€‚

- ä¾‹å¦‚ï¼Œå…ˆä¿®è¯¾ç¨‹å¯¹ `[0, 1]` è¡¨ç¤ºï¼šæƒ³è¦å­¦ä¹ è¯¾ç¨‹ `0` ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ `1` ã€‚

è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0 ã€‚è¿™æ˜¯å¯èƒ½çš„ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0],[0,1]]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 0 ï¼›å¹¶ä¸”å­¦ä¹ è¯¾ç¨‹ 0 ä¹‹å‰ï¼Œä½ è¿˜åº”å…ˆå®Œæˆè¯¾ç¨‹ 1 ã€‚è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚
```

**æç¤ºï¼š**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` ä¸­çš„æ‰€æœ‰è¯¾ç¨‹å¯¹ **äº’ä¸ç›¸åŒ**

é¦–å…ˆæˆ‘ä»¬è¦æŠŠé¢˜ç›®çš„è¾“å…¥è½¬åŒ–æˆä¸€å¹…æœ‰å‘å›¾ï¼Œç„¶åå†åˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨ç¯ã€‚

å¦‚ä½•è½¬æ¢æˆå›¾å‘¢ï¼Ÿæˆ‘ä»¬å‰æ–‡ [å›¾è®ºåŸºç¡€](https://labuladong.github.io/article/fname.html?fname=å›¾) å†™è¿‡å›¾çš„ä¸¤ç§å­˜å‚¨å½¢å¼ï¼Œé‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨ã€‚

ä»¥æˆ‘åˆ·é¢˜çš„ç»éªŒï¼Œå¸¸è§çš„å­˜å‚¨æ–¹å¼æ˜¯ä½¿ç”¨é‚»æ¥è¡¨ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§ç»“æ„ï¼š

```java
List<Integer>[] graph;
```

**`graph[s]` æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå­˜å‚¨ç€èŠ‚ç‚¹ `s` æ‰€æŒ‡å‘çš„èŠ‚ç‚¹**ã€‚

æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆå¯ä»¥å†™ä¸€ä¸ªå»ºå›¾å‡½æ•°ï¼š

```java
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        // è¾¹çš„æ–¹å‘æ˜¯ã€Œè¢«ä¾èµ–ã€å…³ç³»ï¼Œå³ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        graph[from].add(to);
    }
    return graph;
}
```

å›¾å»ºå‡ºæ¥äº†ï¼Œæ€ä¹ˆåˆ¤æ–­å›¾ä¸­æœ‰æ²¡æœ‰ç¯å‘¢ï¼Ÿ

> tipï¼šç±»æ¯”è´ªåƒè›‡æ¸¸æˆï¼Œ`visited` è®°å½•è›‡ç»è¿‡è¿‡çš„æ ¼å­ï¼Œè€Œ `onPath` ä»…ä»…è®°å½•è›‡èº«ã€‚`onPath` ç”¨äºåˆ¤æ–­æ˜¯å¦æˆç¯ï¼Œç±»æ¯”å½“è´ªåƒè›‡è‡ªå·±å’¬åˆ°è‡ªå·±ï¼ˆæˆç¯ï¼‰çš„åœºæ™¯ã€‚

è¿™æ ·ï¼Œå°±å¯ä»¥åœ¨éå†å›¾çš„è¿‡ç¨‹ä¸­é¡ºä¾¿åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¯äº†ï¼Œå®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```java
class Solution {
    // è®°å½•ä¸€æ¬¡é€’å½’å †æ ˆä¸­çš„èŠ‚ç‚¹
    boolean[] onPath;
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    boolean[] visited;
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    boolean hasCycle = false;

    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            traverse(graph, i);
        }
        // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
        return !hasCycle;
    }

    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // å‡ºç°ç¯
            hasCycle = true;
        }
        
        if (visited[s] || hasCycle) {
            // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
            return;
        }
        // å‰åºä»£ç ä½ç½®
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // ååºä»£ç ä½ç½®
        onPath[s] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            // è¾¹çš„æ–¹å‘æ˜¯ã€Œè¢«ä¾èµ–ã€å…³ç³»ï¼Œå³ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            graph[from].add(to);
        }
        return graph;
    }
}
```

## æ‹“æ‰‘æ’åºé—®é¢˜ï¼ˆæœ‰å‘æ— ç¯å›¾ã€AOVç½‘ï¼‰

**æœ‰å‘æ— ç¯å›¾ï¼ŒDirected Acyclic Graphï¼ŒDAG**

**æ‹“æ‰‘æ’åºï¼ŒTopological sorting**

**AOVç½‘ï¼ˆActivity On Vertex Network)**ï¼šå°†ä¸€ä¸ªå·¥ç¨‹åˆ†ä¸ºå¤šä¸ªå°çš„**æ´»åŠ¨ï¼ˆActivity)**ï¼Œåœ¨**æœ‰å‘æ— ç¯å›¾**ä¸­ï¼Œç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨å¼§ï¼ˆæœ‰å‘è¾¹ï¼‰è¡¨ç¤ºæ´»åŠ¨çš„å…ˆåå…³ç³»ï¼Œç®€ç§°ä¸ºAOVç½‘ã€‚

æ€§è´¨ï¼š

- èƒ½ æ‹“æ‰‘æ’åº çš„å›¾ï¼Œä¸€å®šæ˜¯æœ‰å‘æ— ç¯å›¾
- æœ‰å‘æ— ç¯å›¾ï¼Œä¸€å®šèƒ½æ‹“æ‰‘æ’åº

æ³¨æ„ï¼š

- Bä¾èµ–Aï¼Œä¸€èˆ¬åœ¨å›¾ä¸­è¡¨ç¤ºä¸ºæœ‰å‘è¾¹ `A -> B` ï¼Œä¹Ÿå°±æ˜¯å…ˆå®ŒæˆAï¼Œåå®ŒæˆBã€‚

### LeetCode 210. è¯¾ç¨‹è¡¨ II

[210. è¯¾ç¨‹è¡¨ II](https://leetcode-cn.com/problems/course-schedule-ii/)

ç°åœ¨ä½ æ€»å…±æœ‰ n é—¨è¯¾ `0 ~ n-1`ã€‚æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0ï¼Œè¦å…ˆå®Œæˆè¯¾ç¨‹ 1ï¼Œç”¨ `[0,1]` è¡¨ç¤ºã€‚ç»™å®šè¯¾ç¨‹æ€»é‡ä»¥åŠå®ƒä»¬çš„å…ˆå†³æ¡ä»¶ï¼Œè¿”å›å­¦å®Œæ‰€æœ‰è¯¾ç¨‹çš„é¡ºåºï¼ˆè¿”å›ä¸€ç§å³å¯ï¼‰ï¼Œå¦‚æœä¸å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè¿”å›ç©ºæ•°ç»„ã€‚

### Kahn ç®—æ³•

#### æµç¨‹

1. å°†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ä¿å­˜åˆ°é›†åˆSä¸­ï¼ˆå…¥åº¦ä¸º0è¯´æ˜ä¸ä¾èµ–å…¶ä»–èŠ‚ç‚¹ï¼‰ã€‚
2. ä»é›†åˆSä¸­å–å‡º**ä»»æ„**ä¸€ä¸ªèŠ‚ç‚¹nï¼Œæ”¾åˆ°ç»“æœListä¸­ã€‚
3. å°†nçš„åç»§èŠ‚ç‚¹å…¥åº¦å‡å°‘1ï¼Œå¦‚æœå…¥åº¦å˜ä¸º0ï¼Œåˆ™æ·»åŠ åˆ°é›†åˆSä¸­ï¼ˆå¯ä»¥ç†è§£ä¸ºä»å›¾ä¸­åˆ é™¤èŠ‚ç‚¹nåŠå…¶å‡ºè¾¹ï¼Œå› æ­¤åç»§èŠ‚ç‚¹çš„å…¥åº¦å‡å°‘äº†ï¼›èŠ‚ç‚¹å…¥åº¦å˜ä¸º0æ—¶ï¼Œè¯´æ˜å®ƒçš„ä¾èµ–èŠ‚ç‚¹éƒ½å·²ç»æ”¾å¥½äº†ï¼‰ã€‚
4. ä¸æ–­å¾ªç¯ç›´åˆ°é›†åˆSä¸ºç©ºã€‚
5. æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èŠ‚ç‚¹éƒ½å·²ç»å¤„ç†ã€‚å¦‚æœæœ‰èŠ‚ç‚¹æ²¡å¤„ç†ï¼Œè¯´æ˜æœ‰ç¯ï¼Œæ— æ³•æ’åºã€‚

#### å¤æ‚åº¦

æ—¶é—´å¤æ‚åº¦ `O(E + V)`

#### å›¾è§£

0ã€Açš„å…¥åº¦ä¸º0ï¼Œæ·»åŠ åˆ°é›†åˆSä¸­ã€‚

- é›†åˆSï¼š `[A]`
- æ’åºç»“æœï¼š `[]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn1.png)

1ã€ç§»é™¤Aã€‚åŒæ—¶Bã€Cçš„å…¥åº¦ä¹Ÿä¼šå˜ä¸º0ï¼Œæ·»åŠ åˆ°é›†åˆä¸­ã€‚

- é›†åˆSï¼š `[B, C]`
- æ’åºç»“æœï¼š `[A]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn2.png)

2ã€ç§»é™¤Bï¼ŒåŒæ—¶Dçš„å…¥åº¦å˜ä¸º1ï¼ŒEçš„å…¥åº¦å˜ä¸º0ï¼Œæ·»åŠ Eåˆ°é›†åˆSä¸­ã€‚

- é›†åˆSï¼š `[C, E]`
- æ’åºç»“æœï¼š `[A, B]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn3.png)

3ã€ç§»é™¤Cï¼ŒåŒæ—¶Dçš„å…¥åº¦å˜ä¸º0ï¼Œæ·»åŠ åˆ°é›†åˆSä¸­ã€‚

- é›†åˆSï¼š `[E, D]`
- æ’åºç»“æœï¼š `[A, B, C]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn4.png)

4ã€ç§»é™¤Eã€‚

- é›†åˆSï¼š `[D]`
- æ’åºç»“æœï¼š `[A, B, C, E]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn5.png)

5ã€ç§»é™¤Dï¼Œé›†åˆSå˜ä¸ºç©ºï¼Œä¸”æ‰€æœ‰èŠ‚ç‚¹éƒ½å·²ç»æ”¾åˆ°äº†æ’åºç»“æœåˆ—è¡¨ä¸­ï¼Œæ’åºå®Œæˆã€‚

- é›†åˆSï¼š `[]`
- æ’åºç»“æœï¼š `[A, B, C, E, D]`

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/kahn6.png)

#### ä»£ç 

```
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
```

### æ·±åº¦ä¼˜å…ˆç®—æ³• DFS

#### æµç¨‹

- ä»æ¯ä¸ª**æœªè®¿é—®**çš„èŠ‚ç‚¹å¼€å§‹æ·±åº¦ä¼˜å…ˆéå†ã€‚
- è®¿é—®å®Œä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åç»§èŠ‚ç‚¹åï¼Œå°†è¯¥èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­ï¼ˆç±»ä¼¼æ ‘çš„**ååºéå†**ï¼‰ã€‚
- æœ€åå°†æ ˆåè½¬å³å¯å¾—åˆ°ç»“æœã€‚

#### å›¾è§£

ä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dfs-sort1.png)

æ·±åº¦ä¼˜å…ˆå¯ä»¥æƒ³è±¡æˆå°†å›¾åˆ†å‰²ä¸ºå¤šä¸ªæ ‘ï¼Œå…ˆåéå†æ¯æ£µæ ‘ï¼Œä¸”åéå†çš„æ ‘ä¾èµ–å…ˆéå†çš„æ ‘ã€‚

1. `DFS(A)`ï¼šè®¿é—®äº† `A, B, D, E` ï¼Œæ ˆï¼š`[E, D, B, A]`
2. `DFS(C)`ï¼šè®¿é—®äº† `C, G`ï¼Œæ ˆï¼š`[E, D, B, A; G, C]`
3. `DFS(F)`ï¼šè®¿é—®äº† `F, H`ï¼Œæ ˆï¼š`[E, D, B, A, G, C; H, F]`

æ’åºç»“æœï¼š`F H C G A B D E` ã€‚

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dfs-sort2.png)

#### ä»£ç 

DFSå®ç°å¦‚ä¸‹ï¼Œå…¶ä¸­ï¼š

- `graph` ä¸ºé‚»æ¥è¡¨ã€‚
- `globalVisited` ç”¨äºæ ‡è®°æ‰€æœ‰è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå·²ç»è®¿é—®è¿‡çš„ä¸å†é‡å¤è®¿é—®ã€‚
- `localVisited` ç”¨äºæ ‡è®°æœ¬è½®DFSè®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå¦‚æœæŸä¸€è½®DFSé‡å¤è®¿é—®åˆ°äº†æŸä¸ªèŠ‚ç‚¹ï¼Œè¯´æ˜å›¾ä¸­æœ‰ç¯ã€‚

```
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
```

## æœ€çŸ­è·¯å¾„é—®é¢˜

å¯¹äºè¾¹æƒä¸ºæ­£çš„å›¾ï¼Œä»»æ„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ï¼š

- ä¸ä¼šç»è¿‡é‡å¤çš„ç»“ç‚¹ã€‚
- ä¸ä¼šç»è¿‡é‡å¤çš„è¾¹ã€‚
- ç»“ç‚¹æ•°ä¸è¶…è¿‡ n ï¼Œè¾¹æ•°ä¸ä¼šè¶…è¿‡ n - 1ã€‚

**å•æºæœ€çŸ­è·¯**ï¼šæŒ‡å®šæºç‚¹ï¼Œæ±‚å®ƒåˆ°å…¶ä½™å„ä¸ªç»“ç‚¹çš„æœ€çŸ­è·¯ã€‚

### LeetCode 743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´

[743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´](https://leetcode-cn.com/problems/network-delay-time/)

æœ‰ N ä¸ªç½‘ç»œèŠ‚ç‚¹ `1 ~ N`ã€‚ç»™å®šåˆ—è¡¨ timesï¼Œè¡¨ç¤ºä¿¡å·ç»è¿‡æœ‰å‘è¾¹çš„ä¼ é€’æ—¶é—´ã€‚ `times[i] = (u, v, w)`ï¼Œå…¶ä¸­ u æ˜¯æºèŠ‚ç‚¹ï¼Œv æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œ w æ˜¯ä¸€ä¸ªä¿¡å·ä»æºèŠ‚ç‚¹ä¼ é€’åˆ°ç›®æ ‡èŠ‚ç‚¹çš„æ—¶é—´ã€‚

ä»èŠ‚ç‚¹ K å‘é€ä¿¡å·ï¼Œå¤šä¹…æ‰èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹éƒ½æ”¶åˆ°ä¿¡å·ï¼Ÿå¦‚æœä¸èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹æ”¶åˆ°ä¿¡å·ï¼Œè¿”å› -1ã€‚

### æ·±åº¦ä¼˜å…ˆç®—æ³• DFS

æµç¨‹ï¼š

- ä½¿ç”¨æ•°ç»„ä¿å­˜åˆ°è¾¾æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å°è€—æ—¶ã€‚åˆå§‹åŒ–æ—¶èŠ‚ç‚¹ K è€—æ—¶ä¸º0ï¼Œå…¶ä»–èŠ‚ç‚¹å‡ä¸º `-1`ï¼Œè¡¨ç¤ºæœªè®¿é—®ã€‚
- ä»èŠ‚ç‚¹ K å¼€å§‹æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚æ¯å½“é‡åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸”èŠ‚ç‚¹**æœªè®¿é—®** æˆ– **æ–°çš„æ—¶é—´å°äºèŠ‚ç‚¹ä¿å­˜çš„æ—¶é—´**ï¼Œå°±æ›´æ–°è¿™ä¸ªèŠ‚ç‚¹çš„æ—¶é—´ï¼ˆä¸€æ–¹é¢ä¸éœ€è¦æ›´æ–°ä¸ºæ›´å¤§çš„æ—¶é—´ï¼Œå¦ä¸€æ–¹é¢é¿å…é‡åˆ°ç¯ï¼Œå¯¼è‡´æ­»å¾ªç¯ï¼‰ã€‚
- éå†èŠ‚ç‚¹æ—¶é—´æ•°ç»„ï¼Œå¦‚æœä»æœ‰æœªè®¿é—®çš„èŠ‚ç‚¹ï¼Œè¯´æ˜ä»èŠ‚ç‚¹ K åˆ°è¯¥èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› `-1`ï¼›å¦åˆ™è¿”å›æ•°ç»„ä¸­çš„æœ€å¤§å€¼ã€‚

ä½¿ç”¨DFSè§£é¢˜ï¼ˆ489 msï¼‰ï¼Œæ€§èƒ½å¾ˆå·®ã€‚

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // time[i]: node [i] receive time
        int[] time = new int[N+1];
        Arrays.fill(time, -1);
        time[K] = 0;

        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] t : times) {
            int from = t[0], to = t[1], w = t[2];
            graph[from].add(new int[]{to, w});
        }

        dfs(graph, time, K);

        int max = -1;
        for (int i = 1; i <= N; ++i) {
            if (time[i] == -1) return -1;
            max = Math.max(max, time[i]);
        }
        return max;
    }

    public void dfs(List<int[]>[] graph, int[] time, int node) {
        for (int[] t : graph[node]) {
            int to = t[0], w = t[1];
            int newTime = time[node] + w;
            if (time[to] != -1 && newTime >= time[to]) {
                continue;
            }
            time[to] = newTime;
            dfs(graph, time, to);
        }
    }
}
```

### å¼—æ´›ä¼Šå¾·ç®—æ³• Floyd-Warshall Algorithm

ç‰¹ç‚¹ï¼š

- å¯ä»¥æ±‚ä»»æ„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ã€‚
- å¤æ‚åº¦è¾ƒé«˜ï¼Œä½†å®¹æ˜“å®ç°ã€‚
- é€‚ç”¨äºä»»ä½•å›¾ï¼Œä¸ç®¡æœ‰å‘æ— å‘ï¼Œè¾¹æƒæ­£è´Ÿï¼Œä½†æ˜¯æœ€çŸ­è·¯å¿…é¡»å­˜åœ¨ï¼ˆä¸èƒ½æœ‰ä¸ªè´Ÿç¯ï¼‰ã€‚

æ€è·¯ï¼š

- ä½¿ç”¨çŸ©é˜µè¡¨ç¤ºèŠ‚ç‚¹ `u â†’ v` ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚
- åˆå§‹åŒ–æ—¶ï¼Œ`w[i][i]` ä¸º0ï¼Œ `w[i][j]` ä¸ºè¾¹ `i â†’ j` çš„æƒé‡ï¼Œæ²¡æœ‰è¾¹çš„å…ƒç´ è®¾ç½®ä¸ºæ— ç©·å¤§ã€‚
- èŠ‚ç‚¹ `i â†’ j` å¯èƒ½é€šè¿‡ `k` ä¸­è½¬è€Œç¼©çŸ­è·ç¦»ï¼Œéå†è®¡ç®—ç‚¹ `i â†’ k â†’ j` çš„è·¯å¾„ï¼Œå¦‚æœæ¯”ç°æœ‰çš„ `i â†’ j` å°ï¼Œåˆ™æ›´æ–°ï¼Œå³**æ¾å¼›**æ“ä½œã€‚

å¤æ‚åº¦ï¼š

- æ—¶é—´å¤æ‚åº¦ `O( N^3 )`
- ç©ºé—´å¤æ‚åº¦ `O( N^2 )`

ä½¿ç”¨Floydç®—æ³•æ±‚è§£ï¼ˆ18msï¼‰ã€‚

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
```

### è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• Dijkstra Algorithm

ç‰¹ç‚¹ï¼š

- æ±‚å•æºæœ€çŸ­è·¯å¾„ã€‚
- åªé€‚ç”¨äºéè´Ÿæƒå›¾ã€‚
- æ—¶é—´å¤æ‚åº¦ä¼˜ç§€ã€‚
- ä½¿ç”¨äº†è´ªå¿ƒæ€æƒ³ã€‚

æ­¥éª¤ï¼š

- åˆå§‹ï¼š
  - å·²ç¡®å®šæœ€çŸ­è·¯çš„èŠ‚ç‚¹ä¸ºé›†åˆPï¼Œæœªç¡®å®šæœ€çŸ­è·¯çš„èŠ‚ç‚¹ä¸ºé›†åˆQã€‚
  - ä¿å­˜æºèŠ‚ç‚¹ K åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»ï¼Œåˆå§‹åŒ–æ—¶è·ç¦»ä¸ºæ— ç©·å¤§ã€‚
  - å°†æºèŠ‚ç‚¹ K æ”¾å…¥Qï¼Œå…¶è·ç¦»ä¸º0ã€‚
- å¾ªç¯ï¼š
  - ä»Qå–å‡ºä¸€ä¸ªè·ç¦»æœ€çŸ­çš„èŠ‚ç‚¹ uï¼Œå…¶æœ€çŸ­è·¯å¾„å·²ç»ç¡®å®šï¼Œå› æ­¤ç§»åˆ°Pï¼ˆè´ªå¿ƒæ€æƒ³ï¼Œå› ä¸º K åˆ°å…¶ä»–ç‚¹çš„è·ç¦»æ›´è¿œï¼Œä¸å¯èƒ½æ‰¾åˆ°ä¸€ä¸ªç»è¿‡å…¶ä»–ç‚¹å†åˆ° u çš„æ›´çŸ­è·¯å¾„ï¼‰ã€‚
  - æ¾å¼› u çš„**æœªç¡®å®šæœ€çŸ­è·¯çš„**å‡ºèŠ‚ç‚¹ï¼Œå³åˆ¤æ–­ç»è¿‡ u èƒ½å¦ç¼©çŸ­è·ç¦»ã€‚å°†è¿™äº›èŠ‚ç‚¹æ”¾åˆ°Qä¸­ç­‰å¾…ä¸‹ä¸€è½®å¾ªç¯å¤„ç†ã€‚
  - ç»§ç»­å¾ªç¯ï¼Œç›´åˆ°Qä¸ºç©ºã€‚

å…·ä½“å®ç°ï¼š

1. å¯ä»¥ç”¨ int æ•°ç»„ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»ï¼Œboolean æ•°ç»„è¡¨ç¤ºèŠ‚ç‚¹æ˜¯å¦å·²ç»åŠ å…¥åˆ°Pã€‚
2. ä¼˜åŒ–ï¼šJavaä¸­ä½¿ç”¨ `PriorityQueue` å®ç°Qï¼Œè¿™æ ·æ¯æ¬¡å–å‡ºè·ç¦»æœ€çŸ­èŠ‚ç‚¹æ—¶æ€§èƒ½æ›´å¥½ã€‚

å›¾è§£1ï¼Œæ¥è‡ª [ç»´åŸºç™¾ç§‘](https://zh.wikipedia.org/wiki/æˆ´å…‹æ–¯ç‰¹æ‹‰ç®—æ³•)ï¼š

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/Dijkstra_Animation.gif)

å›¾è§£2ï¼Œæ¥è‡ª [åšå®¢](https://www.cnblogs.com/thousfeet/p/9229395.html)ï¼š

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dijkstra.jpg)

å›¾è§£2çš„æ‰§è¡Œæ­¥éª¤åˆ†æï¼š

```
ç¬¬ä¸€è¡Œä¸ºèŠ‚ç‚¹ï¼Œç¬¬äºŒè¡Œä¸ºè·ç¦»ï¼Œ.è¡¨ç¤ºæ— ç©·å¤§âˆï¼ŒåŠ ä¸­æ‹¬å·è¡¨ç¤ºå·²ç»ç¡®å®šæœ€çŸ­è·¯å¾„

 1    2    3    4    5    6
 0    Â·    Â·    Â·    Â·    Â·
 â†‘                             é€‰1ï¼Œæ¾å¼›2ã€3

 1    2    3    4    5    6
[0]   1   12    Â·    Â·    Â·
      â†‘                        é€‰2ï¼Œæ¾å¼›3ã€4

 1    2    3    4    5    6
[0]  [1]  10    4    Â·    Â·
                â†‘              é€‰4ï¼Œæ¾å¼›3ã€5ã€6...
```

ä½¿ç”¨Dijkstraç®—æ³•æ±‚è§£ï¼ˆ24 msï¼‰ï¼š

```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
```

## å¹¶æŸ¥é›† Disjoint-set

æ•…äº‹ï¼š

> å‡ ä¸ªå®¶æ—è¿›è¡Œå®´ä¼šï¼Œä½†æ˜¯å®¶æ—æ™®éé•¿å¯¿ï¼Œæ‰€ä»¥äººæ•°ä¼—å¤šã€‚ç”±äºé•¿æ—¶é—´çš„åˆ†ç¦»ä»¥åŠå¹´é¾„çš„å¢é•¿ï¼Œè¿™äº›äººé€æ¸å¿˜æ‰äº†è‡ªå·±çš„äº²äººï¼Œåªè®°å¾—è‡ªå·±çš„çˆ¸çˆ¸æ˜¯è°äº†ï¼Œè€Œæœ€é•¿è€…ï¼ˆç§°ä¸ºã€Œç¥–å…ˆã€ï¼‰çš„çˆ¶äº²å·²ç»å»ä¸–ï¼Œä»–åªçŸ¥é“è‡ªå·±æ˜¯ç¥–å…ˆã€‚
>
> ä¸ºäº†ç¡®å®šè‡ªå·±æ˜¯å“ªä¸ªå®¶æ—ï¼Œä»–ä»¬æƒ³å‡ºäº†ä¸€ä¸ªåŠæ³•ï¼Œåªè¦é—®è‡ªå·±çš„çˆ¸çˆ¸æ˜¯ä¸æ˜¯ç¥–å…ˆï¼Œä¸€å±‚ä¸€å±‚çš„å‘ä¸Šé—®ï¼Œç›´åˆ°é—®åˆ°ç¥–å…ˆã€‚å¦‚æœè¦åˆ¤æ–­ä¸¤äººæ˜¯å¦åœ¨åŒä¸€å®¶æ—ï¼Œåªè¦çœ‹ä¸¤äººçš„ç¥–å…ˆæ˜¯ä¸æ˜¯åŒä¸€äººå°±å¯ä»¥äº†ã€‚

### åˆå§‹åŒ–

```
int[] parent = new int[n];

void init() {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}
```

### æŸ¥æ‰¾

```
int findRoot(int x) {
    int x_root = parent[x];
    while (x_root != x) {
        x_root = parent[x_root];
    }
    return x_root;
}
```

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dsu1.png)

### è·¯å¾„å‹ç¼©

æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼ŒåŒæ—¶æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ç›´æ¥è¿æ¥åˆ°æ ¹ä¸Šã€‚è¿™æ ·å¯ä»¥å¤§å¤§æé«˜æ•ˆç‡ã€‚

```
// è¿­ä»£å†™æ³•
int findRoot(int x) {
    while (parent[x] != x) {
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}

// é€’å½’å†™æ³•
int findRoot(int x) {
  if (x != parent[x])
    parent[x] = find(parent, parent[x]);
  return parent[x];
}
```

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dsu2.png)

### åˆå¹¶

> å®´ä¼šä¸Šï¼Œä¸€ä¸ªå®¶æ—çš„ç¥–å…ˆçªç„¶å¯¹å¦ä¸€ä¸ªå®¶æ—è¯´ï¼šæˆ‘ä»¬ä¸¤ä¸ªå®¶æ—äº¤æƒ…è¿™ä¹ˆå¥½ï¼Œä¸å¦‚åˆæˆä¸€å®¶å¥½äº†ã€‚å¦ä¸€ä¸ªå®¶æ—ä¹Ÿæ¬£ç„¶æ¥å—äº†ã€‚ç”±äºå¹¶ä¸åœ¨æ„ç¥–å…ˆç©¶ç«Ÿæ˜¯è°ï¼Œæ‰€ä»¥åªè¦å…¶ä¸­ä¸€ä¸ªç¥–å…ˆå˜æˆå¦ä¸€ä¸ªç¥–å…ˆçš„å„¿å­å°±å¯ä»¥äº†ã€‚

```
boolean union(int x, int y) {
    // x ä¸ y æ‰€åœ¨å®¶æ—åˆå¹¶
    x = find(x);
    y = find(y);
    if (x == y) {  // åŸæœ¬å°±åœ¨ä¸€ä¸ªå®¶æ—é‡Œå°±ä¸ç®¡äº†
        return false;
    }
    parent[x] = y;  // æŠŠ x çš„ç¥–å…ˆå˜æˆ y çš„ç¥–å…ˆçš„å„¿å­
    return true;
}
```

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dsu3.png)

### å¯å‘å¼åˆå¹¶ï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰

> ä¸€ä¸ªç¥–å…ˆçªç„¶æŠ–äº†ä¸ªæœºçµï¼šâ€œä½ ä»¬å®¶æ—äººæ¯”è¾ƒå°‘ï¼Œæ¬å®¶åˆ°æˆ‘ä»¬å®¶æ—é‡Œæ¯”è¾ƒæ–¹ä¾¿ï¼Œæˆ‘ä»¬è¦æ˜¯æ¬è¿‡å»çš„è¯å¤ªè´¹äº‹äº†ã€‚â€

è·¯å¾„å‹ç¼©æœ‰æ—¶ä¸é€‚ç”¨ï¼Œå¯ä»¥ç”¨å¯å‘å¼åˆå¹¶ã€‚

```
int[] rank = new int[n]; // initial value: 0

boolean union(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        return false;
    }
    if (rank[x] > rank[y]) {
        parent[x] = y;
    } else if (rank[x] < rank[y]) {
        parent[y] = x;
    } else {
        parent[x] = y;
        rank[y]++;
    }
    return true;
}
```

### å¹¶æŸ¥é›†åº”ç”¨

- **æ±‚è¿é€šåˆ†é‡**ï¼šä¾æ¬¡å¯¹æ¯ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹è¿›è¡Œå¹¶æŸ¥é›†åˆå¹¶ï¼Œå¯ä»¥ä½¿å¾—æ¯ä¸ªè¿é€šåˆ†é‡çš„rootç›¸åŒï¼Œä»è€Œå¾—å‡ºæ¯ä¸ªè¿é€šåˆ†é‡ã€‚
- **æŸ¥æ‰¾ç¯**ï¼šåˆå¹¶è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°ä¸€æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹å·²ç»åˆå¹¶è¿‡ï¼Œè¯´æ˜è¿™ä¸¤ä¸ªé¡¶ç‚¹ä¹‹å‰å·²ç»é€šè¿‡å…¶ä»–è·¯å¾„åˆå¹¶ï¼Œå†åŠ ä¸Šè¿™æ¡è¾¹ï¼Œå›¾ä¸­å°±å‡ºç°äº†ç¯ã€‚
- **æ±‚æœ€å°ç”Ÿæˆæ ‘**ï¼šè´ªå¿ƒæ€æƒ³ï¼Œä»å°åˆ°å¤§æ’åºæ‰€æœ‰è¾¹ï¼Œä½¿ç”¨å¹¶æŸ¥é›†ä¾æ¬¡åˆå¹¶ï¼Œå¹¶è·³è¿‡å½¢æˆç¯çš„è¾¹ï¼Œå³å¯å¾—åˆ°æœ€å°ç”Ÿæˆæ ‘ã€‚

### LeetCode 684. å†—ä½™è¿æ¥

[684. å†—ä½™è¿æ¥](https://leetcode-cn.com/problems/redundant-connection/)

è¾“å…¥ä¸€ä¸ª**æ— å‘å›¾**ï¼Œè¯¥å›¾ç”±æœ‰Nä¸ªèŠ‚ç‚¹çš„æ ‘åŠä¸€æ¡é™„åŠ çš„è¾¹æ„æˆã€‚è¿”å›ä¸€æ¡å¯ä»¥åˆ å»çš„è¾¹ï¼Œä½¿å¾—ç»“æœå›¾æ˜¯æœ‰Nä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚å¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œåˆ™è¿”å›äºŒç»´æ•°ç»„ä¸­æœ€åå‡ºç°çš„è¾¹ã€‚

#### åˆ†æ

- ä¾æ¬¡å¯¹æ¯ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹è¿›è¡Œå¹¶æŸ¥é›†åˆå¹¶ã€‚
- å½“é‡åˆ°ä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹å·²ç»åˆå¹¶è¿‡ï¼Œå‘ç°äº†ç¯ï¼Œè¿”å›è¿™æ¡è¾¹ã€‚
- è¾“å‡ºå‚æ•°åªæœ‰ `edges` è€Œæ²¡æœ‰Nã€‚å¯¹äºæœ‰ `N` ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œåº”è¯¥æœ‰ `N-1` æ¡è¾¹ï¼Œå†åŠ ä¸Šé™„åŠ çš„ä¸€æ¡è¾¹ï¼Œå¾—åˆ°Næ¡è¾¹ã€‚å› æ­¤ `edges` çš„sizeå³ä¸ºNã€‚

#### å›¾è§£

è¾“å…¥è¾¹ `[AB, AC, AE, CD, CF, EF]`ï¼Œ**åˆ æ‰ç¯è·¯ä¸­çš„æ¯ä¸ªè¾¹éƒ½å¯ä»¥ç»„æˆæ ‘**ï¼Œä¾‹å¦‚ACã€AEã€CFã€EFï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œå–æœ€åä¸€ä¸ªå³ EF å³å¯ã€‚

éå†è¿‡ç¨‹å¦‚ä¸‹ï¼š

- éå†ABï¼šåˆå¹¶AB
- éå†ACï¼šåˆå¹¶ABC
- éå†AEï¼šåˆå¹¶ABCE
- éå†CDï¼šåˆå¹¶ABCED
- éå†CFï¼šåˆå¹¶ABCEDF
- éå†EFï¼šå‘ç°èŠ‚ç‚¹ Eã€F å·²ç»åˆå¹¶è¿‡äº†ï¼ˆç»è¿‡ACã€AEã€CFåˆå¹¶ï¼‰ï¼Œè¯´æ˜æœ‰ç¯ï¼Œè¿”å›EFã€‚

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/redundant-connection.png)

#### ä»£ç 

```
class Solution {

    int[] parent;

    public int[] findRedundantConnection(int[][] edges) {
        // N = edges.length
        parent = new int[edges.length + 1];
        for (int i = 0; i < parent.length; ++i) {
            parent[i] = i;
        }
        for (int[] edge : edges) {
            if (!union(edge[0], edge[1])) {
                return edge;
            }
        }
        return new int[]{-1,-1};
    }

    public int findRoot(int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int x, int y) {
        x = findRoot(x);
        y = findRoot(y);
        if (x == y) {
            return false;
        }
        parent[x] = y;
        return true;
    }
}
```

## æœ€å°ç”Ÿæˆæ ‘

**æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼ŒMSTï¼‰**ï¼šæ— å‘è¿é€šå›¾ä¸­è¾¹æƒå’Œæœ€å°çš„ç”Ÿæˆæ ‘ï¼ˆæœ€çŸ­è·¯å¾„è¿æ¥æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

æ³¨æ„ï¼šåªæœ‰è¿é€šå›¾æ‰æœ‰ç”Ÿæˆæ ‘ï¼Œè€Œå¯¹äºéè¿é€šå›¾ï¼Œåªå­˜åœ¨ç”Ÿæˆæ£®æ—ã€‚

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/mst.jpg)

### LeetCode 1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚

[1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/)

- åœ°å›¾ä¸Šæœ‰ N åº§åŸå¸‚ `1 ~ N`ã€‚
- ç»™å‡ºä¸€äº› `conections`ï¼Œå…¶ä¸­ `conections[i] = [city1, city2, cost]` è¡¨ç¤ºå°†åŸå¸‚ `city1` å’ŒåŸå¸‚ `city2` è¿æ¥æ‰€è¦çš„æˆæœ¬ï¼Œè¿æ¥æ˜¯åŒå‘çš„ã€‚
- è¿”å›è¿æ¥æ‰€æœ‰åŸå¸‚çš„æœ€å°æˆæœ¬ï¼Œå¦‚æœæ— æ³•è¿æ¥æ‰€æœ‰åŸå¸‚ï¼Œè¿”å› `-1`ã€‚

### Kruskalç®—æ³•

Kruskalç®—æ³• = è´ªå¿ƒ + å¹¶æŸ¥é›†

æµç¨‹ï¼šå°†æ‰€æœ‰è¾¹æŒ‰costä»å°åˆ°å¤§æ’åºï¼Œç„¶åä½¿ç”¨å¹¶æŸ¥é›†ä¾æ¬¡å°è¯•åˆå¹¶æ¯ä¸ªè¾¹ï¼š

- å¦‚æœåˆå¹¶æˆåŠŸï¼Œåˆ™åŠ å…¥è¿™æ¡è¾¹ã€‚
- å¦‚æœåˆå¹¶å¤±è´¥ï¼ˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åˆå¹¶è¿‡ï¼‰ï¼Œè¯´æ˜äº§ç”Ÿäº†ç¯ï¼Œåˆ™ä¸¢å¼ƒè¿™æ¡è¾¹ã€‚

é€šè¿‡å¹¶æŸ¥é›†åˆå¹¶åï¼Œæ¯ä¸ªè¿é€šåˆ†é‡èŠ‚ç‚¹éƒ½ä¼šæœ‰ç›¸åŒçš„rootï¼Œå› æ­¤æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹çš„rootï¼š

- å¦‚æœæ£€æŸ¥åˆ°åªæœ‰ä¸€ä¸ªrootï¼Œè¯´æ˜è¿™ä¸ªå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œæ˜¯è¿é€šå›¾ï¼Œè¿”å›costã€‚
- å¦‚æœæ£€æŸ¥åˆ°è¶…è¿‡ä¸€ä¸ªrootï¼Œè¯´æ˜è¿™ä¸ªå›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼Œä¸æ˜¯ä¸€ä¸ªè¿é€šå›¾ï¼Œè¿”å›-1ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
```

### Primç®—æ³•

Kruskalç®—æ³•æ¯æ¬¡æ·»åŠ ä¸€ä¸ªæœ€å°çš„è¾¹ï¼Œè€ŒPrimç®—æ³•åˆ™æ˜¯æ¯æ¬¡æ·»åŠ ä¸€ä¸ªè·ç¦»å·²é€‰å–èŠ‚ç‚¹é›†æœ€è¿‘çš„ç‚¹ã€‚

æµç¨‹ï¼š

1. é›†åˆSè¡¨ç¤ºå·²é€‰å–çš„èŠ‚ç‚¹é›†ã€‚
2. é€‰ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºèµ·å§‹èŠ‚ç‚¹ `a`ï¼Œæ”¾åˆ°é›†åˆSä¸­ï¼Œå¹¶æ›´æ–°å…¶ä»–èŠ‚ç‚¹åˆ°é›†åˆSçš„æœ€è¿‘è·ç¦»ã€‚å› ä¸ºå½“å‰Sä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ `a`ï¼Œå› æ­¤æ›´æ–°ä¸ºåˆ°èŠ‚ç‚¹ `a` çš„è·ç¦»ã€‚
3. é€‰å–è·ç¦»Sæœ€è¿‘çš„ä¸€ä¸ªèŠ‚ç‚¹ `b`ï¼Œæ”¾åˆ°é›†åˆSä¸­ï¼Œå¹¶æ›´æ–°å…¶ä»–èŠ‚ç‚¹åˆ°é›†åˆSçš„æœ€è¿‘è·ç¦»ã€‚ä¹Ÿå°±æ˜¯èŠ‚ç‚¹ `i` çš„è·ç¦»æ›´æ–°ä¸º `min { adj[a][i], adj[b][i] }`ã€‚
4. ç»§ç»­é€‰å–ã€æ›´æ–°ï¼Œç›´åˆ°Nä¸ªèŠ‚ç‚¹éƒ½è¢«é€‰å–ã€‚

å®é™…æäº¤å‘ç°ï¼ŒPrimç®—æ³•æ•ˆæœè¿œä¸å¦‚Kruskalå¥½ã€‚

- é¢˜ç›®ç»™çš„æ˜¯è¾¹ï¼ˆconnectionsï¼‰ï¼Œè€Œä½¿ç”¨Primç®—æ³•ï¼Œéœ€è¦å¿«é€Ÿå¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚å¦‚æœæ¯æ¬¡éƒ½ç›´æ¥éå†connectionsï¼Œå¤æ‚åº¦å¤ªé«˜ï¼Œå› æ­¤éœ€è¦å…ˆè½¬æ¢æˆé‚»æ¥çŸ©é˜µæˆ–é‚»æ¥è¡¨ã€‚é€‰æ‹©åˆé€‚çš„é‚»æ¥çŸ©é˜µæˆ–é‚»æ¥è¡¨ï¼Œæ˜¯è§£å†³æœ¬é¢˜çš„ä¸€ä¸ªå…³é”®ã€‚
- å¦å¤–ä¸€ä¸ªå…³é”®ç‚¹å°±æ˜¯ï¼Œè·å–è·ç¦»æœ€å°çš„èŠ‚ç‚¹ï¼Œå¯ä»¥ç›´æ¥éå†ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ© `PriorityQueue` å®ç°ã€‚

#### è§£æ³•1ï¼šè¶…å‡ºå†…å­˜é™åˆ¶

æœ€åŸºç¡€çš„Primç®—æ³•å®ç°ï¼Œä½¿ç”¨äºŒç»´æ•°ç»„ä¿å­˜é‚»æ¥çŸ©é˜µï¼Œæš´åŠ›æœç´¢æŸ¥æ‰¾è·ç¦»æœ€å°çš„èŠ‚ç‚¹ã€‚

ä»£ç åº”è¯¥æ˜¯æ­£ç¡®çš„ï¼Œåœ¨ç®€å•çš„æµ‹è¯•ç”¨ä¾‹ä¸­è¿è¡Œæ˜¯æ­£ç¡®çš„ã€‚ä½†æ˜¯ç”±äºé‚»æ¥çŸ©é˜µå¤ªå¤§ï¼Œå¯¼è‡´è¶…å‡ºäº†å†…å­˜é™åˆ¶ï¼Œæäº¤æœªé€šè¿‡ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
```

#### è§£æ³•2ï¼šè¶…å‡ºæ—¶é—´é™åˆ¶

ä¼˜åŒ–Primç®—æ³•ï¼Œä½¿ç”¨HashMapæ•°ç»„ä¿å­˜é¢†æ¥è¡¨ï¼Œå€ŸåŠ©PriorityQueueé€‰å–è·ç¦»æœ€å°çš„èŠ‚ç‚¹ã€‚

è¶…å‡ºæ—¶é—´é™åˆ¶ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph[i].get(j):
        //     x: distance
        //     null: not reachable
        Map<Integer, Integer>[] graph = new HashMap[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new HashMap<>();
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u].put(v, w);
            graph[v].put(u, w);
        }

        // heap: candidates
        //     int[0]: distance from added nodes
        //     int[1]: node
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[0] - b[0]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{0, 1});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int dist = min[0];
            int node = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            for (int i = 2; i <= N; ++i) {
                if (added[i]) continue;
                Integer d = graph[node].get(i);
                if (d != null) { // d == null: not reachable
                    heap.offer(new int[]{d, i});
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[1];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

#### è§£æ³•3ï¼šé€šè¿‡ï¼Œ67 ms

æ­£åœ¨æ€€ç–‘æ˜¯ä¸æ˜¯è‡ªå·±å†™é”™äº†Primç®—æ³•çš„æ—¶å€™ï¼Œå€Ÿé‰´äº†è¯„è®ºåŒºçš„æ€è·¯ï¼Œé‡æ–°ä¼˜åŒ–äº†é‚»æ¥è¡¨çš„è¡¨ç¤ºæ–¹æ³•ï¼Œä½¿ç”¨ `HashMap -> List -> int[]` çš„å½¢å¼ã€‚

è¿™æ ·åœ¨æ›´æ–°è·ç¦»æ—¶ï¼Œä¸éœ€è¦å†è¿›è¡Œå¤æ‚çš„éå†ï¼Œä¹Ÿä¸éœ€è¦åˆ›å»ºå¾ˆå¤šæ•°ç»„ï¼ˆHashMapé‚»æ¥è¡¨å’ŒPriorityQueueä¸­çš„å…ƒç´ æ ¼å¼æ˜¯ç›¸åŒçš„ï¼Œéƒ½æ˜¯ `[node, distance]`ï¼‰ï¼Œå¤§å¤§æé«˜äº†æ€§èƒ½ã€‚

ç»ˆäºæäº¤é€šè¿‡ï¼Œè€—æ—¶67msã€‚ä½œä¸ºå¯¹æ¯”ï¼ŒKruskalç®—æ³•çš„è€—æ—¶æ˜¯27msï¼Œä¸”å†™èµ·æ¥æ›´å®¹æ˜“ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph.get(i).get(x):
        //     int[0]: node
        //     int[1]: distance from [i] to [node]
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            List<int[]> list1 = graph.get(u);
            if (list1 == null) {
                list1 = new LinkedList<>();
                graph.put(u, list1);
            }
            list1.add(new int[]{v,w});

            List<int[]> list2 = graph.get(v);
            if (list2 == null) {
                list2 = new LinkedList<>();
                graph.put(v, list2);
            }
            list2.add(new int[]{u,w});
        }

        // heap: candidates
        //     int[0]: node
        //     int[1]: distance from one of added nodes
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[1] - b[1]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{1, 0});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int node = min[0];
            int dist = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            List<int[]> list = graph.get(node);
            if (list != null) {
                for (int[] e : list) {
                    heap.offer(e);
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[0];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

## äºŒåˆ†å›¾ Bipartite graph

**äºŒåˆ†å›¾ (Bipartite graph)**ï¼šèŠ‚ç‚¹ç”±ä¸¤ä¸ªé›†åˆç»„æˆï¼Œä¸”ä¸¤ä¸ªé›†åˆå†…éƒ¨æ²¡æœ‰è¾¹çš„å›¾ï¼ˆæˆ–è€…è¯´æ‰€æœ‰è¾¹çš„ä¸¤ä¸ªç‚¹åˆšå¥½åˆ†åˆ«åœ¨ä¸¤ä¸ªé›†åˆä¸­ï¼‰ã€‚

**å®Œå…¨äºŒåˆ†å›¾ (Complete bipartite graph / Biclique)**ï¼šä»»ä½•ä¸¤ä¸ªä¸åœ¨åŒä¸€éƒ¨åˆ†çš„ç‚¹ä¹‹é—´éƒ½æœ‰è¿è¾¹ï¼ˆä¾‹å¦‚ä¸¤éƒ¨åˆ†åˆ†åˆ«æœ‰ `x,y` ä¸ªç‚¹ï¼Œåˆ™å›¾æ€»å…±æœ‰`x*y`ä¸ªè¾¹ï¼‰

æ€§è´¨ï¼š

- å¦‚æœä¸¤ä¸ªé›†åˆä¸­çš„ç‚¹åˆ†åˆ«æŸ“æˆé»‘è‰²å’Œç™½è‰²ï¼Œå¯ä»¥å‘ç°äºŒåˆ†å›¾ä¸­çš„æ¯ä¸€æ¡è¾¹éƒ½ä¸€å®šæ˜¯è¿æ¥ä¸€ä¸ªé»‘è‰²ç‚¹å’Œä¸€ä¸ªç™½è‰²ç‚¹ã€‚

- äºŒåˆ†å›¾ä¸å­˜åœ¨å¥‡ç¯ï¼ˆé•¿åº¦ä¸ºå¥‡æ•°çš„ç¯ï¼‰ã€‚

  > å› ä¸ºæ¯ä¸€æ¡è¾¹éƒ½æ˜¯ä»ä¸€ä¸ªé›†åˆèµ°åˆ°å¦ä¸€ä¸ªé›†åˆï¼Œåªæœ‰èµ°å¶æ•°æ¬¡æ‰å¯èƒ½å›åˆ°åŒä¸€ä¸ªé›†åˆã€‚

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/bi-graph.png)

### LeetCode 785. åˆ¤æ–­äºŒåˆ†å›¾

[785. åˆ¤æ–­äºŒåˆ†å›¾](https://leetcode-cn.com/problems/is-graph-bipartite/)

ä»¥äºŒç»´æ•°ç»„å½¢å¼çš„é‚»æ¥è¡¨æ–¹å¼ç»™å‡ºæ— å‘å›¾ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºäºŒåˆ†å›¾ã€‚

æ€è·¯ï¼š

1. å¯¹èŠ‚ç‚¹è¿›è¡Œç€è‰²ï¼Œ`color == 0` è¡¨ç¤ºæœªç€è‰²ï¼Œ`color == 1` æˆ– `color == -1`è¡¨ç¤ºç€è‰²ã€‚
2. ä»æ¯ä¸ªæœªç€è‰²çš„èŠ‚ç‚¹å¼€å§‹ï¼Œå°†å…¶ç€è‰²ï¼Œå¹¶è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆæ¯æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢éƒ½ä¼šéå†å®Œä¸€ä¸ªè¿é€šåˆ†é‡ï¼‰ã€‚
3. æ¯é‡åˆ°ä¸€æ¡è¾¹ï¼Œåˆ¤æ–­å…¶å¦ä¸€ä¸ªç‚¹çš„é¢œè‰²ï¼š
   - å¦‚æœæ²¡æœ‰ç€è‰²ï¼Œå°±è®¾ç½®æˆç›¸åçš„é¢œè‰²ï¼Œå¹¶ç»§ç»­æ·±å…¥æœç´¢ã€‚
   - å¦‚æœå·²ç»ç€è‰²ï¼Œå¹¶ä¸”å’Œå½“å‰ç‚¹é¢œè‰²ç›¸åŒï¼Œè¯´æ˜ä¸æ˜¯äºŒåˆ†å›¾ã€‚
   - å¦‚æœå·²ç»ç€è‰²ï¼Œå¹¶ä¸”å’Œå½“å‰ç‚¹é¢œè‰²ä¸åŒï¼Œå¿½ç•¥ï¼ˆç»§ç»­å¾ªç¯ï¼‰ã€‚

ä»£ç ï¼š

```
class Solution {
    public boolean isBipartite(int[][] graph) {
        // 0: uncolored.  1,-1: two oppsite colors
        int[] colors = new int[graph.length];
        for (int i = 0; i < graph.length; ++i) {
            // skip already colored node
            if (colors[i] != 0) continue;
            // set color to 1
            colors[i] = 1;
            // dfs, visit connected components
            if (!dfs(graph, colors, i)) return false;
        }
        return true;
    }

    public boolean dfs(int[][] graph, int[] colors, int node) {
        int color = colors[node];
        int[] nodes = graph[node];
        for (int n : nodes) {
            // found uncolored node, set color to oppsite and search deep
            if (colors[n] == 0) {
                colors[n] = -color;
                if (!dfs(graph, colors, n)) {
                    return false;
                }
            }
            // found node with same color, return false
            if (colors[n] == color) {
                return false;
            }
            // found node with oppsite color, loop continue
        }
        return true;
    }
}
```

