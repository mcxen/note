# å›¾è®ºåŸºç¡€çŸ¥è¯†ã€å¸¸ç”¨ç®—æ³•ä¸LeetCodeé¢˜è§£

## åŸºæœ¬æ¦‚å¿µ

**å›¾ (Graph)** æ˜¯ç”±è‹¥å¹²ç»™å®šçš„é¡¶ç‚¹åŠè¿æ¥ä¸¤é¡¶ç‚¹çš„è¾¹æ‰€æ„æˆçš„å›¾å½¢ï¼Œè¿™ç§å›¾å½¢é€šå¸¸ç”¨æ¥æè¿°æŸäº›äº‹ç‰©ä¹‹é—´çš„æŸç§ç‰¹å®šå…³ç³»ã€‚é¡¶ç‚¹ç”¨äºä»£è¡¨äº‹ç‰©ï¼Œè¿æ¥ä¸¤é¡¶ç‚¹çš„è¾¹åˆ™ç”¨äºè¡¨ç¤ºä¸¤ä¸ªäº‹ç‰©é—´å…·æœ‰è¿™ç§å…³ç³»ã€‚

ä½¿ç”¨ `G(V, E)` è¡¨ç¤ºä¸€ä¸ªå›¾ï¼ŒVä¸ºé¡¶ç‚¹(Vertex)ï¼ŒEä¸ºè¾¹(Edge)ã€‚å›¾ä¸­**ä¸å…è®¸æ²¡æœ‰é¡¶ç‚¹**ï¼Œä½†æ˜¯å¯ä»¥æ²¡æœ‰è¾¹ã€‚

### æœ‰é™å›¾ä¸æ— é™å›¾

**æœ‰é™å›¾**ï¼šV, E éƒ½æ˜¯æœ‰é™é›†åˆã€‚

**æ— é™å›¾**ï¼šV æˆ– E æ˜¯æ— é™é›†åˆã€‚

### æœ‰å‘å›¾ä¸æ— å‘å›¾

**æ— å‘å›¾ (Undirected graph)**ï¼šæ¯ä¸ªè¾¹éƒ½æ˜¯æ— å‘è¾¹ã€‚

```
e = (u, v)
```

- eï¼š**æ— å‘è¾¹ (Undirected edge)**ï¼Œç®€ç§° **è¾¹ (Edge)**
- u, vï¼šeçš„ **ç«¯ç‚¹ (Endpoint)**

**æœ‰å‘å›¾ (Directed graph)**ï¼šæ¯ä¸ªè¾¹éƒ½æ˜¯æœ‰å‘è¾¹ã€‚

```
e = u -> v
```

- eï¼š**æœ‰å‘è¾¹ (Directed edge)** ï¼Œç®€ç§°**å¼§ (Arc)** æˆ– **è¾¹ (Edge)**
- uï¼še çš„ **èµ·ç‚¹ (Tail)**
- vï¼še çš„ **ç»ˆç‚¹ (Head)**
- u, vï¼šeçš„ **ç«¯ç‚¹ (Endpoint)**
- u æ˜¯ v çš„**ç›´æ¥å‰é©±**ï¼Œv æ˜¯ u çš„**ç›´æ¥åç»§**

> ä¸ºä»€ä¹ˆèµ·ç‚¹æ˜¯ Tailï¼Œç»ˆç‚¹æ˜¯ Headï¼Ÿ
> æœ‰å‘è¾¹é€šå¸¸ç”¨ç®­å¤´è¡¨ç¤ºï¼Œè€Œç®­å¤´æ˜¯ä»â€œå°¾â€æŒ‡å‘â€œå¤´â€çš„ã€‚

**æ··åˆå›¾ (Mixed graph)**ï¼šæ—¢æœ‰æœ‰å‘è¾¹ï¼Œåˆæœ‰æ— å‘è¾¹ã€‚

### ç›¸é‚»

**å…³è”ï¼ˆIncident)**ï¼šé¡¶ç‚¹ v æ˜¯è¾¹ e çš„ä¸€ä¸ªç«¯ç‚¹ï¼Œåˆ™ç§° e å’Œ v å…³è” æˆ– ç›¸é‚»ã€‚

**é‚»æ¥ / ç›¸é‚»ï¼ˆAdjacentï¼‰**ï¼šé¡¶ç‚¹uå’Œvï¼Œè‹¥å­˜åœ¨è¾¹ `(uï¼Œv)`ï¼Œåˆ™ç§°uå’Œvæ˜¯é‚»æ¥æˆ–ç›¸é‚»çš„ã€‚

**é‚»åŸŸ (Neighborhood)** ï¼š

- é¡¶ç‚¹ vï¼šæ‰€æœ‰ä¸é¡¶ç‚¹ v ç›¸é‚»çš„é¡¶ç‚¹é›†åˆï¼Œè®°ä½œ `N(v)`ã€‚
- ç‚¹é›† Sï¼šä¸ S ä¸­è‡³å°‘ä¸€ä¸ªç‚¹ç›¸é‚»çš„é¡¶ç‚¹é›†åˆï¼Œè®°ä½œ `N(S)` ï¼Œ`N(S) = âˆª N(v), vâˆˆS`

### åº¦

**åº¦ï¼ˆdegreeï¼‰**ï¼šé¡¶ç‚¹ç›¸é‚»è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `deg(V)`, `d(v)` è¡¨ç¤ºã€‚

- å­¤ç«‹ç‚¹ (Isolated vertex) ï¼š `d(v) == 0`
- å¶èŠ‚ç‚¹ (Leaf vertex) / æ‚¬æŒ‚ç‚¹ (Pendant vertex) ï¼š `d(v) == 1`
- å¶ç‚¹ (Even vertex) ï¼š `d(v) % 2 == 0`
- å¥‡ç‚¹ (Odd vertex) ï¼š`d(v) % 2 == 1`ã€‚å¥‡ç‚¹çš„ä¸ªæ•°æ˜¯å¶æ•°ã€‚
- æ”¯é…ç‚¹ (Universal vertex) ï¼š`d(v) = V - 1`ï¼Œå’Œæ‰€æœ‰å…¶ä»–ç‚¹éƒ½ç›¸é‚»ã€‚

æœ‰å‘å›¾ä¸­ï¼š

- **å…¥åº¦ (In-degree)**ï¼šä»¥è¯¥é¡¶ç‚¹ä¸ºç»ˆç‚¹çš„è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `d+(v)` è¡¨ç¤ºã€‚
- **å‡ºåº¦ (Out-degree)**ï¼šä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹çš„è¾¹çš„æ•°ç›®ï¼Œå¸¸ç”¨ `d-(v)` è¡¨ç¤ºã€‚
- é¡¶ç‚¹çš„åº¦ = å…¥åº¦ + å‡ºåº¦ï¼Œå³ `d(v) = d+(v) + d-(v)`ã€‚

### è‡ªç¯ä¸é‡è¾¹

- è‡ªç¯ (Loop) ï¼šè¾¹ e çš„ä¸¤ä¸ªç«¯ç‚¹ç›¸åŒï¼Œåˆ™ e ç§°ä¸ºä¸€ä¸ªè‡ªç¯ã€‚
- é‡è¾¹ (Multiple edge) ï¼šä¸¤ä¸ªå®Œå…¨ç›¸åŒçš„è¾¹ï¼Œç§°ä½œï¼ˆä¸€ç»„ï¼‰é‡è¾¹ã€‚åœ¨æ— å‘å›¾ä¸­ `(u,v)` å’Œ`(v,u)` ç®—ä¸€ç»„é‡è¾¹ï¼Œè€Œåœ¨æœ‰å‘å›¾ä¸­ï¼Œ`u -> v` å’Œ `v -> u` ä¸ä¸ºé‡è¾¹ã€‚

### ç®€å•å›¾ä¸å¤šé‡å›¾

- ç®€å•å›¾ (Simple graph) ï¼šæ²¡æœ‰è‡ªç¯å’Œé‡è¾¹ã€‚éç©ºç®€å•å›¾ä¸­ä¸€å®šå­˜åœ¨åº¦ç›¸åŒçš„ç»“ç‚¹ã€‚
- å¤šé‡å›¾ (Multigraph) ï¼šæœ‰è‡ªç¯æˆ–é‡è¾¹ ã€‚

### è·¯å¾„

**é€”å¾„ (Walk) / é“¾ (Chain)**ï¼š`v0, e1, v1, e2, ... ek, vk`ï¼Œæˆ–ç®€å†™ä¸º `v0 â†’ v1 â†’ ... â†’ vk`

**è¿¹ (Trail)** ï¼šé“¾ï¼Œä¸”æ‰€æœ‰è¾¹éƒ½ä¸åŒã€‚

**è·¯å¾„ï¼ˆPathï¼‰/ ç®€å•è·¯å¾„ (Simple path)**ï¼šè¿¹ï¼Œä¸”æ‰€æœ‰ç‚¹éƒ½ä¸åŒï¼ˆé™¤äº†å…è®¸ `v0 == vk`ï¼‰ã€‚

**å›è·¯ (Circuit)** ï¼šè¿¹ï¼Œä¸” `v0 == vk`ã€‚

**ç¯ / åœˆ (Cycle) / ç®€å•å›è·¯ / ç®€å•ç¯ (Simple circuit)**ï¼šç®€å•è·¯å¾„ï¼Œä¸” `v0 == vk`ã€‚

### è¿é€š

æ— å‘å›¾

- **è¿é€šçš„ (Connected)** ï¼šä»é¡¶ç‚¹ u æœ‰è·¯å¾„åˆ°è¾¾ v ï¼Œåˆ™ `u,v` æ˜¯è¿é€šçš„ã€‚
- **è¿é€šå›¾ (Connected graph)**ï¼šä»»æ„ä¸¤ç‚¹è¿é€šã€‚
- **è¿é€šåˆ†é‡ / æå¤§è¿é€šå­å›¾ (Connected component)**ï¼šHæ˜¯Gçš„è¿é€šå­å›¾ï¼Œä¸”ä¸å­˜åœ¨è¿é€šå›¾Fï¼Œä½¿å¾— `H âŠŠ F âŠ† G`ï¼Œåˆ™Hæ˜¯Gçš„è¿é€šåˆ†é‡ã€‚

æ€§è´¨ï¼š

- è¿é€šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å›¾è‡ªèº«ã€‚
- éè¿é€šå›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ã€‚

æœ‰å‘å›¾

- **å¯è¾¾**ï¼šä»é¡¶ç‚¹ u æœ‰è·¯å¾„åˆ°è¾¾ v ï¼Œåˆ™ u å¯è¾¾ vã€‚
- **å¼ºè¿é€šçš„ (Strongly connected)**ï¼šæœ‰å‘å›¾ä¸­ï¼Œæ‰€æœ‰èŠ‚ç‚¹äº’ç›¸å¯è¾¾ã€‚
- **å¼±è¿é€šçš„ (Weakly connected)**ï¼šæœ‰å‘å›¾ä¸­ï¼Œè¾¹æ›¿æ¢ä¸ºæ— å‘è¾¹åå¯ä»¥å¾—åˆ°è¿é€šå›¾ï¼ˆä¹Ÿå°±æ˜¯æœ‰äº›èŠ‚ç‚¹åªèƒ½å•å‘å¯è¾¾ï¼‰ã€‚
- **å¼±è¿é€šåˆ†é‡ / æå¤§å¼±è¿é€šå­å›¾ (Weakly connected component)** ï¼Œ **å¼ºè¿é€šåˆ†é‡ / æå¤§å¼ºè¿é€šå­å›¾ (Strongly Connected component)**ï¼šä¸è¿é€šåˆ†é‡ç±»ä¼¼ã€‚

### ç¨€ç–å›¾ä¸ç¨ å¯†å›¾

ç¨€ç–å›¾ (Sparse graph)ï¼šè¾¹æ•°è¿œå°äºç‚¹æ•°çš„å¹³æ–¹ã€‚

ç¨ å¯†å›¾ (Dense graph) ï¼šè¾¹æ•°æ¥è¿‘ç‚¹æ•°çš„å¹³æ–¹ã€‚

### ç‰¹æ®Šçš„å›¾

**æ ‘ (Tree)** ï¼šä¸å«ç¯çš„æ— å‘è¿é€šå›¾ã€‚

**æ£®æ— (Forest)**ï¼šå¤šæ£µæ ‘å¯ä»¥ç»„æˆä¸€ä¸ª æ£®æ—ã€‚

**äºŒåˆ†å›¾ (Bipartite graph)**ï¼šå›¾çš„ç‚¹é›†åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæ¯ä¸€éƒ¨åˆ†çš„å†…éƒ¨éƒ½æ²¡æœ‰è¿è¾¹ï¼ˆæˆ–è€…è¯´æ‰€æœ‰è¾¹çš„ä¸¤ä¸ªç‚¹åˆšå¥½åˆ†åˆ«åœ¨ä¸¤éƒ¨åˆ†ä¸­ï¼‰ã€‚

**å®Œå…¨äºŒåˆ†å›¾ (Complete bipartite graph/Biclique)**ï¼šä»»ä½•ä¸¤ä¸ªä¸åœ¨åŒä¸€éƒ¨åˆ†çš„ç‚¹ä¹‹é—´éƒ½æœ‰è¿è¾¹ï¼ˆä¾‹å¦‚ä¸¤éƒ¨åˆ†åˆ†åˆ«æœ‰ `x,y` ä¸ªç‚¹ï¼Œåˆ™å›¾æ€»å…±æœ‰`x*y`ä¸ªè¾¹ï¼‰ã€‚

# ğŸŒŸå›¾çš„è¡¨ç¤º

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/0.jpg)

### Javaä»£ç å±•ç¤ºå›¾

å‚è€ƒï¼š

https://labuladong.online/algo/data-structure/graph-traverse/#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86



```java
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

å’Œæˆ‘ä»¬ä¹‹å‰è¯´çš„å¤šå‰æ ‘èŠ‚ç‚¹å‡ ä¹å®Œå…¨ä¸€æ ·ï¼š

```java
class TreeNode {
    int val;
    TreeNode[] children;
}
```

å›¾çœŸçš„æ²¡å•¥é«˜æ·±çš„ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸ªé«˜çº§ç‚¹çš„å¤šå‰æ ‘è€Œå·²ï¼Œé€‚ç”¨äºæ ‘çš„ DFS/BFS éå†ç®—æ³•ï¼Œå…¨éƒ¨é€‚ç”¨äºå›¾ã€‚

ä¸è¿‡å‘¢ï¼Œä¸Šé¢çš„è¿™ç§å®ç°æ˜¯**ã€Œé€»è¾‘ä¸Šçš„ã€ï¼Œå®é™…ä¸Šæˆ‘ä»¬å¾ˆå°‘ç”¨è¿™ä¸ª `Vertex` ç±»å®ç°å›¾ï¼Œè€Œæ˜¯ç”¨å¸¸è¯´çš„é‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µæ¥å®ç°ã€‚**

```java
List<Integer>[] graph;
boolean[][] matrix;
```

### é‚»æ¥è¡¨ Adjacency Table

ä½¿ç”¨ä¸€ä¸ªæ”¯æŒåŠ¨æ€å¢åŠ å…ƒç´ çš„æ•°æ®ç»“æ„æ„æˆçš„æ•°ç»„ï¼Œä¾‹å¦‚Javaä¸­çš„ `List[] adj`ã€‚

- **é¢†æ¥è¡¨**ä¸­ `adj[u]` å­˜å‚¨çš„æ˜¯ç‚¹ u æ‰€æœ‰å‡ºè¾¹çš„ä¿¡æ¯ï¼ˆç»ˆç‚¹ã€è¾¹æƒç­‰ï¼‰ã€‚
- **é€†é‚»æ¥è¡¨**ä¸­ `adj[u]` å­˜å‚¨çš„æ˜¯ç‚¹ u æ‰€æœ‰å…¥è¾¹çš„ä¿¡æ¯ï¼ˆèµ·ç‚¹ã€è¾¹æƒç­‰ï¼‰ã€‚

é‚»æ¥è¡¨å¾ˆç›´è§‚ï¼Œæˆ‘æŠŠæ¯ä¸ªèŠ‚ç‚¹ x çš„é‚»å±…éƒ½å­˜åˆ°ä¸€ä¸ªåˆ—è¡¨é‡Œï¼Œç„¶åæŠŠ x å’Œè¿™ä¸ªåˆ—è¡¨å…³è”èµ·æ¥ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ä¸€ä¸ªèŠ‚ç‚¹ x æ‰¾åˆ°å®ƒçš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ã€‚

### é‚»æ¥çŸ©é˜µ Adjacency Matrix

äºŒç»´æ•°ç»„ `adj[][]`ï¼Œ`adj[u][v]` ä¸º 1 è¡¨ç¤ºå­˜åœ¨ u åˆ° v çš„è¾¹ï¼Œä¸º 0 è¡¨ç¤ºä¸å­˜åœ¨ã€‚

å¦‚æœæ˜¯å¸¦è¾¹æƒçš„å›¾ï¼Œå¯ä»¥åœ¨ `adj[u][v]` ä¸­å­˜å‚¨ u åˆ° v çš„è¾¹çš„è¾¹æƒã€‚

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2.jpeg)

### é‚»æ¥çŸ©é˜µ\é‚»æ¥è¡¨åŒºåˆ«

é‚»æ¥çŸ©é˜µé‡Œé¢ç©ºç€é‚£ä¹ˆå¤šä½ç½®ï¼Œè‚¯å®šéœ€è¦æ›´å¤šçš„å­˜å‚¨ç©ºé—´ã€‚
ä½†æ˜¯ï¼Œé‚»æ¥è¡¨æ— æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸é‚»ã€‚
æ¯”å¦‚è¯´æˆ‘æƒ³åˆ¤æ–­èŠ‚ç‚¹ 1 æ˜¯å¦å’ŒèŠ‚ç‚¹ 3 ç›¸é‚»ï¼Œæˆ‘è¦å»é‚»æ¥è¡¨é‡Œ 1 å¯¹åº”çš„é‚»å±…åˆ—è¡¨é‡ŒæŸ¥æ‰¾ 3 æ˜¯å¦å­˜åœ¨ã€‚ä½†å¯¹äºé‚»æ¥çŸ©é˜µå°±ç®€å•äº†ï¼Œåªè¦çœ‹çœ‹ `matrix[1][3] `å°±çŸ¥é“äº†ï¼Œæ•ˆç‡é«˜ã€‚
æ‰€ä»¥è¯´ï¼Œä½¿ç”¨å“ªä¸€ç§æ–¹å¼å®ç°å›¾ï¼Œè¦çœ‹å…·ä½“æƒ…å†µã€‚

é‚»æ¥è¡¨çš„ä½¿ç”¨ä¼šæ›´é¢‘ç¹ä¸€äº›ï¼Œä¸»è¦æ˜¯å› ä¸ºæ“ä½œèµ·æ¥è¾ƒä¸ºç®€å•ï¼Œä½†è¿™ä¸æ„å‘³ç€é‚»æ¥çŸ©é˜µåº”è¯¥è¢«è½»è§†ã€‚çŸ©é˜µæ˜¯ä¸€ä¸ªå¼ºæœ‰åŠ›çš„æ•°å­¦å·¥å…·ï¼Œå›¾çš„ä¸€äº›éšæ™¦æ€§è´¨å¯ä»¥å€ŸåŠ©ç²¾å¦™çš„çŸ©é˜µè¿ç®—å±•ç°å‡ºæ¥ã€‚ä¸è¿‡æœ¬æ–‡ä¸å‡†å¤‡å¼•å…¥æ•°å­¦å†…å®¹ï¼Œæ‰€ä»¥æœ‰å…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œæœç´¢å­¦ä¹ ã€‚

### å›¾è®ºçš„åº¦

æœ€åï¼Œæˆ‘ä»¬å†æ˜ç¡®ä¸€ä¸ªå›¾è®ºä¸­ç‰¹æœ‰çš„åº¦ï¼ˆdegreeï¼‰çš„æ¦‚å¿µï¼Œåœ¨æ— å‘å›¾ä¸­ï¼Œã€Œåº¦ã€å°±æ˜¯æ¯ä¸ªèŠ‚ç‚¹ç›¸è¿çš„è¾¹çš„æ¡æ•°ã€‚
ç”±äºæœ‰å‘å›¾çš„è¾¹æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æœ‰å‘å›¾ä¸­æ¯ä¸ªèŠ‚ç‚¹ã€Œåº¦ã€è¢«ç»†åˆ†ä¸ºå…¥åº¦ï¼ˆindegreeï¼‰å’Œå‡ºåº¦ï¼ˆoutdegreeï¼‰ï¼Œæ¯”å¦‚ä¸‹å›¾ï¼š

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657368-60303c3a-360f-45f7-9e60-98b32887cb36.jpeg)

å…¶ä¸­èŠ‚ç‚¹ 3 çš„å…¥åº¦ä¸º 3ï¼ˆæœ‰ä¸‰æ¡è¾¹æŒ‡å‘å®ƒï¼‰ï¼Œå‡ºåº¦ä¸º 1ï¼ˆå®ƒæœ‰ 1 æ¡è¾¹æŒ‡å‘åˆ«çš„èŠ‚ç‚¹ï¼‰ã€‚
å¥½äº†ï¼Œå¯¹äºã€Œå›¾ã€è¿™ç§æ•°æ®ç»“æ„ï¼Œèƒ½çœ‹æ‡‚ä¸Šé¢è¿™äº›å°±ç»°ç»°å¤Ÿç”¨äº†ã€‚
é‚£ä½ å¯èƒ½ä¼šé—®ï¼Œæˆ‘ä»¬ä¸Šé¢è¯´çš„è¿™ä¸ªå›¾çš„æ¨¡å‹ä»…ä»…æ˜¯ã€Œæœ‰å‘æ— æƒå›¾ã€ï¼Œä¸æ˜¯è¿˜æœ‰ä»€ä¹ˆåŠ æƒå›¾ï¼Œæ— å‘å›¾ï¼Œç­‰ç­‰â€¦â€¦

å¦‚æœæ˜¯é‚»æ¥è¡¨ï¼Œæˆ‘ä»¬ä¸ä»…ä»…å­˜å‚¨æŸä¸ªèŠ‚ç‚¹ x çš„æ‰€æœ‰é‚»å±…èŠ‚ç‚¹ï¼Œè¿˜å­˜å‚¨ x åˆ°æ¯ä¸ªé‚»å±…çš„æƒé‡ï¼Œä¸å°±å®ç°åŠ æƒæœ‰å‘å›¾äº†å—ï¼Ÿ
å¦‚æœæ˜¯é‚»æ¥çŸ©é˜µï¼Œ`matrix[x][y] `ä¸å†æ˜¯å¸ƒå°”å€¼ï¼Œè€Œæ˜¯ä¸€ä¸ª int å€¼ï¼Œ0 è¡¨ç¤ºæ²¡æœ‰è¿æ¥ï¼Œå…¶ä»–å€¼è¡¨ç¤ºæƒé‡ï¼Œä¸å°±å˜æˆåŠ æƒæœ‰å‘å›¾äº†å—ï¼Ÿ

```java
List<int[]>[] graph;
int[][] matrix;
```

å¯ä»¥å‚è€ƒ 207.è¯¾ç¨‹è¡¨

```java
class Solution {
    boolean hasCycle = false;
    boolean[] onPath;
    boolean[] visited;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        int[] inDegrees = new int[numCourses];//å…¥åº¦è¡¨æ³•
        for (int i = 0; i < prerequisites.length; i++) {
            int from = prerequisites[i][1];
            int to = prerequisites[i][0];
            graph[from].add(to);//graph[s] æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå­˜å‚¨ç€èŠ‚ç‚¹ s æ‰€æŒ‡å‘çš„èŠ‚ç‚¹ã€‚
            inDegrees[to]++;
        }
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                queue.push(i);
            }
        }
        while (!queue.isEmpty()){
            Integer pop = queue.pop();
            numCourses--;
            for (Integer i : graph[pop]) {
                inDegrees[i]--;
                if (inDegrees[i]==0) queue.push(i);
            }
        }
        return numCourses==0;
    }

}
```



### å›¾çš„éå†-DFSå›¾

- æ·±åº¦ä¼˜å…ˆæœç´¢ (Depth-First Search, DFS)

![æ·±åº¦ä¼˜å…ˆæœç´¢](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/dfs.png)

å¤šå‰æ ‘çš„éå†ï¼š

```java
void traverse(TreeNode root) {
    if (root == null) return;
    
    for (TreeNode child : root.children) {
        traverse(child);
    }
    
}
```

å›¾å’Œå¤šå‰æ ‘æœ€å¤§çš„åŒºåˆ«æ˜¯ï¼Œ**å›¾æ˜¯å¯èƒ½åŒ…å«ç¯çš„**ï¼Œä½ ä»å›¾çš„æŸä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹éå†ï¼Œæœ‰å¯èƒ½èµ°äº†ä¸€åœˆåˆå›åˆ°è¿™ä¸ªèŠ‚ç‚¹ï¼Œè€Œæ ‘ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µï¼Œä»æŸä¸ªèŠ‚ç‚¹å‡ºå‘å¿…ç„¶èµ°åˆ°å¶å­èŠ‚ç‚¹ï¼Œç»ä¸å¯èƒ½å›åˆ°å®ƒè‡ªèº«ã€‚
æ‰€ä»¥ï¼Œå¦‚æœå›¾åŒ…å«ç¯ï¼Œ**éå†æ¡†æ¶å°±è¦ä¸€ä¸ª visited æ•°ç»„è¿›è¡Œè¾…åŠ©**ï¼š

```java
// è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹
boolean[] visited;
// è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
boolean[] onPath;

/* å›¾éå†æ¡†æ¶ */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå†
    visited[s] = true;
    // åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„
    onPath[s] = false;
}
```

æ³¨æ„ visited æ•°ç»„å’Œ onPath æ•°ç»„çš„åŒºåˆ«ï¼Œå› ä¸ºäºŒå‰æ ‘ç®—æ˜¯ç‰¹æ®Šçš„å›¾ï¼Œæ‰€ä»¥ç”¨éå†äºŒå‰æ ‘çš„è¿‡ç¨‹æ¥ç†è§£ä¸‹è¿™ä¸¤ä¸ªæ•°ç»„çš„åŒºåˆ«ï¼š

![image.jpg](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716695657880-80ddf295-ecfc-4d18-a7e7-b861bcc244da.gif)

ä¸Šè¿° GIF æè¿°äº†é€’å½’éå†äºŒå‰æ ‘çš„è¿‡ç¨‹ï¼Œåœ¨ visited ä¸­è¢«æ ‡è®°ä¸º true çš„èŠ‚ç‚¹ç”¨ç°è‰²è¡¨ç¤ºï¼Œåœ¨ onPath ä¸­è¢«æ ‡è®°ä¸º true çš„èŠ‚ç‚¹ç”¨ç»¿è‰²è¡¨ç¤ºï¼Œç±»æ¯”è´ªåƒè›‡æ¸¸æˆï¼Œvisited è®°å½•è›‡ç»è¿‡è¿‡çš„æ ¼å­ï¼Œè€Œ onPath ä»…ä»…è®°å½•è›‡èº«ã€‚åœ¨å›¾çš„éå†è¿‡ç¨‹ä¸­ï¼ŒonPath ç”¨äºåˆ¤æ–­æ˜¯å¦æˆç¯ï¼Œç±»æ¯”å½“è´ªåƒè›‡è‡ªå·±å’¬åˆ°è‡ªå·±ï¼ˆæˆç¯ï¼‰çš„åœºæ™¯ï¼Œè¿™ä¸‹ä½ å¯ä»¥ç†è§£å®ƒä»¬äºŒè€…çš„åŒºåˆ«äº†å§ã€‚

å¦‚æœè®©ä½ å¤„ç†è·¯å¾„ç›¸å…³çš„é—®é¢˜ï¼Œè¿™ä¸ª onPath å˜é‡æ˜¯è‚¯å®šä¼šè¢«ç”¨åˆ°çš„ï¼Œæ¯”å¦‚ [æ‹“æ‰‘æ’åº](https://labuladong.online/algo/data-structure/topological-sort/) ä¸­å°±æœ‰è¿ç”¨ã€‚
 onPath æ•°ç»„çš„æ“ä½œåšã€Œåšé€‰æ‹©ã€å’Œã€Œæ’¤é”€é€‰æ‹©ã€ï¼ŒåŒºåˆ«åœ¨äºä½ç½®ï¼š**å›æº¯ç®—æ³•çš„ã€Œåšé€‰æ‹©ã€å’Œã€Œæ’¤é”€é€‰æ‹©ã€åœ¨ for å¾ªç¯é‡Œé¢**ï¼ŒDFS**å¯¹ onPath æ•°ç»„çš„æ“ä½œåœ¨ for å¾ªç¯å¤–é¢ã€‚**
ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªåŒºåˆ«å‘¢ï¼Ÿå›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„åŒºåˆ«æ‰€åœ¨ï¼šå›æº¯ç®—æ³•å…³æ³¨çš„ä¸æ˜¯èŠ‚ç‚¹ï¼Œè€Œæ˜¯æ ‘æã€‚

```java
// DFS ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨èŠ‚ç‚¹
void traverse(TreeNode root) {
    if (root == null) return;
    printf("è¿›å…¥èŠ‚ç‚¹ %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("ç¦»å¼€èŠ‚ç‚¹ %s", root);
}

// å›æº¯ç®—æ³•ï¼Œå…³æ³¨ç‚¹åœ¨æ ‘æ
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // åšé€‰æ‹©
        printf("ä» %s åˆ° %s", root, child);
        backtrack(child);
        // æ’¤é”€é€‰æ‹©
        printf("ä» %s åˆ° %s", child, root);
    }
}
```

æ‰€ä»¥å¯¹äºè¿™é‡Œã€Œå›¾ã€çš„éå†ï¼Œæˆ‘ä»¬åº”è¯¥ç”¨ DFS ç®—æ³•ï¼Œå³æŠŠ `onPath` çš„æ“ä½œæ”¾åˆ° for å¾ªç¯å¤–é¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è®°å½•èµ·å§‹ç‚¹çš„éå†ã€‚



- å¹¿åº¦ä¼˜å…ˆæœç´¢ (Breadth-First Search, BFS)

![å¹¿åº¦ä¼˜å…ˆæœç´¢](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/bfs.png)



## å›¾çš„éå†é—®é¢˜

### 797.æ‰€æœ‰å¯èƒ½è·¯å¾„

é¢˜ç›®è¾“å…¥ä¸€å¹…**æœ‰å‘æ— ç¯å›¾**ï¼Œè¿™ä¸ªå›¾åŒ…å« `n` ä¸ªèŠ‚ç‚¹ï¼Œæ ‡å·ä¸º `0, 1, 2,..., n - 1`ï¼Œè¯·ä½ è®¡ç®—æ‰€æœ‰ä»èŠ‚ç‚¹ `0` åˆ°èŠ‚ç‚¹ `n - 1` çš„è·¯å¾„ã€‚

è¾“å…¥çš„è¿™ä¸ª `graph` å…¶å®å°±æ˜¯ã€Œé‚»æ¥è¡¨ã€è¡¨ç¤ºçš„ä¸€å¹…å›¾ï¼Œ`graph[i]` å­˜å‚¨è¿™èŠ‚ç‚¹ `i` çš„æ‰€æœ‰é‚»å±…èŠ‚ç‚¹ã€‚

æ¯”å¦‚è¾“å…¥ `graph = [[1,2],[3],[3],[]]`ï¼Œå°±ä»£è¡¨ä¸‹é¢è¿™å¹…å›¾ï¼š

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1.jpg)

ç®—æ³•åº”è¯¥è¿”å› `[[0,1,3],[0,2,3]]`ï¼Œå³ `0` åˆ° `3` çš„æ‰€æœ‰è·¯å¾„ã€‚

**è§£æ³•å¾ˆç®€å•ï¼Œä»¥ `0` ä¸ºèµ·ç‚¹éå†å›¾ï¼ŒåŒæ—¶è®°å½•éå†è¿‡çš„è·¯å¾„ï¼Œå½“éå†åˆ°ç»ˆç‚¹æ—¶å°†è·¯å¾„è®°å½•ä¸‹æ¥å³å¯**ã€‚

æ—¢ç„¶è¾“å…¥çš„å›¾æ˜¯æ— ç¯çš„ï¼Œæˆ‘ä»¬å°±ä¸éœ€è¦ `visited` æ•°ç»„è¾…åŠ©äº†ï¼Œç›´æ¥å¥—ç”¨å›¾çš„éå†æ¡†æ¶ï¼š

```java
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    List<List<Integer>> res = new LinkedList<>();
        
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // ç»´æŠ¤é€’å½’è¿‡ç¨‹ä¸­ç»è¿‡çš„è·¯å¾„
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.add(new LinkedList<>(path));
            // å¯ä»¥åœ¨è¿™ç›´æ¥ returnï¼Œä½†è¦ removeLast æ­£ç¡®ç»´æŠ¤ path
            // path.removeLast();
            // return;
            // ä¸ return ä¹Ÿå¯ä»¥ï¼Œå› ä¸ºå›¾ä¸­ä¸åŒ…å«ç¯ï¼Œä¸ä¼šå‡ºç°æ— é™é€’å½’
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
        
        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.removeLast();
    }
}

```

ç®€æ´ç‰ˆï¼š

```java
class Solution {
    List<List<Integer>> ans = new LinkedList<>();
    List<Integer> path = new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        dfs(graph,0);
        return ans;
    }
    void dfs(int[][] graph,int s){
        path.addLast(s);
        if (s==graph.length-1){
            ans.add(new LinkedList<>(path));
        }
        for (int i : graph[s]) {
            dfs(graph,i);
        }
        path.removeLast();
    }
}
```



## ç¯æ£€æµ‹ç®—æ³•é—®é¢˜

### 207. è¯¾ç¨‹è¡¨

ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® `numCourses` é—¨è¯¾ç¨‹ï¼Œè®°ä¸º `0` åˆ° `numCourses - 1` ã€‚

åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„ `prerequisites` ç»™å‡ºï¼Œå…¶ä¸­ `prerequisites[i] = [ai, bi]` ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹ `ai` åˆ™ **å¿…é¡»** å…ˆå­¦ä¹ è¯¾ç¨‹ `bi` ã€‚

- ä¾‹å¦‚ï¼Œå…ˆä¿®è¯¾ç¨‹å¯¹ `[0, 1]` è¡¨ç¤ºï¼šæƒ³è¦å­¦ä¹ è¯¾ç¨‹ `0` ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ `1` ã€‚

è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0 ã€‚è¿™æ˜¯å¯èƒ½çš„ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0],[0,1]]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 0 ï¼›å¹¶ä¸”å­¦ä¹ è¯¾ç¨‹ 0 ä¹‹å‰ï¼Œä½ è¿˜åº”å…ˆå®Œæˆè¯¾ç¨‹ 1 ã€‚è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚
```

**æç¤ºï¼š**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` ä¸­çš„æ‰€æœ‰è¯¾ç¨‹å¯¹ **äº’ä¸ç›¸åŒ**

é¦–å…ˆæˆ‘ä»¬è¦æŠŠé¢˜ç›®çš„è¾“å…¥è½¬åŒ–æˆä¸€å¹…æœ‰å‘å›¾ï¼Œç„¶åå†åˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨ç¯ã€‚

å¦‚ä½•è½¬æ¢æˆå›¾å‘¢ï¼Ÿæˆ‘ä»¬å‰æ–‡ [å›¾è®ºåŸºç¡€](https://labuladong.github.io/article/fname.html?fname=å›¾) å†™è¿‡å›¾çš„ä¸¤ç§å­˜å‚¨å½¢å¼ï¼Œé‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨ã€‚

ä»¥æˆ‘åˆ·é¢˜çš„ç»éªŒï¼Œå¸¸è§çš„å­˜å‚¨æ–¹å¼æ˜¯ä½¿ç”¨é‚»æ¥è¡¨ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§ç»“æ„ï¼š

```java
List<Integer>[] graph;
```

**`graph[s]` æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå­˜å‚¨ç€èŠ‚ç‚¹ `s` æ‰€æŒ‡å‘çš„èŠ‚ç‚¹**ã€‚

æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆå¯ä»¥å†™ä¸€ä¸ªå»ºå›¾å‡½æ•°ï¼š

```java
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        // è¾¹çš„æ–¹å‘æ˜¯ã€Œè¢«ä¾èµ–ã€å…³ç³»ï¼Œå³ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        graph[from].add(to);
    }
    return graph;
}
```

å›¾å»ºå‡ºæ¥äº†ï¼Œæ€ä¹ˆåˆ¤æ–­å›¾ä¸­æœ‰æ²¡æœ‰ç¯å‘¢ï¼Ÿ

> tipï¼šç±»æ¯”è´ªåƒè›‡æ¸¸æˆï¼Œ`visited` è®°å½•è›‡ç»è¿‡è¿‡çš„æ ¼å­ï¼Œè€Œ `onPath` ä»…ä»…è®°å½•è›‡èº«ã€‚`onPath` ç”¨äºåˆ¤æ–­æ˜¯å¦æˆç¯ï¼Œç±»æ¯”å½“è´ªåƒè›‡è‡ªå·±å’¬åˆ°è‡ªå·±ï¼ˆæˆç¯ï¼‰çš„åœºæ™¯ã€‚

è¿™æ ·ï¼Œå°±å¯ä»¥åœ¨éå†å›¾çš„è¿‡ç¨‹ä¸­é¡ºä¾¿åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¯äº†ï¼Œå®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```java
class Solution {
    // è®°å½•ä¸€æ¬¡é€’å½’å †æ ˆä¸­çš„èŠ‚ç‚¹
    boolean[] onPath;
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    boolean[] visited;
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    boolean hasCycle = false;

    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            traverse(graph, i);
        }
        // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
        return !hasCycle;
    }

    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // å‡ºç°ç¯
            hasCycle = true;
        }
        
        if (visited[s] || hasCycle) {
            // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
            return;
        }
        // å‰åºä»£ç ä½ç½®
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // ååºä»£ç ä½ç½®
        onPath[s] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            // è¾¹çš„æ–¹å‘æ˜¯ã€Œè¢«ä¾èµ–ã€å…³ç³»ï¼Œå³ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            graph[from].add(to);
        }
        return graph;
    }
}
```



é™„ï¼š207. ä¸´è¡—è¡¨è®¡ç®—å…¥åº¦æ³•ï¼š

```java
class Solution {
    boolean hasCycle = false;
    boolean[] onPath;
    boolean[] visited;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        int[] inDegrees = new int[numCourses];//å…¥åº¦è¡¨æ³•
        for (int i = 0; i < prerequisites.length; i++) {
            int from = prerequisites[i][1];
            int to = prerequisites[i][0];
            graph[from].add(to);//graph[s] æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå­˜å‚¨ç€èŠ‚ç‚¹ s æ‰€æŒ‡å‘çš„èŠ‚ç‚¹ã€‚
            inDegrees[to]++;
        }
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                queue.push(i);
            }
        }
        while (!queue.isEmpty()){
            Integer pop = queue.pop();
            numCourses--;
            for (Integer i : graph[pop]) {
                inDegrees[i]--;
                if (inDegrees[i]==0) queue.push(i);
            }
        }
        return numCourses==0;
    }

}
```





## æ‹“æ‰‘æ’åºé—®é¢˜ï¼ˆæœ‰å‘æ— ç¯å›¾ã€AOVç½‘ï¼‰

**æœ‰å‘æ— ç¯å›¾ï¼ŒDirected Acyclic Graphï¼ŒDAG**

**æ‹“æ‰‘æ’åºï¼ŒTopological sorting**

**AOVç½‘ï¼ˆActivity On Vertex Network)**ï¼šå°†ä¸€ä¸ªå·¥ç¨‹åˆ†ä¸ºå¤šä¸ªå°çš„**æ´»åŠ¨ï¼ˆActivity)**ï¼Œåœ¨**æœ‰å‘æ— ç¯å›¾**ä¸­ï¼Œç”¨é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨å¼§ï¼ˆæœ‰å‘è¾¹ï¼‰è¡¨ç¤ºæ´»åŠ¨çš„å…ˆåå…³ç³»ï¼Œç®€ç§°ä¸ºAOVç½‘ã€‚

æ€§è´¨ï¼š

- èƒ½ æ‹“æ‰‘æ’åº çš„å›¾ï¼Œä¸€å®šæ˜¯æœ‰å‘æ— ç¯å›¾
- æœ‰å‘æ— ç¯å›¾ï¼Œä¸€å®šèƒ½æ‹“æ‰‘æ’åº

æ³¨æ„ï¼š

- Bä¾èµ–Aï¼Œä¸€èˆ¬åœ¨å›¾ä¸­è¡¨ç¤ºä¸ºæœ‰å‘è¾¹ `A -> B` ï¼Œä¹Ÿå°±æ˜¯å…ˆå®ŒæˆAï¼Œåå®ŒæˆBã€‚

### LeetCode 210. è¯¾ç¨‹è¡¨ II

[210. è¯¾ç¨‹è¡¨ II](https://leetcode-cn.com/problems/course-schedule-ii/)

ç°åœ¨ä½ æ€»å…±æœ‰ n é—¨è¯¾ `0 ~ n-1`ã€‚æƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0ï¼Œè¦å…ˆå®Œæˆè¯¾ç¨‹ 1ï¼Œç”¨ `[0,1]` è¡¨ç¤ºã€‚ç»™å®šè¯¾ç¨‹æ€»é‡ä»¥åŠå®ƒä»¬çš„å…ˆå†³æ¡ä»¶ï¼Œè¿”å›å­¦å®Œæ‰€æœ‰è¯¾ç¨‹çš„é¡ºåºï¼ˆè¿”å›ä¸€ç§å³å¯ï¼‰ï¼Œå¦‚æœä¸å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè¿”å›ç©ºæ•°ç»„ã€‚

è¿™é“é¢˜å°±æ˜¯ä¸Šé“é¢˜çš„è¿›é˜¶ç‰ˆï¼Œä¸æ˜¯ä»…ä»…è®©ä½ åˆ¤æ–­æ˜¯å¦å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè€Œæ˜¯è¿›ä¸€æ­¥è®©ä½ è¿”å›ä¸€ä¸ªåˆç†çš„ä¸Šè¯¾é¡ºåºï¼Œä¿è¯å¼€å§‹ä¿®æ¯ä¸ªè¯¾ç¨‹æ—¶ï¼Œå‰ç½®çš„è¯¾ç¨‹éƒ½å·²ç»ä¿®å®Œã€‚

å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```java
int[] findOrder(int numCourses, int[][] prerequisites);
```

è¿™é‡Œæˆ‘å…ˆè¯´ä¸€ä¸‹æ‹“æ‰‘æ’åºï¼ˆTopological Sortingï¼‰è¿™ä¸ªåè¯ï¼Œç½‘ä¸Šæœå‡ºæ¥çš„å®šä¹‰å¾ˆæ•°å­¦ï¼Œè¿™é‡Œå¹²è„†ç”¨ç™¾åº¦ç™¾ç§‘çš„ä¸€å¹…å›¾æ¥è®©ä½ ç›´è§‚åœ°æ„Ÿå—ä¸‹ï¼š

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/top.jpg)

> noteï¼šå›¾ç‰‡ä¸­æ‹“æ‰‘æ’åºçš„ç»“æœæœ‰è¯¯ï¼Œ`C7->C8->C6` åº”è¯¥æ”¹ä¸º `C6->C7->C8`ã€‚

**ç›´è§‚åœ°è¯´å°±æ˜¯ï¼Œè®©ä½ æŠŠä¸€å¹…å›¾ã€Œæ‹‰å¹³ã€ï¼Œè€Œä¸”è¿™ä¸ªã€Œæ‹‰å¹³ã€çš„å›¾é‡Œé¢ï¼Œæ‰€æœ‰ç®­å¤´æ–¹å‘éƒ½æ˜¯ä¸€è‡´çš„**ï¼Œæ¯”å¦‚ä¸Šå›¾æ‰€æœ‰ç®­å¤´éƒ½æ˜¯æœå³çš„ã€‚

å¾ˆæ˜¾ç„¶ï¼Œå¦‚æœä¸€å¹…æœ‰å‘å›¾ä¸­å­˜åœ¨ç¯ï¼Œæ˜¯æ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åºçš„ï¼Œå› ä¸ºè‚¯å®šåšä¸åˆ°æ‰€æœ‰ç®­å¤´æ–¹å‘ä¸€è‡´ï¼›åè¿‡æ¥ï¼Œå¦‚æœä¸€å¹…å›¾æ˜¯ã€Œæœ‰å‘æ— ç¯å›¾ã€ï¼Œé‚£ä¹ˆä¸€å®šå¯ä»¥è¿›è¡Œæ‹“æ‰‘æ’åºã€‚

ä½†æ˜¯æˆ‘ä»¬è¿™é“é¢˜å’Œæ‹“æ‰‘æ’åºæœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ

**å…¶å®ä¹Ÿä¸éš¾çœ‹å‡ºæ¥ï¼Œå¦‚æœæŠŠè¯¾ç¨‹æŠ½è±¡æˆèŠ‚ç‚¹ï¼Œè¯¾ç¨‹ä¹‹é—´çš„ä¾èµ–å…³ç³»æŠ½è±¡æˆæœ‰å‘è¾¹ï¼Œé‚£ä¹ˆè¿™å¹…å›¾çš„æ‹“æ‰‘æ’åºç»“æœå°±æ˜¯ä¸Šè¯¾é¡ºåº**ã€‚



#### ä»£ç 

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
```

### æ·±åº¦ä¼˜å…ˆç®—æ³• DFS

#### æµç¨‹

- ä»æ¯ä¸ª**æœªè®¿é—®**çš„èŠ‚ç‚¹å¼€å§‹æ·±åº¦ä¼˜å…ˆéå†ã€‚
- è®¿é—®å®Œä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åç»§èŠ‚ç‚¹åï¼Œå°†è¯¥èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­ï¼ˆç±»ä¼¼æ ‘çš„**ååºéå†**ï¼‰ã€‚
- æœ€åå°†æ ˆåè½¬å³å¯å¾—åˆ°ç»“æœã€‚

#### ä»£ç 

DFSå®ç°å¦‚ä¸‹ï¼Œå…¶ä¸­ï¼š

- `graph` ä¸ºé‚»æ¥è¡¨ã€‚
- `globalVisited` ç”¨äºæ ‡è®°æ‰€æœ‰è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå·²ç»è®¿é—®è¿‡çš„ä¸å†é‡å¤è®¿é—®ã€‚
- `localVisited` ç”¨äºæ ‡è®°æœ¬è½®DFSè®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå¦‚æœæŸä¸€è½®DFSé‡å¤è®¿é—®åˆ°äº†æŸä¸ªèŠ‚ç‚¹ï¼Œè¯´æ˜å›¾ä¸­æœ‰ç¯ã€‚

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
```

## æœ€çŸ­è·¯å¾„é—®é¢˜

å¯¹äºè¾¹æƒä¸ºæ­£çš„å›¾ï¼Œä»»æ„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ï¼š

- ä¸ä¼šç»è¿‡é‡å¤çš„ç»“ç‚¹ã€‚
- ä¸ä¼šç»è¿‡é‡å¤çš„è¾¹ã€‚
- ç»“ç‚¹æ•°ä¸è¶…è¿‡ n ï¼Œè¾¹æ•°ä¸ä¼šè¶…è¿‡ n - 1ã€‚

**å•æºæœ€çŸ­è·¯**ï¼šæŒ‡å®šæºç‚¹ï¼Œæ±‚å®ƒåˆ°å…¶ä½™å„ä¸ªç»“ç‚¹çš„æœ€çŸ­è·¯ã€‚

### LeetCode 743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´

[743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´](https://leetcode-cn.com/problems/network-delay-time/)

æœ‰ N ä¸ªç½‘ç»œèŠ‚ç‚¹ `1 ~ N`ã€‚ç»™å®šåˆ—è¡¨ timesï¼Œè¡¨ç¤ºä¿¡å·ç»è¿‡æœ‰å‘è¾¹çš„ä¼ é€’æ—¶é—´ã€‚ `times[i] = (u, v, w)`ï¼Œå…¶ä¸­ u æ˜¯æºèŠ‚ç‚¹ï¼Œv æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œ w æ˜¯ä¸€ä¸ªä¿¡å·ä»æºèŠ‚ç‚¹ä¼ é€’åˆ°ç›®æ ‡èŠ‚ç‚¹çš„æ—¶é—´ã€‚

ä»èŠ‚ç‚¹ K å‘é€ä¿¡å·ï¼Œå¤šä¹…æ‰èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹éƒ½æ”¶åˆ°ä¿¡å·ï¼Ÿå¦‚æœä¸èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹æ”¶åˆ°ä¿¡å·ï¼Œè¿”å› -1ã€‚

### æ·±åº¦ä¼˜å…ˆç®—æ³• DFS

æµç¨‹ï¼š

- ä½¿ç”¨æ•°ç»„ä¿å­˜åˆ°è¾¾æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å°è€—æ—¶ã€‚åˆå§‹åŒ–æ—¶èŠ‚ç‚¹ K è€—æ—¶ä¸º0ï¼Œå…¶ä»–èŠ‚ç‚¹å‡ä¸º `-1`ï¼Œè¡¨ç¤ºæœªè®¿é—®ã€‚
- ä»èŠ‚ç‚¹ K å¼€å§‹æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚æ¯å½“é‡åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸”èŠ‚ç‚¹**æœªè®¿é—®** æˆ– **æ–°çš„æ—¶é—´å°äºèŠ‚ç‚¹ä¿å­˜çš„æ—¶é—´**ï¼Œå°±æ›´æ–°è¿™ä¸ªèŠ‚ç‚¹çš„æ—¶é—´ï¼ˆä¸€æ–¹é¢ä¸éœ€è¦æ›´æ–°ä¸ºæ›´å¤§çš„æ—¶é—´ï¼Œå¦ä¸€æ–¹é¢é¿å…é‡åˆ°ç¯ï¼Œå¯¼è‡´æ­»å¾ªç¯ï¼‰ã€‚
- éå†èŠ‚ç‚¹æ—¶é—´æ•°ç»„ï¼Œå¦‚æœä»æœ‰æœªè®¿é—®çš„èŠ‚ç‚¹ï¼Œè¯´æ˜ä»èŠ‚ç‚¹ K åˆ°è¯¥èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› `-1`ï¼›å¦åˆ™è¿”å›æ•°ç»„ä¸­çš„æœ€å¤§å€¼ã€‚

ä½¿ç”¨DFSè§£é¢˜ï¼ˆ489 msï¼‰ï¼Œæ€§èƒ½å¾ˆå·®ã€‚

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // time[i]: node [i] receive time
        int[] time = new int[N+1];
        Arrays.fill(time, -1);
        time[K] = 0;

        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] t : times) {
            int from = t[0], to = t[1], w = t[2];
            graph[from].add(new int[]{to, w});
        }

        dfs(graph, time, K);

        int max = -1;
        for (int i = 1; i <= N; ++i) {
            if (time[i] == -1) return -1;
            max = Math.max(max, time[i]);
        }
        return max;
    }

    public void dfs(List<int[]>[] graph, int[] time, int node) {
        for (int[] t : graph[node]) {
            int to = t[0], w = t[1];
            int newTime = time[node] + w;
            if (time[to] != -1 && newTime >= time[to]) {
                continue;
            }
            time[to] = newTime;
            dfs(graph, time, to);
        }
    }
}
```

### å¼—æ´›ä¼Šå¾·ç®—æ³• Floyd-Warshall Algorithm

ç‰¹ç‚¹ï¼š

- å¯ä»¥æ±‚ä»»æ„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ã€‚
- å¤æ‚åº¦è¾ƒé«˜ï¼Œä½†å®¹æ˜“å®ç°ã€‚
- é€‚ç”¨äºä»»ä½•å›¾ï¼Œä¸ç®¡æœ‰å‘æ— å‘ï¼Œè¾¹æƒæ­£è´Ÿï¼Œä½†æ˜¯æœ€çŸ­è·¯å¿…é¡»å­˜åœ¨ï¼ˆä¸èƒ½æœ‰ä¸ªè´Ÿç¯ï¼‰ã€‚

æ€è·¯ï¼š

- ä½¿ç”¨çŸ©é˜µè¡¨ç¤ºèŠ‚ç‚¹ `u â†’ v` ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚
- åˆå§‹åŒ–æ—¶ï¼Œ`w[i][i]` ä¸º0ï¼Œ `w[i][j]` ä¸ºè¾¹ `i â†’ j` çš„æƒé‡ï¼Œæ²¡æœ‰è¾¹çš„å…ƒç´ è®¾ç½®ä¸ºæ— ç©·å¤§ã€‚
- èŠ‚ç‚¹ `i â†’ j` å¯èƒ½é€šè¿‡ `k` ä¸­è½¬è€Œç¼©çŸ­è·ç¦»ï¼Œéå†è®¡ç®—ç‚¹ `i â†’ k â†’ j` çš„è·¯å¾„ï¼Œå¦‚æœæ¯”ç°æœ‰çš„ `i â†’ j` å°ï¼Œåˆ™æ›´æ–°ï¼Œå³**æ¾å¼›**æ“ä½œã€‚

å¤æ‚åº¦ï¼š

- æ—¶é—´å¤æ‚åº¦ `O( N^3 )`
- ç©ºé—´å¤æ‚åº¦ `O( N^2 )`

ä½¿ç”¨Floydç®—æ³•æ±‚è§£ï¼ˆ18msï¼‰ã€‚

```
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
```

### è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• Dijkstra Algorithm

ç‰¹ç‚¹ï¼š

- æ±‚å•æºæœ€çŸ­è·¯å¾„ã€‚
- åªé€‚ç”¨äºéè´Ÿæƒå›¾ã€‚
- æ—¶é—´å¤æ‚åº¦ä¼˜ç§€ã€‚
- ä½¿ç”¨äº†è´ªå¿ƒæ€æƒ³ã€‚

æ­¥éª¤ï¼š

- åˆå§‹ï¼š
  - å·²ç¡®å®šæœ€çŸ­è·¯çš„èŠ‚ç‚¹ä¸ºé›†åˆPï¼Œæœªç¡®å®šæœ€çŸ­è·¯çš„èŠ‚ç‚¹ä¸ºé›†åˆQã€‚
  - ä¿å­˜æºèŠ‚ç‚¹ K åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»ï¼Œåˆå§‹åŒ–æ—¶è·ç¦»ä¸ºæ— ç©·å¤§ã€‚
  - å°†æºèŠ‚ç‚¹ K æ”¾å…¥Qï¼Œå…¶è·ç¦»ä¸º0ã€‚
- å¾ªç¯ï¼š
  - ä»Qå–å‡ºä¸€ä¸ªè·ç¦»æœ€çŸ­çš„èŠ‚ç‚¹ uï¼Œå…¶æœ€çŸ­è·¯å¾„å·²ç»ç¡®å®šï¼Œå› æ­¤ç§»åˆ°Pï¼ˆè´ªå¿ƒæ€æƒ³ï¼Œå› ä¸º K åˆ°å…¶ä»–ç‚¹çš„è·ç¦»æ›´è¿œï¼Œä¸å¯èƒ½æ‰¾åˆ°ä¸€ä¸ªç»è¿‡å…¶ä»–ç‚¹å†åˆ° u çš„æ›´çŸ­è·¯å¾„ï¼‰ã€‚
  - æ¾å¼› u çš„**æœªç¡®å®šæœ€çŸ­è·¯çš„**å‡ºèŠ‚ç‚¹ï¼Œå³åˆ¤æ–­ç»è¿‡ u èƒ½å¦ç¼©çŸ­è·ç¦»ã€‚å°†è¿™äº›èŠ‚ç‚¹æ”¾åˆ°Qä¸­ç­‰å¾…ä¸‹ä¸€è½®å¾ªç¯å¤„ç†ã€‚
  - ç»§ç»­å¾ªç¯ï¼Œç›´åˆ°Qä¸ºç©ºã€‚

å…·ä½“å®ç°ï¼š

1. å¯ä»¥ç”¨ int æ•°ç»„ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»ï¼Œboolean æ•°ç»„è¡¨ç¤ºèŠ‚ç‚¹æ˜¯å¦å·²ç»åŠ å…¥åˆ°Pã€‚
2. ä¼˜åŒ–ï¼šJavaä¸­ä½¿ç”¨ `PriorityQueue` å®ç°Qï¼Œè¿™æ ·æ¯æ¬¡å–å‡ºè·ç¦»æœ€çŸ­èŠ‚ç‚¹æ—¶æ€§èƒ½æ›´å¥½ã€‚

å›¾è§£1ï¼Œæ¥è‡ª [ç»´åŸºç™¾ç§‘](https://zh.wikipedia.org/wiki/æˆ´å…‹æ–¯ç‰¹æ‹‰ç®—æ³•)ï¼š

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/Dijkstra_Animation.gif)

å›¾è§£2ï¼Œæ¥è‡ª [åšå®¢](https://www.cnblogs.com/thousfeet/p/9229395.html)ï¼š

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/dijkstra.jpg)

å›¾è§£2çš„æ‰§è¡Œæ­¥éª¤åˆ†æï¼š

```
ç¬¬ä¸€è¡Œä¸ºèŠ‚ç‚¹ï¼Œç¬¬äºŒè¡Œä¸ºè·ç¦»ï¼Œ.è¡¨ç¤ºæ— ç©·å¤§âˆï¼ŒåŠ ä¸­æ‹¬å·è¡¨ç¤ºå·²ç»ç¡®å®šæœ€çŸ­è·¯å¾„

 1    2    3    4    5    6
 0    Â·    Â·    Â·    Â·    Â·
 â†‘                             é€‰1ï¼Œæ¾å¼›2ã€3

 1    2    3    4    5    6
[0]   1   12    Â·    Â·    Â·
      â†‘                        é€‰2ï¼Œæ¾å¼›3ã€4

 1    2    3    4    5    6
[0]  [1]  10    4    Â·    Â·
                â†‘              é€‰4ï¼Œæ¾å¼›3ã€5ã€6...
```

ä½¿ç”¨Dijkstraç®—æ³•æ±‚è§£ï¼ˆ24 msï¼‰ï¼š

```
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
```

## å¹¶æŸ¥é›† Disjoint Set Union

### æ•…äº‹ï¼š

> å‡ ä¸ªå®¶æ—è¿›è¡Œå®´ä¼šï¼Œä½†æ˜¯å®¶æ—æ™®éé•¿å¯¿ï¼Œæ‰€ä»¥äººæ•°ä¼—å¤šã€‚ç”±äºé•¿æ—¶é—´çš„åˆ†ç¦»ä»¥åŠå¹´é¾„çš„å¢é•¿ï¼Œè¿™äº›äººé€æ¸å¿˜æ‰äº†è‡ªå·±çš„äº²äººï¼Œåªè®°å¾—è‡ªå·±çš„çˆ¸çˆ¸æ˜¯è°äº†ï¼Œè€Œæœ€é•¿è€…ï¼ˆç§°ä¸ºã€Œç¥–å…ˆã€ï¼‰çš„çˆ¶äº²å·²ç»å»ä¸–ï¼Œä»–åªçŸ¥é“è‡ªå·±æ˜¯ç¥–å…ˆã€‚
>
> ä¸ºäº†ç¡®å®šè‡ªå·±æ˜¯å“ªä¸ªå®¶æ—ï¼Œä»–ä»¬æƒ³å‡ºäº†ä¸€ä¸ªåŠæ³•ï¼Œåªè¦é—®è‡ªå·±çš„çˆ¸çˆ¸æ˜¯ä¸æ˜¯ç¥–å…ˆï¼Œä¸€å±‚ä¸€å±‚çš„å‘ä¸Šé—®ï¼Œç›´åˆ°é—®åˆ°ç¥–å…ˆã€‚å¦‚æœè¦åˆ¤æ–­ä¸¤äººæ˜¯å¦åœ¨åŒä¸€å®¶æ—ï¼Œåªè¦çœ‹ä¸¤äººçš„ç¥–å…ˆæ˜¯ä¸æ˜¯åŒä¸€äººå°±å¯ä»¥äº†ã€‚

åˆå§‹åŒ–

```java
int[] parent = new int[n];

void init() {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}
```

æŸ¥æ‰¾

```java
int findRoot(int x) {
    int x_root = parent[x];
    while (x_root != x) {
        x_root = parent[x_root];
    }
    return x_root;
}
```



è·¯å¾„å‹ç¼©

æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼ŒåŒæ—¶æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ç›´æ¥è¿æ¥åˆ°æ ¹ä¸Šã€‚è¿™æ ·å¯ä»¥å¤§å¤§æé«˜æ•ˆç‡ã€‚

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2005461-20210107163928771-776073883.jpg)

```java
// è¿­ä»£å†™æ³•
int findRoot(int x) {
    while (parent[x] != x) {
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}

// é€’å½’å†™æ³•
int findRoot(int x) {
  if (x != parent[x])
    parent[x] = find(parent, parent[x]);
  return parent[x];
}
```

åˆå¹¶

> å®´ä¼šä¸Šï¼Œä¸€ä¸ªå®¶æ—çš„ç¥–å…ˆçªç„¶å¯¹å¦ä¸€ä¸ªå®¶æ—è¯´ï¼šæˆ‘ä»¬ä¸¤ä¸ªå®¶æ—äº¤æƒ…è¿™ä¹ˆå¥½ï¼Œä¸å¦‚åˆæˆä¸€å®¶å¥½äº†ã€‚å¦ä¸€ä¸ªå®¶æ—ä¹Ÿæ¬£ç„¶æ¥å—äº†ã€‚ç”±äºå¹¶ä¸åœ¨æ„ç¥–å…ˆç©¶ç«Ÿæ˜¯è°ï¼Œæ‰€ä»¥åªè¦å…¶ä¸­ä¸€ä¸ªç¥–å…ˆå˜æˆå¦ä¸€ä¸ªç¥–å…ˆçš„å„¿å­å°±å¯ä»¥äº†ã€‚

```
boolean union(int x, int y) {
    // x ä¸ y æ‰€åœ¨å®¶æ—åˆå¹¶
    x = find(x);
    y = find(y);
    if (x == y) {  // åŸæœ¬å°±åœ¨ä¸€ä¸ªå®¶æ—é‡Œå°±ä¸ç®¡äº†
        return false;
    }
    parent[x] = y;  // æŠŠ x çš„ç¥–å…ˆå˜æˆ y çš„ç¥–å…ˆçš„å„¿å­
    return true;
}
```

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2005461-20210107163946024-115247088.jpg)

å¯å‘å¼åˆå¹¶ï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰

> ä¸€ä¸ªç¥–å…ˆçªç„¶æŠ–äº†ä¸ªæœºçµï¼šâ€œä½ ä»¬å®¶æ—äººæ¯”è¾ƒå°‘ï¼Œæ¬å®¶åˆ°æˆ‘ä»¬å®¶æ—é‡Œæ¯”è¾ƒæ–¹ä¾¿ï¼Œæˆ‘ä»¬è¦æ˜¯æ¬è¿‡å»çš„è¯å¤ªè´¹äº‹äº†ã€‚â€

è·¯å¾„å‹ç¼©æœ‰æ—¶ä¸é€‚ç”¨ï¼Œå¯ä»¥ç”¨å¯å‘å¼åˆå¹¶ã€‚

```
int[] rank = new int[n]; // initial value: 0

boolean union(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        return false;
    }
    if (rank[x] > rank[y]) {
        parent[x] = y;
    } else if (rank[x] < rank[y]) {
        parent[y] = x;
    } else {
        parent[x] = y;
        rank[y]++;
    }
    return true;
}
```



### ä¸€ã€åŠ¨æ€è”é€š

ç®€å•è¯´ï¼ŒåŠ¨æ€è¿é€šæ€§å…¶å®å¯ä»¥æŠ½è±¡æˆç»™ä¸€å¹…å›¾è¿çº¿ã€‚æ¯”å¦‚ä¸‹é¢è¿™å¹…å›¾ï¼Œæ€»å…±æœ‰ 10 ä¸ªèŠ‚ç‚¹ï¼Œä»–ä»¬äº’ä¸ç›¸è¿ï¼Œåˆ†åˆ«ç”¨ 0~9 æ ‡è®°ï¼š

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639614-1cd699eb-a256-4785-b7f5-fc8115fe3052.jpeg)

ç°åœ¨æˆ‘ä»¬çš„ Union-Find ç®—æ³•ä¸»è¦éœ€è¦å®ç°è¿™ä¸¤ä¸ª APIï¼š  

```java
class UF {
    /* å°† p å’Œ q è¿æ¥ */
    public void union(int p, int q);
    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦è¿é€š */
    public boolean connected(int p, int q);
    /* è¿”å›å›¾ä¸­æœ‰å¤šå°‘ä¸ªè¿é€šåˆ†é‡ */
    public int count();
}
```

è¿™é‡Œæ‰€è¯´çš„ã€Œè¿é€šã€æ˜¯ä¸€ç§ç­‰ä»·å…³ç³»ï¼Œä¹Ÿå°±æ˜¯è¯´å…·æœ‰å¦‚ä¸‹ä¸‰ä¸ªæ€§è´¨ï¼š

**1ã€è‡ªåæ€§**ï¼šèŠ‚ç‚¹`p`å’Œ`p`æ˜¯è¿é€šçš„ã€‚

**2ã€å¯¹ç§°æ€§**ï¼šå¦‚æœèŠ‚ç‚¹`p`å’Œ`q`è¿é€šï¼Œé‚£ä¹ˆ`q`å’Œ`p`ä¹Ÿè¿é€šã€‚

**3ã€ä¼ é€’æ€§**ï¼šå¦‚æœèŠ‚ç‚¹`p`å’Œ`q`è¿é€šï¼Œ`q`å’Œ`r`è¿é€šï¼Œé‚£ä¹ˆ`p`å’Œ`r`ä¹Ÿè¿é€šã€‚

æ¯”å¦‚è¯´ä¹‹å‰é‚£å¹…å›¾ï¼Œ0ï½9 ä»»æ„ä¸¤ä¸ª**ä¸åŒ**çš„ç‚¹éƒ½ä¸è¿é€šï¼Œè°ƒç”¨`connected`éƒ½ä¼šè¿”å› falseï¼Œè¿é€šåˆ†é‡ä¸º 10 ä¸ªï¼Œå®é™…å°±æ˜¯å°å•å…ƒ

å¦‚æœç°åœ¨è°ƒç”¨`union(0, 1)`ï¼Œé‚£ä¹ˆ 0 å’Œ 1 è¢«è¿é€šï¼Œè¿é€šåˆ†é‡é™ä¸º 9 ä¸ªã€‚

å†è°ƒç”¨`union(1, 2)`ï¼Œè¿™æ—¶ 0,1,2 éƒ½è¢«è¿é€šï¼Œè°ƒç”¨`connected(0, 2)`ä¹Ÿä¼šè¿”å› trueï¼Œè¿é€šåˆ†é‡å˜ä¸º 8 ä¸ªã€‚

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639676-f84b04f7-4572-407e-99a5-971ffd0281dc.jpeg)

åˆ¤æ–­è¿™ç§ã€Œç­‰ä»·å…³ç³»ã€éå¸¸å®ç”¨ï¼Œæ¯”å¦‚è¯´ç¼–è¯‘å™¨åˆ¤æ–­åŒä¸€ä¸ªå˜é‡çš„ä¸åŒå¼•ç”¨ï¼Œæ¯”å¦‚ç¤¾äº¤ç½‘ç»œä¸­çš„æœ‹å‹åœˆè®¡ç®—ç­‰ç­‰ã€‚  

è¿™æ ·ï¼Œä½ åº”è¯¥å¤§æ¦‚æ˜ç™½ä»€ä¹ˆæ˜¯åŠ¨æ€è¿é€šæ€§äº†ï¼ŒUnion-Find ç®—æ³•çš„å…³é”®å°±åœ¨äº`union`å’Œ`connected`å‡½æ•°çš„æ•ˆç‡ã€‚é‚£ä¹ˆç”¨ä»€ä¹ˆæ¨¡å‹æ¥è¡¨ç¤ºè¿™å¹…å›¾çš„è¿é€šçŠ¶æ€å‘¢ï¼Ÿç”¨ä»€ä¹ˆæ•°æ®ç»“æ„æ¥å®ç°ä»£ç å‘¢ï¼Ÿ

### äºŒã€åŸºæœ¬æ€è·¯

æ³¨æ„æˆ‘åˆšæ‰æŠŠã€Œæ¨¡å‹ã€å’Œå…·ä½“çš„ã€Œæ•°æ®ç»“æ„ã€åˆ†å¼€è¯´ï¼Œè¿™ä¹ˆåšæ˜¯æœ‰åŸå› çš„ã€‚å› ä¸ºæˆ‘ä»¬ä½¿ç”¨æ£®æ—ï¼ˆè‹¥å¹²æ£µæ ‘ï¼‰æ¥è¡¨ç¤ºå›¾çš„åŠ¨æ€è¿é€šæ€§ï¼Œç”¨æ•°ç»„æ¥å…·ä½“å®ç°è¿™ä¸ªæ£®æ—ã€‚

æ€ä¹ˆç”¨æ£®æ—æ¥è¡¨ç¤ºè¿é€šæ€§å‘¢ï¼Ÿæˆ‘ä»¬è®¾å®šæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯æ ¹èŠ‚ç‚¹çš„è¯ï¼Œè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘è‡ªå·±ã€‚

æ¯”å¦‚è¯´åˆšæ‰é‚£å¹… 10 ä¸ªèŠ‚ç‚¹çš„å›¾ï¼Œä¸€å¼€å§‹çš„æ—¶å€™æ²¡æœ‰ç›¸äº’è¿é€šï¼Œå°±æ˜¯è¿™æ ·ï¼š

```java
class UF {
    // è®°å½•è¿é€šåˆ†é‡
    private int count;
    // èŠ‚ç‚¹ x çš„èŠ‚ç‚¹æ˜¯ parent[x]
    private int[] parent;

    /* æ„é€ å‡½æ•°ï¼Œn ä¸ºå›¾çš„èŠ‚ç‚¹æ€»æ•° */
    public UF(int n) {
        // ä¸€å¼€å§‹äº’ä¸è¿é€š
        this.count = n;
        // çˆ¶èŠ‚ç‚¹æŒ‡é’ˆåˆå§‹æŒ‡å‘è‡ªå·±
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    /* å…¶ä»–å‡½æ•° */
}
```

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801639709-811dfdba-1506-43d2-84ab-13c48e4cebd6.jpeg)

**å¦‚æœæŸä¸¤ä¸ªèŠ‚ç‚¹è¢«è¿é€šï¼Œåˆ™è®©å…¶ä¸­çš„ï¼ˆä»»æ„ï¼‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹æ¥åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ä¸Š**ï¼š

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // å°†ä¸¤æ£µæ ‘åˆå¹¶ä¸ºä¸€æ£µ
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP ä¹Ÿä¸€æ ·
    count--; // ä¸¤ä¸ªåˆ†é‡åˆäºŒä¸ºä¸€
}

/* è¿”å›æŸä¸ªèŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
private int find(int x) {
    // æ ¹èŠ‚ç‚¹çš„ parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* è¿”å›å½“å‰çš„è¿é€šåˆ†é‡ä¸ªæ•° */
public int count() { 
    return count;
}
```

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801639805-15a93d4e-0189-4162-b0bc-5cb08739ddbc.jpeg)

**è¿™æ ·ï¼Œå¦‚æœèŠ‚ç‚¹**`**p**`**å’Œ**`**q**`**è¿é€šçš„è¯ï¼Œå®ƒä»¬ä¸€å®šæ‹¥æœ‰ç›¸åŒçš„æ ¹èŠ‚ç‚¹**ï¼š

```
public boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
```

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801639809-7ffa38e0-2d31-4915-9eef-59d713d9c0bf.jpeg)

è‡³æ­¤ï¼ŒUnion-Find ç®—æ³•å°±åŸºæœ¬å®Œæˆäº†ã€‚æ˜¯ä¸æ˜¯å¾ˆç¥å¥‡ï¼Ÿç«Ÿç„¶å¯ä»¥è¿™æ ·ä½¿ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿå‡ºä¸€ä¸ªæ£®æ—ï¼Œå¦‚æ­¤å·§å¦™çš„è§£å†³è¿™ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼

é‚£ä¹ˆè¿™ä¸ªç®—æ³•çš„å¤æ‚åº¦æ˜¯å¤šå°‘å‘¢ï¼Ÿæˆ‘ä»¬å‘ç°ï¼Œä¸»è¦ API`connected`å’Œ`union`ä¸­çš„å¤æ‚åº¦éƒ½æ˜¯`find`å‡½æ•°é€ æˆçš„ï¼Œæ‰€ä»¥è¯´å®ƒä»¬çš„å¤æ‚åº¦å’Œ`find`ä¸€æ ·ã€‚

`find`ä¸»è¦åŠŸèƒ½å°±æ˜¯ä»æŸä¸ªèŠ‚ç‚¹å‘ä¸Šéå†åˆ°æ ‘æ ¹ï¼Œå…¶æ—¶é—´å¤æ‚åº¦å°±æ˜¯æ ‘çš„é«˜åº¦ã€‚æˆ‘ä»¬å¯èƒ½ä¹ æƒ¯æ€§åœ°è®¤ä¸ºæ ‘çš„é«˜åº¦å°±æ˜¯`logN`ï¼Œä½†è¿™å¹¶ä¸ä¸€å®šã€‚`**logN**`**çš„é«˜åº¦åªå­˜åœ¨äºå¹³è¡¡äºŒå‰æ ‘ï¼Œå¯¹äºä¸€èˆ¬çš„æ ‘å¯èƒ½å‡ºç°æç«¯ä¸å¹³è¡¡çš„æƒ…å†µï¼Œä½¿å¾—ã€Œæ ‘ã€å‡ ä¹é€€åŒ–æˆã€Œé“¾è¡¨ã€ï¼Œæ ‘çš„é«˜åº¦æœ€åæƒ…å†µä¸‹å¯èƒ½å˜æˆ**`**N**`**ã€‚**

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801640025-d750ad3d-7d8b-4514-b50c-afcf42e6e63f.jpeg)

æ‰€ä»¥è¯´ä¸Šé¢è¿™ç§è§£æ³•ï¼Œ`find`,`union`,`connected`çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(N)ã€‚è¿™ä¸ªå¤æ‚åº¦å¾ˆä¸ç†æƒ³çš„ï¼Œä½ æƒ³å›¾è®ºè§£å†³çš„éƒ½æ˜¯è¯¸å¦‚ç¤¾äº¤ç½‘ç»œè¿™æ ·æ•°æ®è§„æ¨¡å·¨å¤§çš„é—®é¢˜ï¼Œå¯¹äº`union`å’Œ`connected`çš„è°ƒç”¨éå¸¸é¢‘ç¹ï¼Œæ¯æ¬¡è°ƒç”¨éœ€è¦çº¿æ€§æ—¶é—´å®Œå…¨ä¸å¯å¿å—ã€‚  

**é—®é¢˜çš„å…³é”®åœ¨äºï¼Œå¦‚ä½•æƒ³åŠæ³•é¿å…æ ‘çš„ä¸å¹³è¡¡å‘¢**ï¼Ÿåªéœ€è¦ç•¥æ–½å°è®¡å³å¯ã€‚

### ä¸‰ã€å¹³è¡¡æ€§ä¼˜åŒ–

æˆ‘ä»¬è¦çŸ¥é“å“ªç§æƒ…å†µä¸‹å¯èƒ½å‡ºç°ä¸å¹³è¡¡ç°è±¡ï¼Œå…³é”®åœ¨äº`union`è¿‡ç¨‹ï¼š

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // å°†ä¸¤æ£µæ ‘åˆå¹¶ä¸ºä¸€æ£µ
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP ä¹Ÿå¯ä»¥
    count--;
```

æˆ‘ä»¬ä¸€å¼€å§‹å°±æ˜¯ç®€å•ç²—æš´çš„æŠŠ`p`æ‰€åœ¨çš„æ ‘æ¥åˆ°`q`æ‰€åœ¨çš„æ ‘çš„æ ¹èŠ‚ç‚¹ä¸‹é¢ï¼Œé‚£ä¹ˆè¿™é‡Œå°±å¯èƒ½å‡ºç°ã€Œå¤´é‡è„šè½»ã€çš„ä¸å¹³è¡¡çŠ¶å†µï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§å±€é¢ï¼š

![](https://cdn.nlark.com/yuque/0/2024/jpeg/1389077/1716801640258-4621ac7e-a6dd-454d-9926-570f768dced0.jpeg)

é•¿æ­¤ä»¥å¾€ï¼Œæ ‘å¯èƒ½ç”Ÿé•¿å¾—å¾ˆä¸å¹³è¡¡ã€‚**æˆ‘ä»¬å…¶å®æ˜¯å¸Œæœ›ï¼Œå°ä¸€äº›çš„æ ‘æ¥åˆ°å¤§ä¸€äº›çš„æ ‘ä¸‹é¢ï¼Œè¿™æ ·å°±èƒ½é¿å…å¤´é‡è„šè½»ï¼Œæ›´å¹³è¡¡ä¸€äº›**ã€‚==è§£å†³æ–¹æ³•æ˜¯é¢å¤–ä½¿ç”¨ä¸€ä¸ª`size`æ•°ç»„ï¼Œè®°å½•æ¯æ£µæ ‘åŒ…å«çš„èŠ‚ç‚¹æ•°ï¼Œæˆ‘ä»¬ä¸å¦¨ç§°ä¸ºã€Œé‡é‡ã€ï¼š==  

```java
class UF {
    private int count;
    private int[] parent;
    // æ–°å¢ä¸€ä¸ªæ•°ç»„è®°å½•æ ‘çš„â€œé‡é‡â€
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        // æœ€åˆæ¯æ£µæ ‘åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
        // é‡é‡åº”è¯¥åˆå§‹åŒ– 1
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    /* å…¶ä»–å‡½æ•° */
}
```

æ¯”å¦‚è¯´`size[3] = 5`è¡¨ç¤ºï¼Œä»¥èŠ‚ç‚¹`3`ä¸ºæ ¹çš„é‚£æ£µæ ‘ï¼Œæ€»å…±æœ‰`5`ä¸ªèŠ‚ç‚¹ã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ä¸€ä¸‹`union`æ–¹æ³•ï¼š

```java
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if (size[rootP] > size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ];
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    count--;
}
```

è¿™æ ·ï¼Œé€šè¿‡æ¯”è¾ƒæ ‘çš„é‡é‡ï¼Œå°±å¯ä»¥ä¿è¯æ ‘çš„ç”Ÿé•¿ç›¸å¯¹å¹³è¡¡ï¼Œæ ‘çš„é«˜åº¦å¤§è‡´åœ¨`logN`è¿™ä¸ªæ•°é‡çº§ï¼Œæå¤§æå‡æ‰§è¡Œæ•ˆç‡ã€‚

æ­¤æ—¶ï¼Œ`find`,`union`,`connected`çš„æ—¶é—´å¤æ‚åº¦éƒ½ä¸‹é™ä¸º O(logN)ï¼Œå³ä¾¿æ•°æ®è§„æ¨¡ä¸Šäº¿ï¼Œæ‰€éœ€æ—¶é—´ä¹Ÿéå¸¸å°‘ã€‚

### å››ã€è·¯å¾„å‹ç¼©

è¿™æ­¥ä¼˜åŒ–ç‰¹åˆ«ç®€å•ï¼Œæ‰€ä»¥éå¸¸å·§å¦™ã€‚æˆ‘ä»¬èƒ½ä¸èƒ½è¿›ä¸€æ­¥å‹ç¼©æ¯æ£µæ ‘çš„é«˜åº¦ï¼Œä½¿æ ‘é«˜å§‹ç»ˆä¿æŒä¸ºå¸¸æ•°ï¼Ÿ

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801640148-7476d66f-b8c8-458c-aa60-d586822e8160.jpeg)

è¿™æ ·`find`å°±èƒ½ä»¥ O(1) çš„æ—¶é—´æ‰¾åˆ°æŸä¸€èŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ï¼Œç›¸åº”çš„ï¼Œ`connected`å’Œ`union`å¤æ‚åº¦éƒ½ä¸‹é™ä¸º O(1)ã€‚  

è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œéå¸¸ç®€å•ï¼Œåªéœ€è¦åœ¨`find`ä¸­åŠ ä¸€è¡Œä»£ç ï¼š

```java
private int find(int x) {
    while (parent[x] != x) {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}
```

è¿™ä¸ªæ“ä½œæœ‰ç‚¹åŒªå¤·æ‰€æ€ï¼Œçœ‹ä¸ª GIF å°±æ˜ç™½å®ƒçš„ä½œç”¨äº†ï¼ˆä¸ºæ¸…æ™°èµ·è§ï¼Œè¿™æ£µæ ‘æ¯”è¾ƒæç«¯ï¼‰ï¼š



![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1716801640694-22b2a899-9b94-451a-8dc4-b2618f3551cf.gif)

å¯è§ï¼Œè°ƒç”¨`find`å‡½æ•°æ¯æ¬¡å‘æ ‘æ ¹éå†çš„åŒæ—¶ï¼Œé¡ºæ‰‹å°†æ ‘é«˜ç¼©çŸ­äº†ï¼Œæœ€ç»ˆæ‰€æœ‰æ ‘é«˜éƒ½ä¸ä¼šè¶…è¿‡ 3ï¼ˆ`union`çš„æ—¶å€™æ ‘é«˜å¯èƒ½è¾¾åˆ° 3ï¼‰ã€‚

PSï¼šè¯»è€…å¯èƒ½ä¼šé—®ï¼Œè¿™ä¸ª GIF å›¾çš„`find`è¿‡ç¨‹å®Œæˆä¹‹åï¼Œæ ‘é«˜æ°å¥½ç­‰äº 3 äº†ï¼Œä½†æ˜¯å¦‚æœæ›´é«˜çš„æ ‘ï¼Œå‹ç¼©åé«˜åº¦ä¾ç„¶ä¼šå¤§äº 3 å‘€ï¼Ÿä¸èƒ½è¿™ä¹ˆæƒ³ã€‚è¿™ä¸ª GIF çš„æƒ…æ™¯æ˜¯æˆ‘ç¼–å‡ºæ¥æ–¹ä¾¿å¤§å®¶ç†è§£è·¯å¾„å‹ç¼©çš„ï¼Œä½†æ˜¯å®é™…ä¸­ï¼Œæ¯æ¬¡`find`éƒ½ä¼šè¿›è¡Œè·¯å¾„å‹ç¼©ï¼Œæ‰€ä»¥æ ‘æœ¬æ¥å°±ä¸å¯èƒ½å¢é•¿åˆ°è¿™ä¹ˆé«˜ï¼Œä½ çš„è¿™ç§æ‹…å¿ƒåº”è¯¥æ˜¯å¤šä½™çš„ã€‚

### äº”ã€æœ€åæ€»ç»“

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹å®Œæ•´ä»£ç ï¼š

```java
class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨ä¸€æ£µæ ‘
    private int[] parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
}
```

Union-Find ç®—æ³•çš„å¤æ‚åº¦å¯ä»¥è¿™æ ·åˆ†æï¼šæ„é€ å‡½æ•°åˆå§‹åŒ–æ•°æ®ç»“æ„éœ€è¦ O(N) çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ï¼›**è¿é€šä¸¤ä¸ªèŠ‚ç‚¹`union`ã€åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹çš„è¿é€šæ€§`connected`ã€è®¡ç®—è¿é€šåˆ†é‡`count`æ‰€éœ€çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º O(1)ã€‚**

#### å¹¶æŸ¥é›†åº”ç”¨

- **æ±‚è¿é€šåˆ†é‡**ï¼šä¾æ¬¡å¯¹æ¯ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹è¿›è¡Œå¹¶æŸ¥é›†åˆå¹¶ï¼Œå¯ä»¥ä½¿å¾—æ¯ä¸ªè¿é€šåˆ†é‡çš„rootç›¸åŒï¼Œä»è€Œå¾—å‡ºæ¯ä¸ªè¿é€šåˆ†é‡ã€‚
- **æŸ¥æ‰¾ç¯**ï¼šåˆå¹¶è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°ä¸€æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹å·²ç»åˆå¹¶è¿‡ï¼Œè¯´æ˜è¿™ä¸¤ä¸ªé¡¶ç‚¹ä¹‹å‰å·²ç»é€šè¿‡å…¶ä»–è·¯å¾„åˆå¹¶ï¼Œå†åŠ ä¸Šè¿™æ¡è¾¹ï¼Œå›¾ä¸­å°±å‡ºç°äº†ç¯ã€‚
- **æ±‚æœ€å°ç”Ÿæˆæ ‘**ï¼šè´ªå¿ƒæ€æƒ³ï¼Œä»å°åˆ°å¤§æ’åºæ‰€æœ‰è¾¹ï¼Œä½¿ç”¨å¹¶æŸ¥é›†ä¾æ¬¡åˆå¹¶ï¼Œå¹¶è·³è¿‡å½¢æˆç¯çš„è¾¹ï¼Œå³å¯å¾—åˆ°æœ€å°ç”Ÿæˆæ ‘ã€‚

### LeetCode 684. å†—ä½™è¿æ¥

[684. å†—ä½™è¿æ¥](https://leetcode-cn.com/problems/redundant-connection/)

æ ‘å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªè¿é€šä¸” **æ— ç¯** çš„ **æ— å‘** å›¾ã€‚ï¼ˆå…³é”®æ˜¯è¿™ä¸€å¥ï¼Œå‰©ä½™éƒ¨åˆ†é’¥åŒ™è”é€šæ²¡æœ‰ç¯çš„ï¼‰

ç»™å®šå¾€ä¸€æ£µ `n` ä¸ªèŠ‚ç‚¹ (èŠ‚ç‚¹å€¼ `1ï½n`) çš„æ ‘ä¸­æ·»åŠ ä¸€æ¡è¾¹åçš„å›¾ã€‚æ·»åŠ çš„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹åŒ…å«åœ¨ `1` åˆ° `n` ä¸­é—´ï¼Œä¸”è¿™æ¡é™„åŠ çš„è¾¹ä¸å±äºæ ‘ä¸­å·²å­˜åœ¨çš„è¾¹ã€‚å›¾çš„ä¿¡æ¯è®°å½•äºé•¿åº¦ä¸º `n` çš„äºŒç»´æ•°ç»„ `edges` ï¼Œ`edges[i] = [ai, bi]` è¡¨ç¤ºå›¾ä¸­åœ¨ `ai` å’Œ `bi` ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚

è¯·æ‰¾å‡ºä¸€æ¡å¯ä»¥åˆ å»çš„è¾¹ï¼Œåˆ é™¤åå¯ä½¿å¾—å‰©ä½™éƒ¨åˆ†æ˜¯ä¸€ä¸ªæœ‰ç€ `n` ä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚å¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œåˆ™è¿”å›æ•°ç»„ `edges` ä¸­æœ€åå‡ºç°çš„é‚£ä¸ªã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626676174-hOEVUL-image.png)

```
è¾“å…¥: edges = [[1,2], [1,3], [2,3]]
è¾“å‡º: [2,3]
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626676179-kGxcmu-image.png)

```
è¾“å…¥: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
è¾“å‡º: [1,4]
```



åˆ†æ

- ä¾æ¬¡å¯¹æ¯ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹è¿›è¡Œå¹¶æŸ¥é›†åˆå¹¶ã€‚
- å½“é‡åˆ°ä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹å·²ç»åˆå¹¶è¿‡ï¼Œå‘ç°äº†ç¯ï¼Œè¿”å›è¿™æ¡è¾¹ã€‚
- è¾“å‡ºå‚æ•°åªæœ‰ `edges` è€Œæ²¡æœ‰Nã€‚å¯¹äºæœ‰ `N` ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œåº”è¯¥æœ‰ `N-1` æ¡è¾¹ï¼Œå†åŠ ä¸Šé™„åŠ çš„ä¸€æ¡è¾¹ï¼Œå¾—åˆ°Næ¡è¾¹ã€‚å› æ­¤ `edges` çš„sizeå³ä¸ºNã€‚



ä»£ç 

```java
class Solution {

    int[] parent;

    public int[] findRedundantConnection(int[][] edges) {
        // N = edges.length
        parent = new int[edges.length + 1];
        for (int i = 0; i < parent.length; ++i) {
            parent[i] = i;
        }
      // 2. éå†äºŒç»´æ•°ç»„çš„é¡¶ç‚¹å¯¹
        for (int[] edge : edges) {
          // å¦‚æœèƒ½åŠ å…¥åˆ°å¹¶æŸ¥é›†è¿”å›trueï¼Œå¦åˆ™è¿”å›false
            if (!union(edge[0], edge[1])) {
                return edge;
            }
        }
        return new int[]{-1,-1};
    }

    public int findRoot(int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int x, int y) {
        x = findRoot(x);
        y = findRoot(y);
        if (x == y) {
            return false;
        }
        parent[x] = y;
        return true;
    }
}
```



æ ‡å‡†ç­”æ¡ˆï¼š

```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        UF uf = new UF(edges.length + 1);
        for (int[] edge : edges) {
            if (!uf.union(edge[0],edge[1])){
                return edge;
            }
        }
        return new int[]{-1,-1};
    }
    class UF{
        int count;//è”é€šé‡
        int[] parent;
        // è®°å½•æ ‘çš„â€œé‡é‡â€
        private int[] size;
        UF(int n){
            parent = new int[n];
            size = new int[n];
            this.count = n;
            for (int i = 0; i < n; i++) {
                parent[i]=i;//åˆå§‹åŒ–è‡ªå·±çš„ç¥–å…ˆä¸ºè‡ªå·±
                size[i]=1;
            }
        }
        boolean union(int p,int q){
            int rootP = find(p);
            int rootQ = find(q);
            if (rootQ==rootP) return false;
            if (size[rootP]>size[rootQ]){
                parent[rootQ]=rootP;
                size[rootP]+=size[rootQ];
                // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            }else {
                parent[rootP]=rootQ;
                size[rootQ]+=size[rootP];
            }
            count--;
            return true;
        }
        int find(int p){
            //æŸ¥æ‰¾ç¥–å…ˆ
            while (p!=parent[p]){
                parent[p]=parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
    }
}
```





## æœ€å°ç”Ÿæˆæ ‘

**æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼ŒMSTï¼‰**ï¼šæ— å‘è¿é€šå›¾ä¸­è¾¹æƒå’Œæœ€å°çš„ç”Ÿæˆæ ‘ï¼ˆæœ€çŸ­è·¯å¾„è¿æ¥æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

æ³¨æ„ï¼šåªæœ‰è¿é€šå›¾æ‰æœ‰ç”Ÿæˆæ ‘ï¼Œè€Œå¯¹äºéè¿é€šå›¾ï¼Œåªå­˜åœ¨ç”Ÿæˆæ£®æ—ã€‚

![img](https://www.paincker.com/graph-theory/img/https://www.paincker.com/wp-content/uploads/2020/04/mst.jpg)

### LeetCode 1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚

[1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚](https://leetcode-cn.com/problems/connecting-cities-with-minimum-cost/)

- åœ°å›¾ä¸Šæœ‰ N åº§åŸå¸‚ `1 ~ N`ã€‚
- ç»™å‡ºä¸€äº› `conections`ï¼Œå…¶ä¸­ `conections[i] = [city1, city2, cost]` è¡¨ç¤ºå°†åŸå¸‚ `city1` å’ŒåŸå¸‚ `city2` è¿æ¥æ‰€è¦çš„æˆæœ¬ï¼Œè¿æ¥æ˜¯åŒå‘çš„ã€‚
- è¿”å›è¿æ¥æ‰€æœ‰åŸå¸‚çš„æœ€å°æˆæœ¬ï¼Œå¦‚æœæ— æ³•è¿æ¥æ‰€æœ‰åŸå¸‚ï¼Œè¿”å› `-1`ã€‚

### Kruskalç®—æ³•

Kruskalç®—æ³• = è´ªå¿ƒ + å¹¶æŸ¥é›†

æµç¨‹ï¼šå°†æ‰€æœ‰è¾¹æŒ‰costä»å°åˆ°å¤§æ’åºï¼Œç„¶åä½¿ç”¨å¹¶æŸ¥é›†ä¾æ¬¡å°è¯•åˆå¹¶æ¯ä¸ªè¾¹ï¼š

- å¦‚æœåˆå¹¶æˆåŠŸï¼Œåˆ™åŠ å…¥è¿™æ¡è¾¹ã€‚
- å¦‚æœåˆå¹¶å¤±è´¥ï¼ˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åˆå¹¶è¿‡ï¼‰ï¼Œè¯´æ˜äº§ç”Ÿäº†ç¯ï¼Œåˆ™ä¸¢å¼ƒè¿™æ¡è¾¹ã€‚

é€šè¿‡å¹¶æŸ¥é›†åˆå¹¶åï¼Œæ¯ä¸ªè¿é€šåˆ†é‡èŠ‚ç‚¹éƒ½ä¼šæœ‰ç›¸åŒçš„rootï¼Œå› æ­¤æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹çš„rootï¼š

- å¦‚æœæ£€æŸ¥åˆ°åªæœ‰ä¸€ä¸ªrootï¼Œè¯´æ˜è¿™ä¸ªå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œæ˜¯è¿é€šå›¾ï¼Œè¿”å›costã€‚
- å¦‚æœæ£€æŸ¥åˆ°è¶…è¿‡ä¸€ä¸ªrootï¼Œè¯´æ˜è¿™ä¸ªå›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼Œä¸æ˜¯ä¸€ä¸ªè¿é€šå›¾ï¼Œè¿”å›-1ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
```

### Primç®—æ³•

Kruskalç®—æ³•æ¯æ¬¡æ·»åŠ ä¸€ä¸ªæœ€å°çš„è¾¹ï¼Œè€ŒPrimç®—æ³•åˆ™æ˜¯æ¯æ¬¡æ·»åŠ ä¸€ä¸ªè·ç¦»å·²é€‰å–èŠ‚ç‚¹é›†æœ€è¿‘çš„ç‚¹ã€‚

æµç¨‹ï¼š

1. é›†åˆSè¡¨ç¤ºå·²é€‰å–çš„èŠ‚ç‚¹é›†ã€‚
2. é€‰ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºèµ·å§‹èŠ‚ç‚¹ `a`ï¼Œæ”¾åˆ°é›†åˆSä¸­ï¼Œå¹¶æ›´æ–°å…¶ä»–èŠ‚ç‚¹åˆ°é›†åˆSçš„æœ€è¿‘è·ç¦»ã€‚å› ä¸ºå½“å‰Sä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ `a`ï¼Œå› æ­¤æ›´æ–°ä¸ºåˆ°èŠ‚ç‚¹ `a` çš„è·ç¦»ã€‚
3. é€‰å–è·ç¦»Sæœ€è¿‘çš„ä¸€ä¸ªèŠ‚ç‚¹ `b`ï¼Œæ”¾åˆ°é›†åˆSä¸­ï¼Œå¹¶æ›´æ–°å…¶ä»–èŠ‚ç‚¹åˆ°é›†åˆSçš„æœ€è¿‘è·ç¦»ã€‚ä¹Ÿå°±æ˜¯èŠ‚ç‚¹ `i` çš„è·ç¦»æ›´æ–°ä¸º `min { adj[a][i], adj[b][i] }`ã€‚
4. ç»§ç»­é€‰å–ã€æ›´æ–°ï¼Œç›´åˆ°Nä¸ªèŠ‚ç‚¹éƒ½è¢«é€‰å–ã€‚

å®é™…æäº¤å‘ç°ï¼ŒPrimç®—æ³•æ•ˆæœè¿œä¸å¦‚Kruskalå¥½ã€‚

- é¢˜ç›®ç»™çš„æ˜¯è¾¹ï¼ˆconnectionsï¼‰ï¼Œè€Œä½¿ç”¨Primç®—æ³•ï¼Œéœ€è¦å¿«é€Ÿå¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚å¦‚æœæ¯æ¬¡éƒ½ç›´æ¥éå†connectionsï¼Œå¤æ‚åº¦å¤ªé«˜ï¼Œå› æ­¤éœ€è¦å…ˆè½¬æ¢æˆé‚»æ¥çŸ©é˜µæˆ–é‚»æ¥è¡¨ã€‚é€‰æ‹©åˆé€‚çš„é‚»æ¥çŸ©é˜µæˆ–é‚»æ¥è¡¨ï¼Œæ˜¯è§£å†³æœ¬é¢˜çš„ä¸€ä¸ªå…³é”®ã€‚
- å¦å¤–ä¸€ä¸ªå…³é”®ç‚¹å°±æ˜¯ï¼Œè·å–è·ç¦»æœ€å°çš„èŠ‚ç‚¹ï¼Œå¯ä»¥ç›´æ¥éå†ï¼Œä¹Ÿå¯ä»¥å€ŸåŠ© `PriorityQueue` å®ç°ã€‚

#### è§£æ³•1ï¼šè¶…å‡ºå†…å­˜é™åˆ¶

æœ€åŸºç¡€çš„Primç®—æ³•å®ç°ï¼Œä½¿ç”¨äºŒç»´æ•°ç»„ä¿å­˜é‚»æ¥çŸ©é˜µï¼Œæš´åŠ›æœç´¢æŸ¥æ‰¾è·ç¦»æœ€å°çš„èŠ‚ç‚¹ã€‚

ä»£ç åº”è¯¥æ˜¯æ­£ç¡®çš„ï¼Œåœ¨ç®€å•çš„æµ‹è¯•ç”¨ä¾‹ä¸­è¿è¡Œæ˜¯æ­£ç¡®çš„ã€‚ä½†æ˜¯ç”±äºé‚»æ¥çŸ©é˜µå¤ªå¤§ï¼Œå¯¼è‡´è¶…å‡ºäº†å†…å­˜é™åˆ¶ï¼Œæäº¤æœªé€šè¿‡ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
```

#### è§£æ³•2ï¼šè¶…å‡ºæ—¶é—´é™åˆ¶

ä¼˜åŒ–Primç®—æ³•ï¼Œä½¿ç”¨HashMapæ•°ç»„ä¿å­˜é¢†æ¥è¡¨ï¼Œå€ŸåŠ©PriorityQueueé€‰å–è·ç¦»æœ€å°çš„èŠ‚ç‚¹ã€‚

è¶…å‡ºæ—¶é—´é™åˆ¶ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph[i].get(j):
        //     x: distance
        //     null: not reachable
        Map<Integer, Integer>[] graph = new HashMap[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new HashMap<>();
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u].put(v, w);
            graph[v].put(u, w);
        }

        // heap: candidates
        //     int[0]: distance from added nodes
        //     int[1]: node
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[0] - b[0]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{0, 1});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int dist = min[0];
            int node = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            for (int i = 2; i <= N; ++i) {
                if (added[i]) continue;
                Integer d = graph[node].get(i);
                if (d != null) { // d == null: not reachable
                    heap.offer(new int[]{d, i});
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[1];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

#### è§£æ³•3ï¼šé€šè¿‡ï¼Œ67 ms

æ­£åœ¨æ€€ç–‘æ˜¯ä¸æ˜¯è‡ªå·±å†™é”™äº†Primç®—æ³•çš„æ—¶å€™ï¼Œå€Ÿé‰´äº†è¯„è®ºåŒºçš„æ€è·¯ï¼Œé‡æ–°ä¼˜åŒ–äº†é‚»æ¥è¡¨çš„è¡¨ç¤ºæ–¹æ³•ï¼Œä½¿ç”¨ `HashMap -> List -> int[]` çš„å½¢å¼ã€‚

è¿™æ ·åœ¨æ›´æ–°è·ç¦»æ—¶ï¼Œä¸éœ€è¦å†è¿›è¡Œå¤æ‚çš„éå†ï¼Œä¹Ÿä¸éœ€è¦åˆ›å»ºå¾ˆå¤šæ•°ç»„ï¼ˆHashMapé‚»æ¥è¡¨å’ŒPriorityQueueä¸­çš„å…ƒç´ æ ¼å¼æ˜¯ç›¸åŒçš„ï¼Œéƒ½æ˜¯ `[node, distance]`ï¼‰ï¼Œå¤§å¤§æé«˜äº†æ€§èƒ½ã€‚

ç»ˆäºæäº¤é€šè¿‡ï¼Œè€—æ—¶67msã€‚ä½œä¸ºå¯¹æ¯”ï¼ŒKruskalç®—æ³•çš„è€—æ—¶æ˜¯27msï¼Œä¸”å†™èµ·æ¥æ›´å®¹æ˜“ã€‚

```
class Solution {

    public int minimumCost(int N, int[][] connections) {

        // graph.get(i).get(x):
        //     int[0]: node
        //     int[1]: distance from [i] to [node]
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            List<int[]> list1 = graph.get(u);
            if (list1 == null) {
                list1 = new LinkedList<>();
                graph.put(u, list1);
            }
            list1.add(new int[]{v,w});

            List<int[]> list2 = graph.get(v);
            if (list2 == null) {
                list2 = new LinkedList<>();
                graph.put(v, list2);
            }
            list2.add(new int[]{u,w});
        }

        // heap: candidates
        //     int[0]: node
        //     int[1]: distance from one of added nodes
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[1] - b[1]);
        // added nodes
        boolean[] added = new boolean[N+1];

        // add node [1] to the candidate collection
        heap.offer(new int[]{1, 0});

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int[] min = findMin(heap, added);

            // no reachable node found
            if (min == null) {
                return -1;
            }

            int node = min[0];
            int dist = min[1];

            // add [node]
            cost += dist;
            added[node] = true;

            // add candidates with distance from [node]
            List<int[]> list = graph.get(node);
            if (list != null) {
                for (int[] e : list) {
                    heap.offer(e);
                }
            }
        }
        return cost;
    }

    public int[] findMin(PriorityQueue<int[]> heap, boolean[] added) {
        while (heap.size() > 0) {
            int[] n = heap.poll();
            int node = n[0];
            if (!added[node]) {
                return n;
            }
        }
        return null;
    }
}
```

## äºŒåˆ†å›¾ Bipartite graph

**ç»™ä½ ä¸€å¹…ã€Œå›¾ã€ï¼Œè¯·ä½ ç”¨ä¸¤ç§é¢œè‰²å°†å›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹ç€è‰²ï¼Œä¸”ä½¿å¾—ä»»æ„ä¸€æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹çš„é¢œè‰²éƒ½ä¸ç›¸åŒï¼Œä½ èƒ½åšåˆ°å—**ï¼Ÿ

è¿™å°±æ˜¯å›¾çš„ã€ŒåŒè‰²é—®é¢˜ã€ï¼Œå…¶å®è¿™ä¸ªé—®é¢˜å°±ç­‰åŒäºäºŒåˆ†å›¾çš„åˆ¤å®šé—®é¢˜ï¼Œå¦‚æœä½ èƒ½å¤ŸæˆåŠŸåœ°å°†å›¾æŸ“è‰²ï¼Œé‚£ä¹ˆè¿™å¹…å›¾å°±æ˜¯ä¸€å¹…äºŒåˆ†å›¾ï¼Œåä¹‹åˆ™ä¸æ˜¯ï¼š

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-2c7cf3ff0aa23b08c7bb2c56a429656d_r.jpg)

  

åœ¨å…·ä½“è®²è§£äºŒåˆ†å›¾åˆ¤å®šç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥è¯´è¯´è®¡ç®—æœºå¤§ä½¬ä»¬é—²ç€æ— èŠè§£å†³åŒè‰²é—®é¢˜çš„ç›®çš„æ˜¯ä»€ä¹ˆã€‚

é¦–å…ˆï¼ŒäºŒåˆ†å›¾ä½œä¸ºä¸€ç§ç‰¹æ®Šçš„å›¾æ¨¡å‹ï¼Œä¼šè¢«å¾ˆå¤šé«˜çº§å›¾ç®—æ³•ï¼ˆæ¯”å¦‚æœ€å¤§æµç®—æ³•ï¼‰ç”¨åˆ°ã€‚

ä»ç®€å•å®ç”¨çš„è§’åº¦æ¥çœ‹ï¼ŒäºŒåˆ†å›¾ç»“æ„åœ¨æŸäº›åœºæ™¯å¯ä»¥æ›´é«˜æ•ˆåœ°å­˜å‚¨æ•°æ®ã€‚

æ¯”å¦‚å‰æ–‡ [ä»‹ç»ã€Šç®—æ³• 4ã€‹](https://labuladong.gitee.io/algo/) æ–‡ç« ä¸­çš„ä¾‹å­ï¼Œå¦‚ä½•å­˜å‚¨ç”µå½±æ¼”å‘˜å’Œç”µå½±ä¹‹é—´çš„å…³ç³»ï¼Ÿ

å¦‚æœç”¨å“ˆå¸Œè¡¨å­˜å‚¨ï¼Œéœ€è¦ä¸¤ä¸ªå“ˆå¸Œè¡¨åˆ†åˆ«å­˜å‚¨ã€Œæ¯ä¸ªæ¼”å‘˜åˆ°ç”µå½±åˆ—è¡¨ã€çš„æ˜ å°„å’Œã€Œæ¯éƒ¨ç”µå½±åˆ°æ¼”å‘˜åˆ—è¡¨ã€çš„æ˜ å°„ã€‚

ä½†å¦‚æœç”¨ã€Œå›¾ã€ç»“æ„å­˜å‚¨ï¼Œå°†ç”µå½±å’Œå‚æ¼”çš„æ¼”å‘˜è¿æ¥ï¼Œå¾ˆè‡ªç„¶åœ°å°±æˆä¸ºäº†ä¸€å¹…äºŒåˆ†å›¾ï¼š

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-5b7aa37d036fc8373fe634cd2217850e_r.jpg)

  

==æ¯ä¸ªç”µå½±èŠ‚ç‚¹çš„ç›¸é‚»èŠ‚ç‚¹å°±æ˜¯å‚æ¼”è¯¥ç”µå½±çš„æ‰€æœ‰æ¼”å‘˜ï¼Œæ¯ä¸ªæ¼”å‘˜çš„ç›¸é‚»èŠ‚ç‚¹å°±æ˜¯è¯¥æ¼”å‘˜å‚æ¼”è¿‡çš„æ‰€æœ‰ç”µå½±ï¼Œéå¸¸æ–¹ä¾¿ç›´è§‚ã€‚==

ç±»æ¯”è¿™ä¸ªä¾‹å­ï¼Œå…¶å®ç”Ÿæ´»ä¸­ä¸å°‘å®ä½“çš„å…³ç³»éƒ½èƒ½è‡ªç„¶åœ°å½¢æˆäºŒåˆ†å›¾ç»“æ„ï¼Œæ‰€ä»¥åœ¨æŸäº›åœºæ™¯ä¸‹å›¾ç»“æ„ä¹Ÿå¯ä»¥ä½œä¸ºå­˜å‚¨é”®å€¼å¯¹çš„æ•°æ®ç»“æ„ï¼ˆç¬¦å·è¡¨ï¼‰ã€‚



### äºŒåˆ†å›¾åˆ¤å®šæ€è·¯

åˆ¤å®šäºŒåˆ†å›¾çš„ç®—æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯ç”¨ä»£ç è§£å†³ã€ŒåŒè‰²é—®é¢˜ã€ã€‚

**è¯´ç™½äº†å°±æ˜¯éå†ä¸€éå›¾ï¼Œä¸€è¾¹éå†ä¸€éæŸ“è‰²ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½ç”¨ä¸¤ç§é¢œè‰²ç»™æ‰€æœ‰èŠ‚ç‚¹æŸ“è‰²ï¼Œä¸”ç›¸é‚»èŠ‚ç‚¹çš„é¢œè‰²éƒ½ä¸ç›¸åŒ**ã€‚

æ—¢ç„¶è¯´åˆ°éå†å›¾ï¼Œä¹Ÿä¸æ¶‰åŠæœ€çŸ­è·¯å¾„ä¹‹ç±»çš„ï¼Œå½“ç„¶æ˜¯ DFS ç®—æ³•å’Œ BFS çš†å¯äº†ï¼ŒDFS ç®—æ³•ç›¸å¯¹æ›´å¸¸ç”¨äº›ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å¦‚ä½•ç”¨ DFS ç®—æ³•åˆ¤å®šåŒè‰²å›¾ã€‚

é¦–å…ˆï¼Œå†™å‡ºå›¾çš„éå†æ¡†æ¶ï¼š

```java
/* äºŒå‰æ ‘éå†æ¡†æ¶ */
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    traverse(root.right);
}

/* å¤šå‰æ ‘éå†æ¡†æ¶ */
void traverse(Node root) {
    if (root == null) return;
    for (Node child : root.children)
        traverse(child);
}

/* å›¾éå†æ¡†æ¶ */
boolean[] visited;
void traverse(Graph graph, int v) {
    // é˜²æ­¢èµ°å›å¤´è·¯è¿›å…¥æ­»å¾ªç¯
    if (visited[v]) return;
    // å‰åºéå†ä½ç½®ï¼Œæ ‡è®°èŠ‚ç‚¹ v å·²è®¿é—®
    visited[v] = true;
    for (TreeNode neighbor : graph.neighbors(v))
        traverse(graph, neighbor);
}
```

å› ä¸ºå›¾ä¸­å¯èƒ½å­˜åœ¨ç¯ï¼Œæ‰€ä»¥ç”¨ `visited` æ•°ç»„é˜²æ­¢èµ°å›å¤´è·¯ã€‚

**è¿™é‡Œå¯ä»¥çœ‹åˆ°æˆ‘ä¹ æƒ¯æŠŠ return è¯­å¥éƒ½æ”¾åœ¨å‡½æ•°å¼€å¤´ï¼Œå› ä¸ºä¸€èˆ¬ return è¯­å¥éƒ½æ˜¯ base caseï¼Œé›†ä¸­æ”¾åœ¨ä¸€èµ·å¯ä»¥è®©ç®—æ³•ç»“æ„æ›´æ¸…æ™°**ã€‚

å…¶å®ï¼Œå¦‚æœä½ æ„¿æ„ï¼Œä¹Ÿå¯ä»¥æŠŠ if åˆ¤æ–­æ”¾åˆ°å…¶å®ƒåœ°æ–¹ï¼Œæ¯”å¦‚å›¾éå†æ¡†æ¶å¯ä»¥ç¨å¾®æ”¹æ”¹ï¼š

```java
/* å›¾éå†æ¡†æ¶ */
boolean[] visited;
void traverse(Graph graph, int v) {
    // å‰åºéå†ä½ç½®ï¼Œæ ‡è®°èŠ‚ç‚¹ v å·²è®¿é—®
    visited[v] = true;
    for (int neighbor : graph.neighbors(v)) {
        if (!visited[neighbor]) {
            // åªéå†æ²¡æ ‡è®°è¿‡çš„ç›¸é‚»èŠ‚ç‚¹
            traverse(graph, neighbor);
        }
    }
}
```

è¿™ç§å†™æ³•æŠŠå¯¹ `visited` çš„åˆ¤æ–­æ”¾åˆ°é€’å½’è°ƒç”¨ä¹‹å‰ï¼Œå’Œä¹‹å‰çš„å†™æ³•å”¯ä¸€çš„ä¸åŒå°±æ˜¯ï¼Œä½ éœ€è¦ä¿è¯è°ƒç”¨ `traverse(v)` çš„æ—¶å€™ï¼Œ`visited[v] == false`ã€‚

ä¸ºä»€ä¹ˆè¦ç‰¹åˆ«è¯´è¿™ç§å†™æ³•å‘¢ï¼Ÿå› ä¸ºæˆ‘ä»¬åˆ¤æ–­äºŒåˆ†å›¾çš„ç®—æ³•ä¼šç”¨åˆ°è¿™ç§å†™æ³•ã€‚

**å›é¡¾ä¸€ä¸‹äºŒåˆ†å›¾æ€ä¹ˆåˆ¤æ–­ï¼Œå…¶å®å°±æ˜¯è®© `traverse` å‡½æ•°ä¸€è¾¹éå†èŠ‚ç‚¹ï¼Œä¸€è¾¹ç»™èŠ‚ç‚¹æŸ“è‰²ï¼Œå°è¯•è®©æ¯å¯¹ç›¸é‚»èŠ‚ç‚¹çš„é¢œè‰²éƒ½ä¸ä¸€æ ·**ã€‚

æ‰€ä»¥ï¼Œåˆ¤å®šäºŒåˆ†å›¾çš„ä»£ç é€»è¾‘å¯ä»¥è¿™æ ·å†™ï¼š

```java
/* å›¾éå†æ¡†æ¶ */
void traverse(Graph graph, boolean[] visited, int v) {
    visited[v] = true;
    // éå†èŠ‚ç‚¹ v çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ neighbor
    for (int neighbor : graph.neighbors(v)) {
        if (!visited[neighbor]) {
            // ç›¸é‚»èŠ‚ç‚¹ neighbor æ²¡æœ‰è¢«è®¿é—®è¿‡
            // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ neighbor æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
            traverse(graph, visited, neighbor);
        } else {
            // ç›¸é‚»èŠ‚ç‚¹ neighbor å·²ç»è¢«è®¿é—®è¿‡
            // é‚£ä¹ˆåº”è¯¥æ¯”è¾ƒèŠ‚ç‚¹ neighbor å’ŒèŠ‚ç‚¹ v çš„é¢œè‰²
            // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
        }
    }
}
```



BFS

```java
// ä» start èŠ‚ç‚¹å¼€å§‹è¿›è¡Œ BFS éå†
private void bfs(int[][] graph, int start) {
    Queue<Integer> q = new LinkedList<>();
    visited[start] = true;
    q.offer(start);

    while (!q.isEmpty() && ok) {
        int v = q.poll();
        // ä»èŠ‚ç‚¹ v å‘æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹æ‰©æ•£
        for (int w : graph[v]) {
            if (!visited[w]) {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v];
                // æ ‡è®° w èŠ‚ç‚¹ï¼Œå¹¶æ”¾å…¥é˜Ÿåˆ—
                visited[w] = true;
                q.offer(w);
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if (color[w] == color[v]) {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false;
                }
            }
        }
    }
}
```



### LeetCode 785. åˆ¤æ–­äºŒåˆ†å›¾

[785. åˆ¤æ–­äºŒåˆ†å›¾](https://leetcode-cn.com/problems/is-graph-bipartite/)

ä»¥äºŒç»´æ•°ç»„å½¢å¼çš„é‚»æ¥è¡¨æ–¹å¼ç»™å‡ºæ— å‘å›¾ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºäºŒåˆ†å›¾ã€‚

æ€è·¯ï¼š

1. å¯¹èŠ‚ç‚¹è¿›è¡Œç€è‰²ï¼Œ`color == 0` è¡¨ç¤ºæœªç€è‰²ï¼Œ`color == 1` æˆ– `color == -1`è¡¨ç¤ºç€è‰²ã€‚
2. ä»æ¯ä¸ªæœªç€è‰²çš„èŠ‚ç‚¹å¼€å§‹ï¼Œå°†å…¶ç€è‰²ï¼Œå¹¶è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆæ¯æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢éƒ½ä¼šéå†å®Œä¸€ä¸ªè¿é€šåˆ†é‡ï¼‰ã€‚
3. æ¯é‡åˆ°ä¸€æ¡è¾¹ï¼Œåˆ¤æ–­å…¶å¦ä¸€ä¸ªç‚¹çš„é¢œè‰²ï¼š
   - å¦‚æœæ²¡æœ‰ç€è‰²ï¼Œå°±è®¾ç½®æˆç›¸åçš„é¢œè‰²ï¼Œå¹¶ç»§ç»­æ·±å…¥æœç´¢ã€‚
   - å¦‚æœå·²ç»ç€è‰²ï¼Œå¹¶ä¸”å’Œå½“å‰ç‚¹é¢œè‰²ç›¸åŒï¼Œè¯´æ˜ä¸æ˜¯äºŒåˆ†å›¾ã€‚
   - å¦‚æœå·²ç»ç€è‰²ï¼Œå¹¶ä¸”å’Œå½“å‰ç‚¹é¢œè‰²ä¸åŒï¼Œå¿½ç•¥ï¼ˆç»§ç»­å¾ªç¯ï¼‰ã€‚

ç»“åˆä¹‹å‰çš„ä»£ç æ¡†æ¶ï¼Œæˆ‘ä»¬å¯ä»¥é¢å¤–ä½¿ç”¨ä¸€ä¸ª `color` æ•°ç»„æ¥è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„é¢œè‰²ï¼Œä»è€Œå†™å‡ºè§£æ³•ä»£ç ï¼š

```java
// è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
private boolean ok = true;
// è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
private boolean[] color;
// è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
private boolean[] visited;

// ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color =  new boolean[n];
    visited =  new boolean[n];
    // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
    // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
    // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }
    return ok;
}

// DFS éå†æ¡†æ¶
private void traverse(int[][] graph, int v) {
    // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
    if (!ok) return;

    visited[v] = true;
    for (int w : graph[v]) {
        if (!visited[w]) {
            // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
            // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
            color[w] = !color[v];
            // ç»§ç»­éå† w
            traverse(graph, w);
        } else {
            // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
            // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
            if (color[w] == color[v]) {
                // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                ok = false;
            }
        }
    }
}
```

è¿™å°±æ˜¯è§£å†³ã€ŒåŒè‰²é—®é¢˜ã€çš„ä»£ç ï¼Œå¦‚æœèƒ½æˆåŠŸå¯¹æ•´å¹…å›¾æŸ“è‰²ï¼Œåˆ™è¯´æ˜è¿™æ˜¯ä¸€å¹…äºŒåˆ†å›¾ï¼Œå¦åˆ™å°±ä¸æ˜¯äºŒåˆ†å›¾ã€‚

æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹ BFS ç®—æ³•çš„é€»è¾‘ï¼š

```java
// è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
private boolean ok = true;
// è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
private boolean[] color;
// è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
private boolean[] visited;

public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color =  new boolean[n];
    visited =  new boolean[n];

    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            // æ”¹ä¸ºä½¿ç”¨ BFS å‡½æ•°
            bfs(graph, v);
        }
    }

    return ok;
}

// ä» start èŠ‚ç‚¹å¼€å§‹è¿›è¡Œ BFS éå†
private void bfs(int[][] graph, int start) {
    Queue<Integer> q = new LinkedList<>();
    visited[start] = true;
    q.offer(start);

    while (!q.isEmpty() && ok) {
        int v = q.poll();
        // ä»èŠ‚ç‚¹ v å‘æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹æ‰©æ•£
        for (int w : graph[v]) {
            if (!visited[w]) {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v];
                // æ ‡è®° w èŠ‚ç‚¹ï¼Œå¹¶æ”¾å…¥é˜Ÿåˆ—
                visited[w] = true;
                q.offer(w);
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if (color[w] == color[v]) {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false;
                }
            }
        }
    }
}
```

æ ¸å¿ƒé€»è¾‘å’Œåˆšæ‰å®ç°çš„ `traverse` å‡½æ•°ï¼ˆDFS ç®—æ³•ï¼‰å®Œå…¨ä¸€æ ·ï¼Œä¹Ÿæ˜¯æ ¹æ®ç›¸é‚»èŠ‚ç‚¹ `v` å’Œ `w` çš„é¢œè‰²æ¥è¿›è¡Œåˆ¤æ–­çš„ã€‚





### åŠ›æ‰£ç¬¬ 886 é¢˜ã€Œå¯èƒ½çš„äºŒåˆ†æ³•ã€

  

![](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/v2-59b2765ec902cdf39b758df91a370d2a_r.jpg)

  

å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š

```java
boolean possibleBipartition(int n, int[][] dislikes);
```

**å…¶å®è¿™é¢˜è€ƒå¯Ÿçš„å°±æ˜¯äºŒåˆ†å›¾çš„åˆ¤å®š**ï¼š

å¦‚æœä½ æŠŠæ¯ä¸ªäººçœ‹åšå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œç›¸äº’è®¨åŒçš„å…³ç³»çœ‹åšå›¾ä¸­çš„è¾¹ï¼Œé‚£ä¹ˆ `dislikes` æ•°ç»„å°±å¯ä»¥æ„æˆä¸€å¹…å›¾ï¼›

åˆå› ä¸ºé¢˜ç›®è¯´äº’ç›¸è®¨åŒçš„äººä¸èƒ½æ”¾åœ¨åŒä¸€ç»„é‡Œï¼Œç›¸å½“äºå›¾ä¸­çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹éƒ½è¦æ”¾è¿›ä¸¤ä¸ªä¸åŒçš„ç»„ï¼›

é‚£å°±å›åˆ°äº†ã€ŒåŒè‰²é—®é¢˜ã€ï¼Œå¦‚æœèƒ½å¤Ÿç”¨ä¸¤ç§é¢œè‰²ç€è‰²æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸”ç›¸é‚»èŠ‚ç‚¹é¢œè‰²éƒ½ä¸åŒï¼Œé‚£ä¹ˆä½ æŒ‰ç…§é¢œè‰²æŠŠè¿™äº›èŠ‚ç‚¹åˆ†æˆä¸¤ç»„ä¸å°±è¡Œäº†å˜›ã€‚

æ‰€ä»¥è§£æ³•å°±å‡ºæ¥äº†ï¼Œæˆ‘ä»¬æŠŠ `dislikes` æ„é€ æˆä¸€å¹…å›¾ï¼Œç„¶åæ‰§è¡ŒäºŒåˆ†å›¾çš„åˆ¤å®šç®—æ³•å³å¯ï¼š

```java
private boolean ok = true;
private boolean[] color;
private boolean[] visited;

public boolean possibleBipartition(int n, int[][] dislikes) {
    // å›¾èŠ‚ç‚¹ç¼–å·ä» 1 å¼€å§‹
    color = new boolean[n + 1];
    visited = new boolean[n + 1];
    // è½¬åŒ–æˆé‚»æ¥è¡¨è¡¨ç¤ºå›¾ç»“æ„
    List<Integer>[] graph = buildGraph(n, dislikes);

    for (int v = 1; v <= n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }

    return ok;
}

// å»ºå›¾å‡½æ•°
private List<Integer>[] buildGraph(int n, int[][] dislikes) {
    // å›¾èŠ‚ç‚¹ç¼–å·ä¸º 1...n
    List<Integer>[] graph = new LinkedList[n + 1];
    for (int i = 1; i <= n; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : dislikes) {
        int v = edge[1];
        int w = edge[0];
        // ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
        // v -> w
        graph[v].add(w);
        // w -> v
        graph[w].add(v);
    }
    return graph;
}

// å’Œä¹‹å‰çš„ traverse å‡½æ•°å®Œå…¨ç›¸åŒ
private void traverse(List<Integer>[] graph, int v) {
    if (!ok) return;
    visited[v] = true;
    for (int w : graph[v]) {
        if (!visited[w]) {
            color[w] = !color[v];
            traverse(graph, w);
        } else {
            if (color[w] == color[v]) {
                ok = false;
            }
        }
    }
}
```
