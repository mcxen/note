

## 中断
中断是进去核心的唯一方式
![c](https://quemingfei.com/upload/2021/03/image-e4c29a8dcee849e79a927cf2dd55ca3c.png)

## 系统调用 system call
![](https://quemingfei.com/upload/2021/03/image-53d46ab3cb08451ca97036eee41ef4a6.png)

系统调用
避免进程随意使用硬件，系统对哥哥应用程序统一管理。

系统调用是在核心态，库函数会对系统调用进一步隐藏封装。📦

也有一些库函数不需要和系统调用扯上关系，比如取绝对值。

系统调用的主要作用如下：

1）系统调用为用户空间提供了一种硬件的抽象接口，这样，当需要读写文件时，应用程序就可以不用管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型；

2）系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限、用户类型和其他一些规则对需要进行的访问进行判断；

3）系统调用是实现多任务和虚拟内存的前提。

发起陷入指令trap是在用户态，在用户态执行，但是对应的系统调用的处理是在核心态进行的，陷入指令是唯一一个只能在用户态执行的，不可在核心态执行的指令。


# 进程

面对多道程序技术，内存会存放多道程序，系统会对每一个程序配置一个数据结构，PCB进程控制块,

进程实体指的是：PCB 程序段  数据段

撤销一个进程就是撤销的进程实体的PCB。PCB是进程存在的唯一标志。

进程是程序的一次执行过程，具有动态性，有多种定义。进程实体具有静态性。


进程有地址空间。
内核，操作系统的代码本身就是内核，占用空间，有地址内核地址和用户地址空间是分开的，

内核态， 内核的权限和内核的代码，可以访问硬件
用户态。上层应用程序的活动空间，只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。

为什么要有用户态和内核态？

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。

进程组织 索引方式，链接方式

执行指针、就绪表指针、阻塞表指针



## stack
栈是存放进程地址

## PCB
Process Control Block 进程控制块 ，分时复用

- 进程描述信息

    进程标志符 PID
    用户标志符 UID

- 进程状态和优先级
- 资源分配清单

