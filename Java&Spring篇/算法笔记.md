# 数据结构模板

## 链表问题

### [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626420025-fZfzMX-image.png" alt="img" style="zoom:50%;" />

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```





```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
//        使用两个辅助栈
        ArrayDeque<Integer> stk1 = new ArrayDeque<>();
        ArrayDeque<Integer> stk2 = new ArrayDeque<>();
        while (l1!=null){
            stk1.push(l1.val);
            l1 = l1.next;
        }
        while (l2!=null){
            stk2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;//储存进位
        ListNode res = null;//储存结果
        while (!stk1.isEmpty()||!stk2.isEmpty()||carry!=0) {
            int digit1 = stk1.isEmpty()?0:stk1.pop();
            int digit2 = stk2.isEmpty()?0:stk2.pop();
            int sum = digit1+digit2+carry;
            carry = sum/10;
            sum = sum%10;
            ListNode tmp = new ListNode(sum);
            tmp.next = res;
            res = tmp;
        }
        return res;
    }
}
```





### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

` L0 → L1 → … → Ln-1 → Ln `
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



**示例 1:**

![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        ////将主链表划分为 前一段子链表和后一段子链表，
        // 对于后一段子链表进行翻转，同时对于这两条链表进行重构;
        ArrayDeque<ListNode> deque = new ArrayDeque<ListNode>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        while (head!=null) {
            ListNode next = head.next;
            head.next = null;
            deque.add(head);
            head = next;
        }
        ListNode curr = dummy;
        while (!deque.isEmpty()) {
            ListNode start = deque.pollFirst();
            curr.next = start;
            //循环遍历deque双端，直至队列为空
            if (!deque.isEmpty()){
                ListNode last = deque.pollLast();
                start.next = last;//curr-》start-》last
                curr = last;//curr专程last
            }else {
                start.next = null;
            }
        }
        return;
    }
}
```



### 两个链表合并

```java
public ListNode mergeTwoLists(ListNode a, ListNode b) {
    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode(0);
    ListNode tail = head, la = a, lb = b;
    while (la != null && lb != null) {
        if (la.val < lb.val) {
            tail.next = la;
            la = la.next;
        } else {
            tail.next = lb;
            lb = lb.next;
        }
        tail = tail.next;
    }
    tail.next = (la != null ? la : lb);
    return head.next;
}

```

> 多个链表合并可以遍历，
>
> ```java
> public ListNode mergeKLists(ListNode[] lists) {
>     ListNode ans = null;
>     for (ListNode list : lists) {
>         ans = mergeTwoLists(ans,list);
>     }
>     return ans;
> }
> ```

## 栈的使用

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```



```java
class Solution {
    public int trap(int[] height) {
        int count = 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        //维持一个递减的栈，递增了显然就是有一个坑
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[stack.peek()]<height[i]){
                //出现递增的时候
                int popped = stack.pop();
                while (!stack.isEmpty() && height[popped]==height[stack.peek()])
                    stack.pop();//继续弹出去
                if (!stack.isEmpty()){
                    int min = Math.min(height[stack.peek()], height[i]);
                    count+=(min-height[popped])*(i- stack.peek()-1);
                }
            }
            stack.push(i);
        }
        return count;
    }
}

```







### 逆波兰算法

### [剑指 Offer II 036. 后缀表达式](https://leetcode.cn/problems/8Zf90G/)

根据[ 逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437)，求该后缀表达式的计算结果。

有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 **说明：**

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

 **示例 1：**

```sh
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。



```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<>();
        for(int i = 0;i<tokens.length;i++){
            String token = tokens[i];
            if(isNumber(token)) {
                stack.push(Integer.parseInt(token));//压入数字到栈厘米
            }else{
                int num2 = stack.pop();
                int num1 = stack.pop();//弹出两个就是数组
                switch(token){
                    case "+":{
                        stack.push(num1+num2);
                        break;
                    }
                    case "-":{
                        stack.push(num1-num2);
                        break;
                    }
                    case "*":{
                        stack.push(num1*num2);
                        break;
                    }
                    case "/":{
                        stack.push(num1/num2);
                        break;
                    }
                }
            }
        }
        return stack.pop();
    }
    public boolean isNumber(String s){
        return !("+".equals(s)||"-".equals(s)||"*".equals(s)||"/".equals(s));
        // 既不是加减乘除就是对的数字了
    }
}
```

> 你想哈，这个数字可能是几百上千的，所以我们不能说用判断0到9就行了

## 哈希算法

### 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums==null||nums.length==0) return ans;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp =target-nums[i];
            if(map.containsKey(tmp)) {
                return new int[]{i,map.get(tmp)};
            }
            map.put(nums[i],i);
        }
        return ans;
    }
}
```

### 四数之和II

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2



实际就是化简为两个数之和

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int tmp = i + j;
                map.put(tmp,map.getOrDefault(tmp,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int tmp = i + j;
                // 直接寻找相对的数是否存在，存在就直接可以算作是一组数，几个value就是几组
                if (map.containsKey(0-tmp))
                    ans+=map.get(0-tmp);
            }
        }
        return ans;
    }
}
```



### 哈希法求解不含重复字串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int j = 0;
        // p w w e k
        // j   i
        //找到w上一次的位置设置为最长子串的起始点。
        if (s.length()==1) return 1;
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            ans = Math.max(ans,i-j+1);
        }
        return ans;
    }
}
```



给定一个字符串数组 `strs` ，将 **变位词** 组合在一起。 可以按任意顺序返回结果列表。

**注意：**若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。



**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```



由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> map = new HashMap<>();
//        map存放排好序了的string的数组
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String s = new String(chars);//将排好序的重新转化成string
            List<String> path = map.getOrDefault(s, new ArrayList<>());//取出来s对应的list，
            path.add(str);
            map.put(s,path);//重新再放回去
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

### [249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)

给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：`"abc" -> "bcd"`。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：

```
"abc" -> "bcd" -> ... -> "xyz"
```

给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。

**示例：**

```
输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]
输出：
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]
解释：可以认为字母表首尾相接，所以 'z' 的后续为 'a'，所以 ["az","ba"] 也满足 “移位” 操作规律。
```

```java
class Solution {
    public List<List<String>> groupStrings(String[] strings) {
         if (strings==null || strings.length==0) return new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();//存储
        for (String string : strings) {
            StringBuilder sb = new StringBuilder();
            for (char c : string.toCharArray()) {
                sb.append("#");
                int shift = (c-string.charAt(0)+26)%26;
                sb.append(shift);
            }
            String key = sb.toString();
            if (!map.containsKey(key)) map.put(key,new ArrayList<String>());
            map.get(key).add(string);
        }
        return new ArrayList<>(map.values());
    }
}
```



> 记录移动的位置的时候，存储有一个循环的 时候我们可以加一个26再对26取一个模
>
> `int shift = (c-string.charAt(0)+26)%26;` 就可以实现循环了，比如az就是ba的相似的

## 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

1. 单调栈里元素是递增呢？ 还是递减呢？

**顺序的描述为 从栈头到栈底的顺序**，从左到右或者从前到后，

```txt
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 
输出: [3,3,5,5,6,7] 
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```

这一题是滑动窗口，所以单调栈的构造需要确定是不是在k的范围内，

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();
        //准备单调队列
        for (int right = 0; right < nums.length; right++) {
//            队首元素就是该窗口内的最大值。
            while (!queue.isEmpty() && nums[right]>=nums[queue.peekLast()]) {
                queue.removeLast();
//            非空的时候，如果信赖的比queue顶部的元素大的话，就移走这个
            }
            queue.addLast(right);
//            如果首部坐标小于left，那么就删除这个
            int left = right-k+1;//此时这个left实际也就是依次递增的
            if (queue.peekFirst()<left){
                queue.removeFirst();
            }
            if (left>=0) {
                ans[left] = nums[queue.peekFirst()];
//                这个first对应就是前k个区间内的大的数值了
            }
        }
    }
}
```

### 天气：

```
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]
```

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        // 单调栈，遍历递增循序（再强调一下是指从栈头到栈底的顺序），
        // 因为只有递增的时候，栈里要加入一个元素i的时候，
        // 才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        deque.push(0);//就是在队列的左边，头部，加入了初始的0
        for (int i = 1; i < temperatures.length; i++) {
            while (!deque.isEmpty() && temperatures[i]>temperatures[deque.peek()]){
                ans[deque.peek()] = i - deque.peek(); // 最右边的
                deque.pop();
            }
            deque.push(i);
        }
        return ans;
    }
}
```



![739.每日温度6](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303231393132343730303536372e6a7067.jpeg)



### [剑指 Offer II 039. 直方图最大矩形面积](https://leetcode.cn/problems/0ynMMM/)

给定非负整数数组 `heights` ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 `1` 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```



```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] temp = new int[heights.length+2];//存储单调栈
        System.arraycopy(heights,0,temp,1,heights.length);
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        int area = 0;
        for(int i= 0;i<temp.length;i++){
            while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
                //如果当前位置的高度比stack的小，那么就会漏水
                int h = temp[stack.pop()];
                // 比如： 2 1 
                // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
                // 所以stack里面一直有元素
                area = Math.max(area,h*(i-stack.peek()-1));
                // 当stack为 1 5 6 时
                // 2 小于 6 ，所以area更新为 6
                // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
            }
            stack.push(i);
        }
        return area;
    }
}
```



### [剑指 Offer II 040. 矩阵中最大的矩形](https://leetcode.cn/problems/PLYXKQ/)

难度困难76收藏分享切换为英文接收动态反馈

给定一个由 `0` 和 `1` 组成的矩阵 `matrix` ，找出只包含 `1` 的最大矩形，并返回其面积。

**注意：**此题 `matrix` 输入格式为一维 `01` 字符串数组。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
输入：matrix = ["10100","10111","11111","10010"]
输出：6
解释：最大矩形如上图所示。
```



看下边的橙色的部分，这完全就是上一道题呀！

![image.png](https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png)

算法有了，就是求出每一层的 heights[] 然后传给上一题的函数就可以了。



```java
class Solution {
    public int maximalRectangle(String[] matrix) {
        if(matrix.length==0) return 0;
        int n = matrix[0].length();
        int[] heights = new int[n];
        int maxArea = 0;
        for(int i = 0;i<matrix.length;i++){
            for(int j = 0;j<n;j++){
                if(matrix[i].charAt(j) == '1'){
                    heights[j] +=1;
                }else{
                    heights[j] = 0;
                }
            }
            maxArea = Math.max(maxArea,largestRectangleArea(heights));
        }
        return maxArea;
    }

    public int largestRectangleArea(int[] heights) {
    int[] temp = new int[heights.length+2];//存储单调栈
    System.arraycopy(heights,0,temp,1,heights.length);
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    int area = 0;
    for(int i= 0;i<temp.length;i++){
        while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
            //如果当前位置的高度比stack的小，那么就会漏水
            int h = temp[stack.pop()];
            // 比如： 2 1 
            // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
            // 所以stack里面一直有元素
            area = Math.max(area,h*(i-stack.peek()-1));
            // 当stack为 1 5 6 时
            // 2 小于 6 ，所以area更新为 6
            // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
        }
        stack.push(i);
    }
    return area;
    }
}
```



## 优先级队列

### PriorityQueue的作用

PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。

在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。

Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。

Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。

Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。

由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。

这里牵涉到了大小关系，**元素大小的评判可以通过元素本身的自然顺序（\*natural ordering\*），也可以通过构造时传入的比较器**（*Comparator*，或者元素自身实现 Comparable 接口）来决定。

在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。



### [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/)



设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。

请实现 `KthLargest` 类：

- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

示例：

```sh
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```



其实就是优先级队列，做一个小丁队

```java
class KthLargest {
    PriorityQueue<Integer> queue;
    int k;
    public KthLargest(int k, int[] nums) {
        queue = new PriorityQueue<>();
        // 默认是从小到达的顺序，小顶堆
        for(int num: nums){
            queue.add(num);
        }
        this.k = k;
    }
    
    public int add(int val) {
        queue.offer(val);
        while(queue.size()>k){
            queue.poll();
        }
        return queue.peek();
    }
}
```



### [剑指 Offer II 060. 出现频率最高的 k 个数字](https://leetcode.cn/problems/g5c51o/)

> 关键： 优先级存储了频率和数字，直接定一个PriorityQueue<int[ ] > 
>
> 



给定一个整数数组 `nums` 和一个整数 `k` ，请返回其中出现频率前 `k` 高的元素。可以按 **任意顺序** 返回答案。



**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        PriorityQueue<int[]> queue= new PriorityQueue<>(new Comparator<>(){
            public int compare(int[] a,int[] b){
                return a[1]-b[1];
            }
        });
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            // 遍历每一个map的元素
            int num = entry.getKey(), count = entry.getValue();
            
            if(queue.size()==k){
                if(queue.peek()[1]<count){
                    queue.poll();
                    queue.offer(new int[]{num,count});
                }
            }else{
                queue.offer(new int[]{num,count});
            }
            /*也可以全部都加进去，之后再判断队列大小，大了的部分就poll出去。
            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                Integer num = entry.getKey();
                Integer value = entry.getValue();
                queue.offer(new int[]{num,value});
            }
            while (queue.size()>k){
                queue.poll();
            }
            */
            
        }
        int[] res = new int[k];
        for(int i = 0;i<k;i++){
            res[i] = queue.poll()[0];
        }
        return res;
    }
}
```



### [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)



给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。

 

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->nums1[a[0]] + nums2[a[1]] - nums1[b[0]] - nums2[b[1]]);
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]));
        for(int i = 0;i<Math.min(k,nums1.length);i++){
            heap.offer(new int[]{i,0});
            //nums1的索引都放到heap里面，
            
        }
        List<List<Integer>> ans = new ArrayList<>();
        // 最多弹出 k 次
        while(k-- >0 && !heap.isEmpty()){
            //其实就是吧heap整理一下
            //卧槽，就是说弹出k次heap堆的堆顶，肯定就是最小值
            int[] pos = heap.poll();
            ans.add(Arrays.asList(nums1[pos[0]],nums2[pos[1]]));
            // 将 index2 加 1 之后继续入队
            if(++pos[1]<nums2.length){
                heap.offer(pos);
            }
        }
        return ans;
    }
}
```



## TreeSet

 Java中 TreeMap和TreeSet算是java集合类里面比较有难度的数据结构。和普通的HashMap不一样，普通的HashMap元素存取的时间复杂度一般是O(1)的范围，而TreeMap内部对元素的操作复杂度为O(logn)。

虽然在元素的存取方面TreeMap并不占优，但是它内部的元素都是排序的，当需要查找某些元素以及顺序输出元素的时候它能够带来比较理想的结果。可以说，**TreeMap是一个内部元素排序版的HashMap。**同样，TreeSet是一个封装了一个HashSet的成员变量来实现的，底层运用了红黑树的数据结构。

### TreeSet Vs. HashSet

TreeSet和HashSet都实现了Set接口。然而，它们之间存在着一些区别。

- 与HashSet不同，TreeSet中的元素是以某种顺序存储的。这是因为TreeSet还实现了SortedSet接口。
- TreeSet提供了一些易于导航的方法。 例如first()，last()，headSet()，tailSet()等。这是因为TreeSet还实现了NavigableSet接口。
- 对于添加、删除、包含和大小等基本操作，HashSet比TreeSet更快。



### 使用

为了创建树集，我们必须首先导入java.util.TreeSet包。

导入包之后，下面是如何在Java中创建TreeSet。

```
TreeSet<Integer> numbers = new TreeSet<>();
```

在这里，我们创建了一个没有任何参数的TreeSet。在本示例中，TreeSet中的元素自然排序(升序)。

但是，我们可以使用Comparator接口自定义元素的排序。



### [剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/)

给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。

如果存在则返回 `true`，不存在返回 `false`。

 

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

```java
class Solution {

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        // 滑动窗口，窗口大小为k，窗口内两个数字的大小相差为t
        TreeSet<Long> set =  new TreeSet<>();
        for(int i = 0;i<nums.length;i++){
            Long item = nums[i]*1L;
            Long floor = set.floor(item);
            Long ceil = set.ceiling(item);
            // 比较ceil和floor一个是刚大于一点点item，一个是稍小一点点item的元素
            if(floor!=null && (item-floor<=t)) return true;
            if(ceil!=null && ceil-item<=t)  return true;
            set.add(item);
            //移除大于窗口的元素
            if(i>=k) set.remove(nums[i-k]*1L);
        }
        return false;
    }
}
```







### Method

### first()和last()方法

- first() - 返回集合的第一个元素
- last() - 返回集合的最后一个元素

例如，

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 first() 方法
        int first = numbers.first();
        System.out.println("第一个数字: " + first);

        // 使用 last() 方法
        int last = numbers.last();
        System.out.println("最后一个数字: " + last);
    }
}
```

**输出结果**

```
TreeSet: [2, 5, 6]
第一个数字: 2
最后一个数字: 6
```

### ceiling()，floor()，higher()和lower()方法

- **Higher(element)** - 返回大于指定元素(element)的最小元素。
- **lower(element)** - 返回小于指定元素(element)的最大元素。
- **ceiling(element)** - 返回大于指定元素(element)的那些元素中的最小元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。
- **floor(element)** - 返回小于指定元素(element)的元素中最大的元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(4);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 higher()
        System.out.println("使用 higher: " + numbers.higher(4));

        // 使用 lower()
        System.out.println("使用 lower: " + numbers.lower(4));

        // 使用 ceiling()
        System.out.println("使用 ceiling: " + numbers.ceiling(4));

        // 使用 floor()
        System.out.println("使用 floor: " + numbers.floor(3));

    }
}
```

**输出结果**

```
TreeSet: [2, 4, 5, 6]
使用 higher: 5
使用 lower: 2
使用 ceiling: 4
使用 floor: 2
```

> 当然作为基础的set也可以实现set的方法，执行集合的各种操作







> **TreeMap** 
>
> ```sh
> 输入:
> ["MyCalendar","book","book","book"]
> [[],[10,20],[15,25],[20,30]]
> 输出: [null,true,false,true]
> 解释: 
> MyCalendar myCalendar = new MyCalendar();
> MyCalendar.book(10, 20); // returns true 
> MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了
> MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 
> 
> ```
>
> 
>
> ```java
> 
> class MyCalendar {
>      TreeMap<Integer,Integer> map =null;
>     public MyCalendar() {
>         map =   new TreeMap<>();
>     }
>     
>     public boolean book(int start, int end) {
>         // 查找刚刚好大于等于start时间的条目；
>         Map.Entry<Integer,Integer> event = map.ceilingEntry(start);
>         if(event!=null && event.getKey()<end){
>             // 如果刚大于start，但是开始的比要添加进去的end还要早，就错了
>             return false;
>         }
>         // 查找刚刚好小于等于start时间的条目；
>         event = map.floorEntry(start);
>         // 结束的时间不能比要插入的开始的晚，
>         if(event!=null && event.getValue()>start){
>             return false;
>         }
>         map.put(start,end);
>         return true;
> 
>     }
> }
> 
> /**
>  * Your MyCalendar object will be instantiated and called as such:
>  * MyCalendar obj = new MyCalendar();
>  * boolean param_1 = obj.book(start,end);
>  */
> ```
>
> 

# 算法模板

## 排序算法

### 选择排序

```java
import java.util.Arrays;
public class Solution {
// 选择排序：每一轮选择最小元素交换到未排定部分的开头

public int[] sortArray(int[] nums) {
    int len = nums.length;
    // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子
    for (int i = 0; i < len - 1; i++) {
        // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        swap(nums, i, minIndex);
    }
    return nums;
}

private void swap(int[] nums, int index1, int index2) {
    int temp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = temp;
	}	

public static void main(String[] args) {
    int[] nums = {5, 2, 3, 1};
    Solution solution = new Solution();
    int[] res = solution.sortArray(nums);
    System.out.println(Arrays.toString(res));
	}
}
```
### 快速排序



```java
class Solution {
    public String minNumber(int[] nums) {
        //参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值
        String[] strs = new String[nums.length];
        for(int i =0;i<nums.length;i++){
            strs[i]=String.valueOf(nums[i]);
        }
      	quickSort(strs,0,strs.length-1);
     	 StringBuilder res = new StringBuilder();
      	for(String s:strs){
        	res.append(s);
      	}
      	return res.toString();
    }
    void quickSort(String[] strs,int left,int right){
        if(left>=right) {
            return;
        }
        int pivotIndex =partition(strs,left,right);
        quickSort(strs,left,pivotIndex-1);
        quickSort(strs,pivotIndex+1,right);
    }
    private int partition(String[] strs,int left,int right) {
        String pivot=strs[left];
        //j是pivot第一个区间最后一个元素所在的位置
        int j=left;
        for(int i=left+1;i<=right;i++) {
            if((strs[i]+pivot).compareTo((pivot+strs[i]))<0) {
                j++;
                swap(strs,i,j);
            }
            
        }
        swap(strs,left,j);
        //此时j处于第一个区间的最后一个位置，实际上就是需要的切分元素现在所在的位置了
        return j;
    }
    private void swap(String[] nums,int i,int j) {
        String temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

}
```

### 插入排序

由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。

```java
public class Solution {

    // 插入排序：稳定排序，在接近有序的情况下，表现优异

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            // 先暂存这个元素，然后之前元素逐个后移，留出空位
            int temp = nums[i];
            int j = i;
            // 注意边界 j > 0
            while (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}


```

### 堆排序

堆就是完全二叉树

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图

![img](https://raw.githubusercontent.com/52chen/imagebed2023/main/picgo/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

堆排序的基本思想是：将**待排序序列构造成一个大顶堆**heapify，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```java
import java.util.Arrays;
public class HeapSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i=arr.length/2-1;i>=0;i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j>0;j--){
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr,0,j);//重新对堆进行调整
        }

    }
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i
        for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```



```java
class Solution {
    public int[] sortArray(int[] nums) {
        //实战堆排序
        for(int i = nums.length/2-1;i>=0;i--){
            heapify(nums,i,nums.length);
        }
        for(int i = nums.length-1;i>=1;i--){
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            heapify(nums,0,i);
        }
        return nums;
    }
    void heapify(int[] nums,int i,int length){
        int maxindex = i;
        int leftson = 2*i+1;
        int rightson = 2*i+2;
        if(leftson<length&&nums[leftson]>nums[maxindex]) maxindex =leftson;
        if(rightson<length&&nums[rightson]>nums[maxindex]) maxindex = rightson;//选这三者里面最大的作为naxIndex。
        if(maxindex!=i){
            // 如果发生了交换，那么
            int temp = nums[maxindex];
            nums[maxindex] =nums[i];
            nums[i] = temp;
            heapify(nums,maxindex,length);//交换了最大元素之后的位置继续进行堆排序
        }

    }
}
```

[LeetCode排序堆排序题解](https://leetcode.cn/submissions/detail/410212711/)

### 归并排序

[链表排序](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
//        归并排序
       if(head == null || head.next == null) return head;
       ListNode fast = head;
       ListNode slow = head;
       while (fast.next!=null && fast.next.next!=null) {
           fast = fast.next.next;
           slow = slow.next;
       }
        ListNode cnt = slow.next;//从中间切开
        slow.next = null;
        ListNode dummy = new ListNode();
        ListNode res = dummy;
        ListNode left = sortList(head);
        ListNode right = sortList(cnt);
        while (left!=null&&right!=null) {
            if(left.val<right.val) {
                res.next = left;
                left = left.next;
            }else {
                res.next = right;
                right=right.next;
            }
            res = res.next;
        }
        res.next = left!=null? left:right;
        return dummy.next;

    }

}
```



统计逆序对：

```java
class Solution {
    int[] nums,tmp;
    public int reversePairs(int[] nums) {
        //归并排序，计算逆序
        this.nums = nums;
        tmp = new int[nums.length];
        return merge(0,nums.length-1);
    }
    int merge(int left,int right){
        if(left>=right) return 0;
        int m = (left+right)/2;
        int res = merge(left,m)+merge(m+1,right);
        //上面是归并拆分
      
        //下面开始归并排序
        int i = left,j=m+1;
        for(int k =left;k<=right;k++){
            tmp[k] = nums[k];//拷贝一份
            //
        }
        for(int k = left;k<=right;k++){
            //左子区间的元素都遍历了，剩下只要把右子区间剩下的元素加入nums即可
            if(i==m+1)
                while(k<=right) nums[k++]=tmp[j++];
             //同上，此时右子区间的元素已经遍历完，只需要添加左子区间的元素到nums
            else if(j==right+1)
                while(k<=right) nums[k++]=tmp[i++];
            else if(tmp[i]<=tmp[j]){
                //往nums添加一个按从小到达排列的元素，不引入逆序对
                nums[k]=tmp[i++];
            }else {
                //对应 tmp[i] > tmp[j]
                res+=m-i+1;//也就是说，在合并左右子区间时，新引入了共m-i+1对 以tmp[j]为右元素的逆序对
                nums[k]=tmp[j++];
            } 
        }
        return res;
    }
}
```

### [280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)



给你一个的整数数组 `nums`, 将该数组重新排序后使 `nums[0] <= nums[1] >= nums[2] <= nums[3]...` 

输入数组总是有一个有效的答案。



**示例 1:**

```
输入：nums = [3,5,2,1,6,4]
输出：[3,5,1,6,2,4]
解释：[1,6,2,5,3,4]也是有效的答案
```

```java
class Solution {
    public void wiggleSort(int[] nums) {
        for (int i = 0; i < nums.length-1; i++) {
            if ((i%2==0)==(nums[i]>nums[i+1])){
                //当前位置为偶数的时候，应该递增，为奇数时为递减
                //nums[i]>nums[i+1]为递减的时候我们就交换一下
                int temp = nums[i];
                nums[i] = nums[i+1];
                nums[i+1] = temp;
            }
        }
    }
}
```

## 二分查找法 

**前提是数组为有序数组**，同时题目还强调**数组中无重复元素**

```java
class Solution {
    public int search(int[] nums,int target){
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;//左闭右闭
    }
}
```



```CPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        return right;
    }
};

```

## KMP

```CPP
void kmp(int* next, const string& s){
    next[0] = -1;
    int j = -1;
    for(int i = 1; i < s.size(); i++){
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

## 二叉树



### 序列化与反序列化二叉树：

```java
public String serialize(TreeNode root) {
        if (root==null) return "";
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
//            只要不是空的
            TreeNode polled = queue.poll();
            if (polled!=null){
                sb.append(""+polled.val);
                queue.offer(polled.left);
                queue.offer(polled.right);

            }else {
                sb.append("null");
            }
            sb.append(",");
        }
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data=="") return null;
        String substring = data.substring(1, data.length() - 1);
        String[] datalist = substring.split(",");
//        split之后就可以得到字符串列表了
        TreeNode root = new TreeNode(Integer.parseInt(datalist[0]));
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i =1;
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            if (!"null".equals(datalist[i])){
                poll.left =  new TreeNode(Integer.parseInt(datalist[i]));
                queue.offer(poll.left);
            }
            i++;
            if (!"null".equals(datalist[i])){
                poll.right =  new TreeNode(Integer.parseInt(datalist[i]));
                queue.offer(poll.right);
            }
            i++;
        }
        return root;

    }
```





##  

二叉树的定义：

```CPP
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 前序中序后序遍历

 中序遍历的时候 访问到的元素是从小到大顺序排列的



```java
中序遍历过程模板
public void inorder(TreeNode root){
        if (root == null) return ;    //终止条件
        inorder(root.left);           //访问左子树
        对当前节点进行一些操作          //访问根节点-----在遍历过程中希望实现的操作
        inorder(root.right);          //访问右子树
    }
```



#### 纠正二叉搜索树

输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。



```java
class Solution {
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);
    TreeNode err1 = null;
    TreeNode err2 = null;
    public void recoverTree(TreeNode root) {
        inorder(root);
        int tmp = err1.val;
        err1.val = err2.val;
        err2.val = tmp;
    }
    void inorder(TreeNode root) {
        if(root == null) return;
        inorder(root.left);
        if(pre.val>root.val&&err1==null) err1=pre;//！不相邻，前大后小，第一个错误就要取大的
        if(pre.val>root.val&&err1!=null) err2=root;//哦哦哦哦哦！不相邻，前大后小，第二个错误就要取小的
        pre = root;
        inorder(root.right);

    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //非递归方式实现中序遍历
        List<Integer> res = new LinkedList();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root!=null||!stack.isEmpty()) {
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
    
}
```





### 深度优先遍历（递归） 

前序遍历（中左右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```
中序遍历（左中右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```
后序遍历（左右中）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

### 深度优先遍历（迭代法）

相关题解：[0094.二叉树的中序遍历](https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.二叉树的中序遍历.md)

前序遍历（中左右）
```CPP
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}

```

中序遍历（左中右）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result; // 存放中序遍历的元素
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); 
            if (node->right) st.push(node->right);  // 右
            st.push(node);                          // 中
            st.push(NULL); 
            if (node->left) st.push(node->left);    // 左
        } else {
            st.pop(); 
            node = st.top(); 
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

后序遍历（左右中）
```CPP
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```




#### [剑指 Offer II 049. 从根节点到叶节点的路径数字之和](https://leetcode.cn/problems/3Etpl5/)

难度中等49

给定一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }
    int dfs(TreeNode root,int preSum){
        if(root == null) return 0;
        int sum = preSum*10+root.val;
        if(root.left==null && root.right == null){
            return sum;
        }
        return dfs(root.left,sum) + dfs(root.right,sum);
    }
}
```





### 广度优先遍历（队列）

相关题解：[0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)

```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}

```



可以直接解决如下题目：

* [0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)
* [0199.二叉树的右视图](https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.二叉树的右视图.md)
* [0637.二叉树的层平均值](https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.二叉树的层平均值.md) 
* [0104.二叉树的最大深度 （迭代法）](https://programmercarl.com/0104.二叉树的最大深度.html)

* [0111.二叉树的最小深度（迭代法）](https://programmercarl.com/0111.二叉树的最小深度.html)
* [0222.完全二叉树的节点个数（迭代法）](https://programmercarl.com/0222.完全二叉树的节点个数.html)



### [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode.cn/problems/hPov7L/)-层序遍历



给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。



**示例1：**

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 
```



```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
        List<Integer> ans = new LinkedList<Integer>();
        if(root == null) return ans;
        stack.push(root);
        
        while(!stack.isEmpty()){
            int size = stack.size();
            int tempMax =Integer.MIN_VALUE;
            for(int i = 0;i<size;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
                tempMax = Math.max(tempMax,poped.val);
            }
            ans.add(tempMax);
        }
        return ans;

    }
}
```





### [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode.cn/problems/LwUNpT/)-层序遍历

难度中等40

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈

写出来了

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
       int ans = 0;
        if(root == null) return ans;
        stack.push(root);
        
        while(!stack.isEmpty()){
            int size = stack.size();
            int tempMax =Integer.MIN_VALUE;
            ans = stack.peek().val;
            for(int i = 0;i<size;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
                tempMax = Math.max(tempMax,poped.val);
            }
            
        }
        return ans;
    }
}
```



### [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode.cn/problems/WNC0Lk/)

难度中等43

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```



哈哈哈哈哈哈哈，层序遍历，每一层最右边的就是需要的右侧的试图

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
        List<Integer> ans = new LinkedList<Integer>();
        if(root == null) return ans;
        stack.push(root);
        while(!stack.isEmpty()){
            int size = stack.size();
            
            for(int i = 0;i<size-1;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
            }
            TreeNode poped = stack.pop();
            ans.add(poped.val);
            if(poped.left!=null) stack.addLast(poped.left);
            if(poped.right!=null) stack.addLast(poped.right);
        }
        return ans;
    }
}

```



### 二叉树深度

```CPP
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

### 二叉树节点数量

```CPP
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```



### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。

实现 `CBTInserter` 类:

- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)` 向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；
- `CBTInserter.get_root()` 将返回树的头节点。

 



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg)

```java
class CBTInserter {
    List<TreeNode> list = new ArrayList<>();
    int idx = 0;
    public CBTInserter(TreeNode root) {
        list.add(root);
        int cur =0;
        //这里就是把传进来的二叉树进行序列化
        while(cur<list.size()) {
            // 如果当前的长度比较长的话
            TreeNode node = list.get(cur);
            if(node.left!=null) list.add(node.left);
            if(node.right!=null) list.add(node.right);
            cur++;
        }
    }
    
    public int insert(int val) {
        TreeNode node = new TreeNode(val);
        while(list.get(idx).left!=null && list.get(idx).right!=null)
            idx++;
        TreeNode father = list.get(idx);//找到了左边或者右边的子节点有位置的地方
        if(father.left==null) father.left = node;
        else if(father.right == null) father.right =node;
        list.add(node);
        return father.val;
    }
    
    public TreeNode get_root() {
        return list.get(0);
    }
}
```



### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root==null) return true;
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        if (leftNode!=null){
            while (leftNode.right!=null){
                leftNode = leftNode.right;//左边子树的最大值
            }
            if (leftNode.val>=root.val) return false;
        }
        if (rightNode!=null){
            while (rightNode.left!=null){
                rightNode = rightNode.left;//右边子树的最小值
            }
            if (rightNode.val<=root.val) return false;
        }
        return isValidBST(root.left) && isValidBST(root.right);
    }
    //只要根节点大于左子树的最大值，小于右子树的最小值即可。

}
```





## 回溯算法 

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。







```CPP
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```



### [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> res= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTrace(n,k,1);//递归函数返回值为void，一般直接就在参数里面修改
        return res;
    }
    void backTrace(int n,int k, int s){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        /*
        已经选择的元素个数：path.size();
        还需要的元素个数为: k - path.size();
        在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
        */
        //可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠s
        for(int i =s;i<=n-(k-path.size())+1;i++ ){
            path.add(i);
            backTrace(n,k,i+1);
            path.removeLast();
        }
    }
}
```

> 如果 `n = 7, k = 4`，**从 5 开始搜索就已经没有意义了**，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。
>
> 因此在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
>
> ```java
>         for (int i = begin; i <= n-(k-path.size())+1; i++) {
> 
> ```
>
> 

![77.组合1](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67.png)

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)



给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```



```JAVA
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    HashMap<Integer,String> map = new HashMap<>(){
        {
            put(2,"abc");
            put(3,"def");
            put(4,"ghi");
            put(5,"jkl");
            put(6,"mno");
            put(7,"pqrs");
            put(8,"tuv");
            put(9,"wxyz");
        }
    };
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits.length()==0) return ans;
        back(digits,0,0);
        //回溯算法，就是遍历
        return ans;
    }
    void back(String digits,int idx,int charIdx){
        if (idx==digits.length()){
            ans.add(sb.toString());
            return;
        }
        //遍历数字，
        char c = digits.charAt(idx);
        String s = map.get(c - '0');
        for (int j = 0; j < s.length(); j++) {
            //单个字符的长度
            sb.append(s.charAt(j));
            back(digits,idx+1,j);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```





### [剑指 Offer II 084. 含有重复元素集合的全排列 ](https://leetcode.cn/problems/7p8L0Z/)

给定一个可包含重复数字的整数集合 `nums` ，**按任意顺序** 返回它所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);//排列一下
        used = new boolean[nums.length];
        back(nums);
        return ans;
    }
    void back(int[] nums){
        if (path.size() == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        int last = -11;
        for (int i = 0; i < nums.length; i++) {
            if ((used[i] || i>0 && nums[i]==nums[i-1] && used[i-1]))
                continue;//去掉重
            // i>0 && nums[i]==nums[i-1] && used[i-1] 这里应该是说如果当前元素和上一个相同，有可能是可以继续使用的
//            判断为不能使用的话，得加一个判断，判断之前的元素也是用过的，那就可以了
            path.add(nums[i]);
            used[i]= true;
            back(nums);
            used[i]= false;
            path.remove(path.size()-1);
        }
    }
}
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)



**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        //startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。
        //本题我们还需要一个变量pointNum，记录添加逗点的数量。
        if (s.length()>12) return ans;
        backTrace(s,0,0);
        return ans;
    }
    void backTrace(String s, int begin,int pointNumber) {
        if (pointNumber==3){
            //此时已经到达了最后一个阶段，判断begin到最后的一段是否合法，不合法就不添加
            if (isValid(s,begin,s.length()-1))
                ans.add(s);
            return;
        }
        for (int i = begin; i < s.length(); i++) {
            if (isValid(s,begin,i)){
                s=s.substring(0, i + 1) + "." + s.substring(i + 1);
                //插入一个。
                pointNumber++;
                backTrace(s,i+2,pointNumber);
                pointNumber--;
                s=s.substring(0, i + 1) + s.substring(i + 2);
            }else {
                continue;
            }
        }
    }
    boolean isValid(String s,int begin,int end) {
        if (begin>end) return false;
        if (s.charAt(begin)=='0'&&begin!=end){
            return false;
            //0开头的数字不合法，此时begin和end不相等的
        }
        int num =0;

        for (int i = begin; i <= end; i++) {
            if (s.charAt(i)>'9'||s.charAt(i)<'0')
                return false;
            num = num *10 + (s.charAt(i)-'0');
            if (num>255)
                return false;
        }
        return true;
    }
}
```



### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)



给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

```java
class Solution {
    HashMap<Long,Integer> map = new HashMap<>();
    public int pathSum(TreeNode root, int targetSum) {
//        回溯算法
        map.put(0L,1);//存储前缀和为0的次数为1；
        return recursion(root,targetSum,0L);
    }
    int recursion(TreeNode root,int targetSum,Long currSum) {
        if (root==null) return 0;
        int res = 0;
        currSum+=root.val;
        // 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径
        res+=map.getOrDefault(currSum-targetSum,0);
        // 更新路径上当前节点前缀和的个数
        map.put(currSum,map.getOrDefault(currSum,0)+1);
        res+=recursion(root.left,targetSum,currSum);
        res+=recursion(root.right,targetSum,currSum);
        map.put(currSum,map.getOrDefault(currSum,0)-1);
        return res;
    }

}
```



### [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)



给定一个字符串 `s` ，请将 `s` 分割成一些子串，使每个子串都是 **回文串** ，返回 s 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 

**示例 1：**

```
输入：s = "google"
输出：[["g","o","o","g","l","e"],["g","oo","g","l","e"],["goog","l","e"]]
```



```java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();
    private String s;
    public String[][] partition(String s) {
        this.s = s;
        back(0);
        String[][] res = new String[ans.size()][];
        for (int i = 0; i < ans.size(); i++) {
            String[] temp = new String[ans.get(i).size()];
            for (int j = 0; j < ans.get(i).size(); j++) {
                temp[j] = ans.get(i).get(j);
            }
            res[i] = temp;//这里的temp每一个都是不同的。
        }
        return res;
    }
    void back(int idx){
        if (idx == s.length()){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            if (isPali(idx,i)) {
                path.add(s.substring(idx,i+1));
                back(i+1);
                path.remove(path.size()-1);
            }
        }
    }
    boolean isPali(int left,int right){
        while (left < right)
            if (s.charAt(left++) != s.charAt(right--))
                return false;
        return true;
    }
}
```

## 动态规划



### [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true
```



```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s3.length()!=(s1.length()+s2.length())) return false;
        int m = s1.length();
        int n = s2.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                int k = i+j-1;
                if (i>0){
                    //向前推进dp数组，新的dp等于原来的是不是true，然后当前的字符是不是相等的
                    dp[i][j] = dp[i-1][j] &&(s1.charAt(i-1)==s3.charAt(k));
                }
                if (j>0){
                    dp[i][j] = dp[i][j] ||(dp[i][j-1]&&s2.charAt(j-1)==s3.charAt(k));
                }
            }
        }
        return dp[m][n];
        //dp[i][j] 表示的是当前是否是s3的i+j的正确的表达式
        //if(s3.chatAt(i+j)==s1.char或者s2.char -》dp[i][j] = dp[i-1][j]

    }
}
```



### II 019回文字符 



给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。



**示例 1:**

```
输入: s = "aba"
输出: true
```

**示例 2:**

```
输入: s = "abca"
输出: true
解释: 可以删除 "c" 字符 或者 "b" 字符
```

```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }
        }
        return true;
    }
    private boolean validSub(String s,int le,int ri){
        while (le<ri){
            if (s.charAt(le)!=s.charAt(ri)) return false;
            le++;
            ri--;
        }
        return true;
    }
}
```



### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给定一个字符串 `s` ，请计算这个字符串中有多少个回文子字符串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。



**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```



**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成



注意：本题与主站 647 题相同：https://leetcode-cn.com/problems/palindromic-substrings/



```java
class Solution {
    public int countSubstrings(String s) {
        //动态规划，dp[i][j]表示i到j是否是回文串
        int length = s.length();
        boolean[][] dp = new boolean[length][length];
        int count = 0;
        for (int i = 0; i < length; i++) {
            dp[i][i] = true;
            count++;
        }
        /*
        * 当下标 i 和 j 相同时：区间只有一个字母，是回文子串。
        * 当下标 i 和 j 相差为 1 时：区间有两个字母，且这两个字母相同，是回文子串。
        * 当下标 i 和 j 相差大于 1 时：此时有 s[i] == s[j] ，
        要看区间 [i, j] 是不是回文子串，就得看中间夹着的区间 [i + 1, j - 1]
        是不是回文子串，即当 dp[i + 1][j - 1] = true 时，
        区间 [i, j] 是回文子串，否则就不是回文子串。
         */
        for (int i = length-1; i >= 0; i--) {
            for (int j = i+1; j < length; j++) {
                char ci = s.charAt(i);
                char cj = s.charAt(j);
                if (j-1>=i+1){
                    //中间的区间
                    dp[i][j] = (ci==cj) && dp[i+1][j-1];
                }else {
                    dp[i][j] = (ci==cj);//只有一个元素的时候
                }
                if (dp[i][j]) count++;
                //如果上述判断完了之后是true，那么就计数+1；
            }
        }
        return count;
    }
}
```



### [剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/)

如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列 `arr` ，找到 `arr` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

*（回想一下，子序列是从原序列 `arr` 中派生出来的，它从 `arr` 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， `[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的一个子序列）*



```java
class Solution {
    public int lenLongestFibSubseq(int[] arr) {
        //每个斐波那契数列都可以由其最后两位数字精准定位
        int n = arr.length;
        int[][] dp = new int[n][n];
        // dp[2][3]表示数列[1,2,3]、dp[3][5]表示数列[1,2,3,5]、
        // dp[5][8]表示数列[1,2,3,5,8]
        //每个dp元素的值，代表它所定位的数列的长度，
        // 例如上面的 dp[2][3]=3 , dp[3][5]=4 , dp[5][8]=5；
        int max = 0;
        for (int i = 2; i < n; i++) {
            int j = 0, k = i-1;
            //j k 为双指针，
            while (j<k){
                if (arr[j] + arr[k] == arr[i]){
                    //找到
                    if (dp[j][k] == 0){//如果j和k，j之前的长度为0，
                        dp[k][i] = 3;//至少有三个元素了，k和i有3的长度
                        //两个前置元素j、k之前并没有形成斐波那契子数列（即dp[j][k]==0），
                        // 那就将当前位置存储的斐波那契数列长度dp[k][i]修改为3
                    }else {
                        //如果前置元素j、k之前作为某个斐波那契数列的最后两位元素存在
                        // （即dp[j][k]==n，n>=3）
                        dp[k][i] = Math.max(dp[j][k]+1,dp[k][i]);
                        //将当前位置存储的斐波那契数列长度dp[k][i]修改为 n+1 ，
                    }
                    max = Math.max(max,dp[k][i]);
                    j++;k--;
                }else if (arr[j] + arr[k] < arr[i]){
                    j++;
                }else
                    k--;
            }
        }
        return max;

    }
}
```



### [剑指 Offer II 092. 翻转字符](https://leetcode.cn/problems/cyJERH/)



如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是 **单调递增** 的。

我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 s，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。

返回使 s **单调递增** 的最小翻转次数。

 

**示例 1：**

```
输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.
```

```java
class Solution {
    public int minFlipsMonoIncr(String s) {
        if(s.length() < 2){
            return 0;
        } // 前一位反转成0的最小值和前一位反转成1的最小值
         int [][] dp = new int[s.length()][2];
        if (s.charAt(0)=='1'){
            dp[0][0] = 1;
            dp[0][1] = 0;
        }else {
            dp[0][0] = 0;
            dp[0][1] = 1;
        }
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i)=='1'){
                dp[i][0] = dp[i-1][0]+1;//前一个是0的时候，就得多翻一个
                dp[i][1] = Math.min(dp[i-1][0],dp[i-1][1]);
            }else {
                //当前位置为0 的时候。如果前一个为0，那么就不需要变，
//                前一个为1，需要加一
                dp[i][0] = dp[i-1][0];
                dp[i][1] = Math.min(dp[i-1][1],dp[i-1][0])+1;
            }
        }
        return Math.min(dp[s.length()-1][0],dp[s.length()-1][1]);
    }
}
```



### [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2：**

```
输入：s = "aa", p = "*"
输出：true
解释：'*' 可以匹配任意字符串。
```



```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        s = " "+s;//char数组就是从1开始的了
        p = " "+p;
        char[] chars = s.toCharArray();
        char[] charp = p.toCharArray();
        //动态规划，dp(i,j)就是1到i的字符和p的1到j的字符是否匹配
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0]=true;
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (charp[j]=='*'){
                    //如果p的此处为*，那么
                    dp[i][j] = dp[i][j-1] || (i-1>=0 && dp[i-1][j]);
                    //此时dp[i][j] 可以是由 dp[i][j-1]匹配传递来 或者(i-1>=0 && dp[i-1][j]);
                    
                }else {
                    dp[i][j] = i-1>=0 
                        && dp[i-1][j-1] && (chars[i]==charp[j] 
                                            || charp[j]=='?');
                // ? 匹配的条件是前面的字符匹配，s 中的第 i 个字符可以是任意字符。
                //   匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。
                }
            }
        }
        return dp[m][n];
    }
}
```



### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)



给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```



```java
class Solution {
    public int minDistance(String word1, String word2) {
        //Dynamic Plan
        //二维数组，dp[i][j] 表示前i个word1转化成前j个word2的最少的操作数
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i <= n; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <=m ; i++) {
            for (int j = 1; j <= n; j++) {
                //开始比较了
                if (word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else {
                    //如果是删除i的话：dp[i][j] = dp[i-1][j]+1；
                    //如果是增加的话：dp[i][j] = dp[i][j-1]+1；
                    //如果是替换那就是dp[i][j] = dp[i-1][j-1]+1;
                    dp[i][j] = Math.min( dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
                }
            }
        }
        return dp[m][n];
    }
}
```



## 背包算法



![416.分割等和子集1](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/20210117171307407-20230310132423205.png)

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```CPP
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**完全背包的模版**：



```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```



### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 

问装满背包所有物品的最小个数：dp[j] =  min(dp[j - coins[i]] + 1, dp[j]); 

### 遍历顺序

### 01背包

二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

一维dp数组01背包**只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历**。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

举例：

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if (sum%2==1) return false;
        int target = sum/2;
        //动态规划 1/背包问题，能不能找到target大小的元素
        // dp[i] = dp[i-nums[j]]
        boolean[] dp = new boolean[target + 1];
        //先遍历物品，再遍历背包，
        dp[0] = true;
        for (int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = dp[j]||dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}
}
```



#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```



1. 确定dp数组以及下标的含义

**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。

可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。

相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”

2. 确定递推公式

01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

本题则是：**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。

大家可以再去看 dp[j]的含义。

最后dp[target]里是容量为target的背包所能背的最大重量。

那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。

那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。



```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        //粉碎石头，其实就是看两个能不能各分一半
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int target = sum/2; // if achieved target，then result is zero;
        //dp表示装满容量为i的背包所能装的最大的价值也就是重量；
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-2*dp[target];//taget容量的背包最多能装下的
        //一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
        //那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。
    }
}
```

> 本题其实和**[416. 分割等和子集]**几乎是一样的，只是最后对dp[target]的处理方式不同。
>
> **<u>*[416. 分割等和子集]*</u>**相当于是求背包是否正好装满，而本题是求背包最多能装多少。



### 完全背包

纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是**纯完全背包**的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。也就是不同的排序都算做新的方法就是求排列数

相关题目如下：

#### [剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/)



给定一个由 **不同** 正整数组成的数组 `nums` ，和一个目标整数 `target` 。请从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```sh
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合
```

dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。 

其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。 

如果数组[0] ，target = 0，那么 bagSize =  (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。 

所以本题我们应该初始化 dp[0] 为 1。

可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。 

其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。 

dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。



```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
//        背包问题，背包总的只能装target大小的东西
//        顺序可以作为不同的组合dp[j] +=dp[j-nums[i]];
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //完全背包（可以重复使用），求排列数（不同的排序都算方法）
        for (int i = 1; i <= target; i++) {
            // 先遍历背包，因为这个容器背包是1的时候，可以每一个nums都去遍历所以是组合
            // 如果先去遍历物品，也就是nums的时候，那不就是没有顺序l
            for (int j = 0; j < nums.length; j++) {
                if (nums[j]<=i){
                    dp[i] += dp[i-nums[j]];
                }
            }
        }
        return dp[target];

    }
}
```

#### [剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/)



给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //无线硬币就是完全背包，组合数首先遍历物品，再遍历背包
        int[] dp = new int[amount + 1];
       //完全背包（可以重复使用），求组合（不同的排序不算方法）
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if(dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
                }//最小的数
            }
        }
        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```



## 并查集 

```CPP
    int n = 1005; // 根据题意而定 
    int father[1005];

    // 并查集初始化
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
```

## 滑动窗口

在 Java 中，可以通过双指针的方式来实现滑动窗口算法，这里给出一个示例代码：

```java
public int slidingWindow(int[] nums, int target) {
    int left = 0, right = 0;
    int sum = 0, minLen = Integer.MAX_VALUE;

    while (right < nums.length) {
        sum += nums[right];

        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }

        right++;
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```



以上代码实现了一个求取数组中最短连续子数组长度的问题，其时间复杂度为 $O(n)$，其中 `left` 和 `right` 分别代表滑动窗口的左右指针，`sum` 为滑动窗口中元素之和，`minLen` 为最短连续子数组的长度。

在双指针算法中，常常需要使用嵌套循环，其中外层循环为右指针移动，内层循环为左指针移动，直到找到符合要求的结果。在内循环中，要注意移动左指针时的细节处理，此外还需要注意边界条件控制。



### 双指针



判断回文数

```java
boolean isPali(String s,int begin,int end) {
    for (int i = begin, j = end; i < j; i++, j--) {
        if (s.charAt(i)!=s.charAt(j))
            return false;
    }
    return true;
}
```



**判断回文串时，允许删除 1 个字符。**

给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。



**示例 1:**

```
输入: s = "aba"
输出: true
```



也就是说，在双指针相向遍历时，当

s[left]\\=s[right]

我们**有且仅有一次**跳过的机会：

- 可以跳过 left 指针指向的元素，继续 [left+1⟶,right⟵]；
- 也可以跳过 right 指针指向的元素，继续 [left⟶,right−1⟵]。

两种情况中，只要有一个判定被为回文串，那么 s 就是合法的回文串。



```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length()-1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }

        }
        return true;
    }
    boolean validSub(String s,int left,int right) {
        while (left<right){
            if (s.charAt(left)!=s.charAt(right))
                return false;
            left++;
            right--;
        }
        return true;
    }
}
```



### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

难度简单3158收藏分享切换为英文接收动态反馈

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。



```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //返回不重复的部分的长度，就是可以把重复的放在最后
        int slow = 0;//最后返回这个就可以了
        int fast = 1;
        while (fast<nums.length){
            //fast在前面标记为可以交换的元素
            if (nums[slow] == nums[fast])
                fast++;
            else {//找到不一样的之后再进行slow前进
                slow++;
                nums[slow]=nums[fast];
                fast++;
            }
        }
        return slow+1;
    }
}
```





### 统计连续子数组个数

给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。



**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**示例 2:**

```
输入: nums = [1,2,3], k = 0
输出: 0
```



**提示:**

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`



注意：本题与主站 713 题相同：https://leetcode-cn.com/problems/subarray-product-less-than-k/

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        //滑动窗口
        //使用一个变量 cur 记录当前窗口的乘积，使用两个变量 j 和 i 分别代表当前窗口的左右端点。
        int len = nums.length;
        int ans = 0;
        if (k<=1) return 0;
        for (int i = 0, j = 0, cur = 1; i < len; i++) {
            cur*=nums[i];
            // 当 cur>=k 时，我们考虑将左端点 j 右移，同时消除原来左端点元素 nums[j] 对 cur 的贡献，
            // 直到 cur>=k 不再满足，这样我们就可以得到每个右端点 nums[i] 的最远左端点 nums[j]
            while (cur>=k) cur/=nums[j++];
            ans+=i-j+1;
        }
        return ans;
        //请找出该数组内乘积小于 k 的连续的子数组的个数。
    }
}
```



### offer || 014 是否包含 `s1` 的某个变位词。

给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。



**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```



**提示：**

- `1 <= s1.length, s2.length <= 104`
- `s1` 和 `s2` 仅包含小写字母



注意：本题与主站 567 题相同： https://leetcode-cn.com/problems/permutation-in-string/



```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        int[] list1 = new int[26];
        int[] list2 = new int[26];
        if (l2<l1) return false;
        //// 同时填充两个字符表，其中alpha1填充完毕，alpha2只填充了前面一部分。
        for (int i = 0; i < l1; i++) {
            list1[s1.charAt(i)-'a']++;
            list2[s2.charAt(i)-'a']++;
        }
        if (Arrays.equals(list1,list2)) return true;
        for (int i = l1; i < l2; i++) {
            //窗口右边新来的加加
//            窗口左边要排除的渐渐
            list2[s2.charAt(i)-'a']++;
            list2[s2.charAt(i-l1)-'a']--;//注意这里，因为有i-li所以要额外写一个遍历
            // 判断当前状态下，s2窗口中的字符是否和s1的字符种类和数量都一致。
            // Arrays.equals() 是通过遍历判断的，自己些for也一样。
            if (Arrays.equals(list2,list1)) return true;
        }
        return false;
    }
}
```





### 滑动窗口统计变位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。



**示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (p.length()>s.length()) return ans;
        int[] listp = new int[26];
        int[] lists = new int[26];
        for (int i = 0; i < p.length(); i++) {
            listp[p.charAt(i)-'a']++;
            lists[s.charAt(i)-'a']++;
        }

        if (Arrays.equals(listp,lists)) ans.add(0);
        for (int i = p.length(); i < s.length(); i++) {
            lists[s.charAt(i)-'a']++;
            lists[s.charAt(i-p.length())-'a']--;
            if (Arrays.equals(listp,lists)) ans.add(i-p.length()+1);
        }
        return ans;
    }
}
```

## 前缀和算法



### 和大于等于target的连续子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int left = 0;
        int right = 1;
        int res = Integer.MAX_VALUE;
        while (right<=nums.length) {
            if (preSum[right]-preSum[left]>=target){
                res = Math.min(right-left,res);
                left++;
                right=left;
            }else
                right++;

        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= nums.length; i++) {
            // 前缀和数组下标 [0,i] 范围内找到满足「值小于等于 s−target」
            // 的最大下标，充当子数组左端点的前一个值。
            // 左边的范围小于等于，那么就是说preSum[i]-preSum[left]>=target
            int s = preSum[i],d = s-target;
            int left = 0, right = i;
            while (left<right){
                int mid = (left+right+1)>>1;
                if (preSum[mid]<=d) left=mid;//如果中间的前缀和小于需要的。
                else
                    right = mid -1;
            }
            if (preSum[right]<=d) res = Math.min(res,i-right);
        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



### offer010 和为k的子数组个数

给定一个整数数组和一个整数 `k` **，**请找到该数组中和为 `k` 的连续子数组的个数。



**示例 1：**

```
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
```

**示例 2：**

```
输入:nums = [1,2,3], k = 3
输出: 2
```



**提示:**

- `1 <= nums.length <= 2 * 104`



统计以每一个 *n**u**m**s*[*i*] 为结尾，和为 *k* 的子数组数量即是答案。

我们可以预处理前缀和数组 `sum`（前缀和数组下标默认从 1 开始），对于求解以某一个 *n**u**m**s*[*i*] 为结尾的，和为 *k* 的子数组数量，本质上是求解在 [0,*i*] 中，`sum` 数组中有多少个值为 *s**u**m*[*i*+1]−*k* 的数，这可以在遍历过程中使用「哈希表」进行同步记录。

```JAVA
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length, ans = 0;
        int[] pre = new int[n+1];
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + nums[i];
        }
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        for (int i = 1; i <= n; i++) {
            int tmp = pre[i], d = tmp-k;//求解在 [0,i] 中，
            // pre 数组中有多少个值为 pre[i+1]−k 的数，
            ans+=map.getOrDefault(d,0);//看看有无目标的值
            map.put(tmp,map.getOrDefault(tmp,0)+1);
        }
        return ans;
    }
}
```



### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int len = nums.length;
        int ans = 0;
        int[] pre = new int[len + 1];
        HashMap<Integer, Integer> map = new HashMap<>();
        //「某个前缀和出现的最小下标」
        map.put(0,0);
        for (int i = 0; i < len; i++) {
            pre[i+1] = pre[i]+(nums[i]==0?-1:1);
            //将 nums[i] 为 0 的值当做 −1 处理。
        }
        for (int i = 1; i <= len; i++) {
            int t = pre[i];
            if (map.containsKey(t))
                // get(t)的目的是，是前缀和，所以找到相同的t的时候，
                // 区间之间长度就是0了
                ans = Math.max(ans,i-map.get(t));
//            每遍历一个元素，就用「当前前缀和」去前面已经统计的前缀和
//            中找到一个使得两者之间区间为0的，并计算这个区间长度
            else
                map.put(t,i);
        }
        return ans;
    }
}
```



### 二位前缀和子数组



给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回左上角 `(row1, col1)` 、右下角 `(row2, col2)` 的子矩阵的元素总和。

<img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img" style="zoom:50%;" />



```java
class NumMatrix {
    int[][] matrix = null;
    int[][] sum = null;
    public NumMatrix(int[][] matrix) {
        this.matrix=matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        sum=new int[m +1][n +1];
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j < n; j++) {
                sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+matrix[i][j];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row1][col2+1]-sum[row2+1][col1]+sum[row1][col1];
    }
}
```



## 算数运算

### 进位与非进位

设两数字的二进制形式 ,观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。



![Picture1.png](assets\56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png)





```java
// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0 
//    1     1         0           1
// 
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
// 
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。

class Solution {
    public int add(int a, int b) {
        // a的二进制表示与b的二进制，
        // 每一位取异或运算，得到无进位和的结果，每一位取与运算，左移<<一位，得到进位，
        // 不用担心整数转二进制，因为他就是默认就是二进制存取的直接去&就可以了
        while(b!=0){
            int c = (a&b)<<1;//进位，左移一位
            a = a ^ b;//非进位和
            b=c;//当进位为0的时候就可以不需要进位，直接非进位和就可以了
        }
        return a;
    }
}
```

### 不用除法的除法：倍增求解

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。



```java
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        //返回完异常值
        //倍增法，每次减去一个2^x倍
        boolean sign = false;
        if((dividend>0&&divisor>0)||(dividend<0&&divisor<0))
            sign = true;//正数标记
        dividend = dividend > 0? -dividend:dividend;
        divisor = divisor > 0? -divisor:divisor;
        int ans = 0;
        //dividend / divisor
        while(dividend<=divisor){
            int tmp = divisor,count =1;
            //tmp + tmp >= dividend
            while(tmp>=dividend-tmp){
                tmp+=tmp;
                count+=count;
            }
            dividend = dividend - tmp;
            ans = ans+count;
        }
        return sign?ans:-ans;
    }
}


```



### 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数

```
如果我们是使用「朴素解法」求解的话，无论是从高位进行统计，还是从低位进行统计，最后一位扫描的都是边缘的数（如果是 1 就计数，不是 1 就不计数）。

从低位到高位，最后一步在扫描最高位之前，统计出 1 的个数应该等同于将 i 左移一位，并在最低位补 0，也就是等于 ans[i << 1]，这时候就要求我们在计算 i 的时候 i << 1 已经被算出来（从大到小遍历）
从高位到低位，最后一步在扫描最低位之前，统计出 1 的个数应该等同于将 i 右移一位，并在最高位补 0，也就是等于 ans[i >> 1]，这时候就要求我们在计算 i 的时候 i >> 1 已经被算出来（从小到大遍历）

```





```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for(int i=1;i<n+1;i++)
        //res[i] = 「i >> 1 所包含的 1 的个数」+「i 的最低位是否为 1」
            res[i] = res[i>>1] + (i&1);
        return res;
    }
}
```



### [剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,100]
输出：100
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

哈希表解法的空间复杂度是 *O*(*n*) 的，而题目的【进阶】部分提到应当使用常数空间来做。

其中一个比较容易想到的做法，是利用int类型固定为 32 位。

**使用一个长度为 32 的数组 cnt[] 记录下所有数值的每一位共出现了多少次 1，再对cnt[] 数组的每一位进行mod 3 操作，重新拼凑出只出现一次的数值。**

举个 🌰，考虑样例 `[1,1,1,3]`，1 和 3 对应的二进制表示分别是 `00..001` 和 `00..011`，存入 *c**n**t*[] 数组后得到 `[0,0,...,0,1,4]`。进行 *m**o**d* 3 操作后得到 `[0,0,...,0,1,1]`，再转为十进制数字即可得「只出现一次」的答案 3。

```java
class Solution {
    public int singleNumber(int[] nums) {
//        出现了三次，那么取模3，应该就是等于0；
        int[] cnt = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                if(((num>>i) & 1)==1){
                    cnt[i]++;
//                    如果当前元素右移i个单位是1的话，就在cnt加加
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i]%3==1)
//                mod 3 之后，其实也不会出现2，因为mod 3 就是去掉了重复3次的，
                ans+=(1<<i);
        }
        return ans;
    }
}
```





### [剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/)-位运算

给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。



**示例 1:**

```
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
```

根据题意进行模拟即可，利用每个 *w**or**d**s*[*i*] 只有小写字母，且只需要区分两字符是否有字母重复。

我们可以使用一个 `int` 来代指某个 *w**or**d*[*i*]：低 26 来代指字母 `a-z` 是否出现过。

然后对每个「字符对」所对应的两个 `int` 值执行 `&` 操作（若两字符无重复字符，则结果为 0），并得出最终答案。

位运算：比较两个字符串不相同

```java
class Solution {
    public int maxProduct(String[] words) {
//        位运算，进行&操作，如果两个字符有重复的字符马，那么就是1，无重复的就是0
        int length = words.length;
        int idx = 0;
        int[] masks = new int[length];
        for (String word : words) {
            int t = 0;
            for (int i = 0; i < word.length(); i++) {
                int u = word.charAt(i)-'a';
                t |= (1<<u);
            }
//            对每一个word进行或运算，计算1左移u位的，
//            则 abc 可以表示为 111 def 可以表示为 111000
            masks[idx++] = t;
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < i; j++) {
//         // 如果两个字符串不包含相同元素 那么与运算肯定为 0
                if ((masks[i]&masks[j])==0)
                    ans = Math.max(ans, words[i].length() * words[j].length());
            }
        }
        return ans;
    }
}
```



### [剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/)

难度中等61收藏分享切换为英文接收动态反馈

给定一个只包含整数的有序数组 `nums` ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

 

**示例 1:**

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0;
        
        int right = nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]==nums[mid^1]){
                left = mid+1;
                //如果mid是奇数，那么异或1的结果是mid-1；所以就相当于是比较mid和mid-1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；

                 //如果mid是偶数，那么异或1的结果是mid+1；所以就相当于是比较mid和mid+1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；
            }else right = mid;
        }
        return nums[left];
    }
}
```



### [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

 

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

 



```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        String res = "0";
        for (int i = num2.length()-1; i >=0 ; i--) {
            int carry = 0;//纪录进位
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < num2.length()-1-i; j++) {
                sb.append(0);//sb是逆序的，因此，假如说是第2个num2的数字，那就是sb代表的数字要进10。
            }
            int n2 = num2.charAt(i)-'0';
            //num2的第i位数字与num1想成
            for (int j = num1.length()-1; j >=0 || carry!=0; j--) {
                int n1 = j<0?0:num1.charAt(j)-'0';
                int product = (n1*n2+carry)%10;
                sb.append(product);
                carry = (n1*n2+carry)/10;
            }
            res = addStrings(res,sb.reverse().toString());
        }
        return res;
    }
    private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
    }
}
```





### 实现两个字符串相加



```java
private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
 }

```





### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

 

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```



```java
class Solution {
    public double myPow(double x, int n) {
        //快速幂，二进制
        //x^9 = (x^1) * (x^0*2) * (x^0*4) * (x^1*8)
        //就是9的二进制 1 0 0 1 然后乘以对应的2^(i-1)
        if (x == 0.0f) return 0.0d;
        long b = n;
        double res = 1.0;
        if (b < 0) {
            x = 1/x;
            b = -b;
        }
        //x^n = (x^2) ^ (n/2),将指数n除以二，如果是偶数则正常，如果是奇数，由于是向下取整，所以后面多乘以x
        while (b > 0) {
            if ((b&1) == 1) res *= x; //对b取余数，b%2 = b&1;
            //当 n 为奇数时，二分后会多出一项 x 。所以要多乘一次x
            x *= x;//x的平方
            b>>=1;
        }
        return res;
    }
}

```



### 66.加一



给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```



```java
class Solution {
    public int[] plusOne(int[] digits) {
        int len = digits.length;
        for (int i = len -1; i >= 0; i--) {
            digits[i]++;
            digits[i]%=10;
            if (digits[i]!=0)
                return digits;
        }
        digits = new int[len+1];
//        for (int digit : digits) {
//            System.out.println(digit);//其实此时所有位置都是零了
//        }
        digits[0] = 1;
        return digits;
    }
}
```
