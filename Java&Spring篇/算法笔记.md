# 一、数据结构模板

## 数组问题

### 41. 缺失的第一个正整数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。



**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```



```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        //最小的正整数，遍历
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            while (nums[i]>0 && nums[i]<=len && nums[i]!=nums[nums[i]-1]){
                //  1 2 3 0 4
                //  - - - ! -
                // 4应该在下标3的位置
                int j = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i]!=i+1){
                return i+1;//如果当前位置不存在对应的合理的值，就返回
            }
        }
        return len+1;
    }
}

```





## 链表问题



### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```



要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：

1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；

3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。

那么，什么数据结构同时符合上述条件呢？**哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。**所以结合一下，形成一种新的数据结构：`哈希链表 LinkedHashMap`。



```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer,Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)){
            return -1;
        }
        int val = cache.get(key);
        cache.remove(key);
        cache.put(key,val);//再次插入就实现了最新的使用的标记
        return cache.get(key);
    }
    
    public void put(int key, int value) {
        if(cache.containsKey(key)){
            cache.put(key,value);
            int val = cache.get(key);
            cache.remove(key);
            cache.put(key,val);//再次插入
            return;
        }
        if(cache.size()>=cap){
            //使用iterator()方法获取迭代器，可以遍历集合中的元素。next()方法用于返回下一个元素，即获取最早的键。
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        cache.put(key,value);
        return;
    }
}
```



### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```



```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return head;
        int n = 1;
        ListNode tail = head;
        while(tail.next!=null){
            tail = tail.next;
            n++;// length
        }
        k = k%n;//防止重复移动
        if(k<1) return head;
        ListNode fast = head;
        ListNode slow = head;
        while(k-->0){
            fast = fast.next;
        }
        
        while(fast.next!=null){
            fast= fast.next;
            slow = slow.next;
        }
        ListNode newHead = slow.next;
        slow.next = null;
        tail.next = head;
        return newHead;
    }
}
```







### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。

算法流程：

- 若头节点 head 为空节点，直接返回 null 。
- 初始化： 哈希表 dic ， 节点 cur 指向头节点。
- 复制链表：
  建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） 。
  cur 遍历至原链表下一节点。
- 构建新链表的引用指向：
  构建新节点的 next 和 random 引用指向。
  cur 遍历至原链表下一节点。
- 返回值： 新链表的头节点 dic[cur] 。



```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node cur = head;
        Map<Node,Node> map = new HashMap<>();
        while(cur!=null){
            //map storage the new Node
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        while(cur!=null){
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```





### [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1626420025-fZfzMX-image.png" alt="img" style="zoom:50%;" />

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```





```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
//        使用两个辅助栈
        ArrayDeque<Integer> stk1 = new ArrayDeque<>();
        ArrayDeque<Integer> stk2 = new ArrayDeque<>();
        while (l1!=null){
            stk1.push(l1.val);
            l1 = l1.next;
        }
        while (l2!=null){
            stk2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;//储存进位
        ListNode res = null;//储存结果
        while (!stk1.isEmpty()||!stk2.isEmpty()||carry!=0) {
            int digit1 = stk1.isEmpty()?0:stk1.pop();
            int digit2 = stk2.isEmpty()?0:stk2.pop();
            int sum = digit1+digit2+carry;
            carry = sum/10;
            sum = sum%10;
            ListNode tmp = new ListNode(sum);
            tmp.next = res;
            res = tmp;
        }
        return res;
    }
}
```



### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。



**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```



```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head==null||head.next ==null) return head;
        ListNode tail = head;
        for(int i = 0;i<k;i++){
            if(tail==null) return head;
            tail = tail.next;
        }
        ListNode newHead = reverse(head,tail);
        head.next = reverseKGroup(tail,k);
        return newHead;
    }
    private ListNode reverse(ListNode head,ListNode tail){
        ListNode prev = null;
        ListNode next = null;
        while(head!=tail){
            next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;//返回头部，就是反转的头部了
    }
}
```





### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

` L0 → L1 → … → Ln-1 → Ln `
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



**示例 1:**

![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        ////将主链表划分为 前一段子链表和后一段子链表，
        // 对于后一段子链表进行翻转，同时对于这两条链表进行重构;
        ArrayDeque<ListNode> deque = new ArrayDeque<ListNode>();
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        while (head!=null) {
            ListNode next = head.next;
            head.next = null;
            deque.add(head);
            head = next;
        }
        ListNode curr = dummy;
        while (!deque.isEmpty()) {
            ListNode start = deque.pollFirst();
            curr.next = start;
            //循环遍历deque双端，直至队列为空
            if (!deque.isEmpty()){
                ListNode last = deque.pollLast();
                start.next = last;//curr-》start-》last
                curr = last;//curr专程last
            }else {
                start.next = null;
            }
        }
        return;
    }
}
```



### 两个链表合并

```java
public ListNode mergeTwoLists(ListNode a, ListNode b) {
    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode(0);
    ListNode tail = head, la = a, lb = b;
    while (la != null && lb != null) {
        if (la.val < lb.val) {
            tail.next = la;
            la = la.next;
        } else {
            tail.next = lb;
            lb = lb.next;
        }
        tail = tail.next;
    }
    tail.next = (la != null ? la : lb);
    return head.next;
}

```

> 多个链表合并可以遍历，
>
> ```java
> public ListNode mergeKLists(ListNode[] lists) {
>     ListNode ans = null;
>     for (ListNode list : lists) {
>         ans = mergeTwoLists(ans,list);
>     }
>     return ans;
> }
> ```

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)



给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://raw.githubusercontent.com/52chen/imagebed2023/main/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`



```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1,head);
        ListNode prev = dummy;
        ListNode curr = head;

        //直接找到对应的位置，然后再切断再反转再接上
        for (int i = 1; i < left; i++) {
            prev = curr;
            curr = curr.next;
        }
        for (int i = 0; i < right - left; i++) {
            ListNode tmp = curr.next;
            curr.next = tmp.next;//curr指向tmp后面
            tmp.next = prev.next;//把tmp接龙，接到要逆向的prev的后面
            prev.next = tmp;//这三部=部分不能调换顺序，因为curr要用tmp
            //tmp要用prev，最后才可以切换prev的next
        }
        return dummy.next;
    }

}
```



## 栈的使用

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```



```java
class Solution {
    public int trap(int[] height) {
        int count = 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        //维持一个递减的栈，递增了显然就是有一个坑
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[stack.peek()]<height[i]){
                //出现递增的时候
                int popped = stack.pop();
                while (!stack.isEmpty() && height[popped]==height[stack.peek()])
                    stack.pop();//继续弹出去
                if (!stack.isEmpty()){
                    int min = Math.min(height[stack.peek()], height[i]);
                    count+=(min-height[popped])*(i- stack.peek()-1);
                }
            }
            stack.push(i);
        }
        return count;
    }
}

```







### 逆波兰算法

### [剑指 Offer II 036. 后缀表达式](https://leetcode.cn/problems/8Zf90G/)

根据[ 逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437)，求该后缀表达式的计算结果。

有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 **说明：**

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

 **示例 1：**

```sh
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。



```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<>();
        for(int i = 0;i<tokens.length;i++){
            String token = tokens[i];
            if(isNumber(token)) {
                stack.push(Integer.parseInt(token));//压入数字到栈厘米
            }else{
                int num2 = stack.pop();
                int num1 = stack.pop();//弹出两个就是数组
                switch(token){
                    case "+":{
                        stack.push(num1+num2);
                        break;
                    }
                    case "-":{
                        stack.push(num1-num2);
                        break;
                    }
                    case "*":{
                        stack.push(num1*num2);
                        break;
                    }
                    case "/":{
                        stack.push(num1/num2);
                        break;
                    }
                }
            }
        }
        return stack.pop();
    }
    public boolean isNumber(String s){
        return !("+".equals(s)||"-".equals(s)||"*".equals(s)||"/".equals(s));
        // 既不是加减乘除就是对的数字了
    }
}
```

> 你想哈，这个数字可能是几百上千的，所以我们不能说用判断0到9就行了





### [32. 最长有效括号-栈存储](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

 

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

```java
import java.util.ArrayDeque;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int longestValidParentheses(String s) {
        if (s.length()<1) return 0;
        int ans  = 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        stack.push(-1);
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)=='('){
                stack.push(i);//左边的就存入
            }
            else {
                stack.pop();
                //peek存的是没有配对的最小的元素
                if (!stack.isEmpty()) ans = Math.max(ans,i-stack.peek());
                else stack.push(i);
            }
        }
        return ans;
    }
}
```



## 哈希算法

### [290. 单词规律](https://leetcode.cn/problems/word-pattern/)

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。



**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

**示例 2:**

```
输入:pattern = "abba", s = "dog cat cat fish"
输出: false
```

**示例 3:**

```
输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
```

 

**提示:**

- `1 <= pattern.length <= 300`
- `pattern` 只包含小写英文字母
- `1 <= s.length <= 3000`
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随对空格
- `s` 中每个单词都被 **单个空格** 分隔

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        //一个单词就是一个组合
        String[] strings = s.split(" ");
        HashMap<Character, String> map = new HashMap<>();
        if (pattern.length()!=strings.length){
            return false;
        }
        for (int i = 0; i < pattern.length(); i++) {
            char key = pattern.charAt(i);
            if (map.containsKey(key)){
                //如果遇到过这个key
                if (!map.get(key).equals(strings[i])){
                    return false;
                }
            }else {
                //没有遇到过的话，就要看这个s里面是不是有匹配的key了
                if (map.containsValue(strings[i])){
                    return false;//如果有匹配的了，那就罪过了
                }
                map.put(key,strings[i]);
            }
        }
        return true;
    }
}
```





### [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)



请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

 

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        //给数独编号
        Map<Integer, Set<Integer>> row = new HashMap<>(),col = new HashMap<>(),area = new HashMap<>();
        //加入三个HashMap
        for (int i = 0; i < 9; i++) {
            row.put(i,new HashSet<>());
            col.put(i,new HashSet<>());
            area.put(i,new HashSet<>());
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                //读取9*9的各个
                char c = board[i][j];
                if (c=='.') continue;
                int u = c-'0';
                int areaIdx=i/3 * 3+j/3;
                if (row.get(i).contains(u)||
                col.get(j).contains(u)||
                area.get(areaIdx).contains(u))
                    return false;
                row.get(i).add(u);//给每个元素加上
                col.get(j).add(u);
                area.get(areaIdx).add(u);
            }
        }
        return true;
    }
}
```





### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

> map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        if(nums==null||nums.length==0) return ans;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp =target-nums[i];
            if(map.containsKey(tmp)) {
                return new int[]{i,map.get(tmp)};
            }
            map.put(nums[i],i);
        }
        return ans;
    }
}
```

### 四数之和II

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2



实际就是化简为两个数之和

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int tmp = i + j;
                map.put(tmp,map.getOrDefault(tmp,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int tmp = i + j;
                // 直接寻找相对的数是否存在，存在就直接可以算作是一组数，几个value就是几组
                if (map.containsKey(0-tmp))
                    ans+=map.get(0-tmp);
            }
        }
        return ans;
    }
}
```



### 哈希法求解不含重复字串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int j = 0;
        // p w w e k
        // j   i
        //找到w上一次的位置设置为最长子串的起始点。
        if (s.length()==1) return 1;
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))){
                j = Math.max(j,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            ans = Math.max(ans,i-j+1);
        }
        return ans;
    }
}
```



给定一个字符串数组 `strs` ，将 **变位词** 组合在一起。 可以按任意顺序返回结果列表。

**注意：**若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。



**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```



由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> map = new HashMap<>();
//        map存放排好序了的string的数组
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String s = new String(chars);//将排好序的重新转化成string
            List<String> path = map.getOrDefault(s, new ArrayList<>());//取出来s对应的list，
            path.add(str);
            map.put(s,path);//重新再放回去
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

### [249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)

给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：`"abc" -> "bcd"`。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：

```
"abc" -> "bcd" -> ... -> "xyz"
```

给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。

**示例：**

```
输入：["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]
输出：
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]
解释：可以认为字母表首尾相接，所以 'z' 的后续为 'a'，所以 ["az","ba"] 也满足 “移位” 操作规律。
```

```java
class Solution {
    public List<List<String>> groupStrings(String[] strings) {
         if (strings==null || strings.length==0) return new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();//存储
        for (String string : strings) {
            StringBuilder sb = new StringBuilder();
            for (char c : string.toCharArray()) {
                sb.append("#");
                int shift = (c-string.charAt(0)+26)%26;
                sb.append(shift);
            }
            String key = sb.toString();
            if (!map.containsKey(key)) map.put(key,new ArrayList<String>());
            map.get(key).add(string);
        }
        return new ArrayList<>(map.values());
    }
}
```



> 记录移动的位置的时候，存储有一个循环的 时候我们可以加一个26再对26取一个模
>
> `int shift = (c-string.charAt(0)+26)%26;` 就可以实现循环了，比如az就是ba的相似的

## 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。

那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**更直白来说，就是用一个栈来记录我们遍历过的元素**，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，**如果需要使用对应的元素，直接T[i]就可以获取。**

1. 单调栈里元素是递增呢？ 还是递减呢？

**顺序的描述为 从栈头到栈底的顺序**，从左到右或者从前到后，

这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。

即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。

文字描述理解起来有点费劲，接下来我画了一系列的图，来讲解单调栈的工作过程，大家再去思考，本题为什么是递增栈。

使用单调栈主要有三个判断条件。

* 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
* 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
* 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况





### 天气：

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```
示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]
```

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        // 单调栈，遍历递增循序（再强调一下是指从栈头到栈底的顺序），
        // 因为只有递增的时候，栈里要加入一个元素i的时候，
        // 才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        deque.push(0);//就是在队列的左边，头部，加入了初始的0
        for (int i = 1; i < temperatures.length; i++) {
            while (!deque.isEmpty() && temperatures[i]>temperatures[deque.peek()]){
                ans[deque.peek()] = i - deque.peek(); // 最右边的
                deque.pop();
            }
            deque.push(i);
        }
        return ans;
    }
}
```



![739.每日温度6](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303231393132343730303536372e6a7067.jpeg)



### 



### 滑动窗口局部最大值

```txt
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 
输出: [3,3,5,5,6,7] 
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```

这一题是滑动窗口，所以单调栈的构造需要确定是不是在k的范围内，

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        LinkedList<Integer> queue = new LinkedList<>();
        //准备单调队列
        for (int right = 0; right < nums.length; right++) {
//            队首元素就是该窗口内的最大值。
            while (!queue.isEmpty() && nums[right]>=nums[queue.peekLast()]) {
                queue.removeLast();
//            非空的时候，如果信赖的比queue顶部的元素大的话，就移走这个
            }
            queue.addLast(right);
//            如果首部坐标小于left，那么就删除这个
            int left = right-k+1;//此时这个left实际也就是依次递增的
            if (queue.peekFirst()<left){
                queue.removeFirst();
            }
            if (left>=0) {
                ans[left] = nums[queue.peekFirst()];
//                这个first对应就是前k个区间内的大的数值了
            }
        }
    }
}
```





### [剑指 Offer II 039. 直方图最大矩形面积](https://leetcode.cn/problems/0ynMMM/)

给定非负整数数组 `heights` ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 `1` 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```



```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] temp = new int[heights.length+2];//存储单调栈
        System.arraycopy(heights,0,temp,1,heights.length);
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        int area = 0;
        for(int i= 0;i<temp.length;i++){
            while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
                //如果当前位置的高度比stack的小，那么就会漏水
                int h = temp[stack.pop()];
                // 比如： 2 1 
                // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
                // 所以stack里面一直有元素
                area = Math.max(area,h*(i-stack.peek()-1));
                // 当stack为 1 5 6 时
                // 2 小于 6 ，所以area更新为 6
                // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
            }
            stack.push(i);
        }
        return area;
    }
}
```



### [剑指 Offer II 040. 矩阵中最大的矩形](https://leetcode.cn/problems/PLYXKQ/)

难度困难76收藏分享切换为英文接收动态反馈

给定一个由 `0` 和 `1` 组成的矩阵 `matrix` ，找出只包含 `1` 的最大矩形，并返回其面积。

**注意：**此题 `matrix` 输入格式为一维 `01` 字符串数组。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```
输入：matrix = ["10100","10111","11111","10010"]
输出：6
解释：最大矩形如上图所示。
```



看下边的橙色的部分，这完全就是上一道题呀！

![image.png](https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png)

算法有了，就是求出每一层的 heights[] 然后传给上一题的函数就可以了。



```java
class Solution {
    public int maximalRectangle(String[] matrix) {
        if(matrix.length==0) return 0;
        int n = matrix[0].length();
        int[] heights = new int[n];
        int maxArea = 0;
        for(int i = 0;i<matrix.length;i++){
            for(int j = 0;j<n;j++){
                if(matrix[i].charAt(j) == '1'){
                    heights[j] +=1;
                }else{
                    heights[j] = 0;
                }
            }
            maxArea = Math.max(maxArea,largestRectangleArea(heights));
        }
        return maxArea;
    }

    public int largestRectangleArea(int[] heights) {
    int[] temp = new int[heights.length+2];//存储单调栈
    System.arraycopy(heights,0,temp,1,heights.length);
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    int area = 0;
    for(int i= 0;i<temp.length;i++){
        while(!stack.isEmpty() && temp[i]<temp[stack.peek()]) {
            //如果当前位置的高度比stack的小，那么就会漏水
            int h = temp[stack.pop()];
            // 比如： 2 1 
            // peek 为序号 0 的数字为0.temp是 0 2 1 5 6 2 3 
            // 所以stack里面一直有元素
            area = Math.max(area,h*(i-stack.peek()-1));
            // 当stack为 1 5 6 时
            // 2 小于 6 ，所以area更新为 6
            // 弹出 6 ， 2小于5 所以 area更新为 5 * （2） 等于10
        }
        stack.push(i);
    }
    return area;
    }
}
```



## 优先级队列

### PriorityQueue的作用

PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。

在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。

Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。

Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。

Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。

由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。

这里牵涉到了大小关系，**元素大小的评判可以通过元素本身的自然顺序（\*natural ordering\*），也可以通过构造时传入的比较器**（*Comparator*，或者元素自身实现 Comparable 接口）来决定。

在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。



### [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/)



设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。

请实现 `KthLargest` 类：

- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

示例：

```sh
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```



其实就是优先级队列，做一个小丁队

```java
class KthLargest {
    PriorityQueue<Integer> queue;
    int k;
    public KthLargest(int k, int[] nums) {
        queue = new PriorityQueue<>();
        // 默认是从小到达的顺序，小顶堆
        for(int num: nums){
            queue.add(num);
        }
        this.k = k;
    }
    
    public int add(int val) {
        queue.offer(val);
        while(queue.size()>k){
            queue.poll();
        }
        return queue.peek();
    }
}
```



### [剑指 Offer II 060. 出现频率最高的 k 个数字](https://leetcode.cn/problems/g5c51o/)

> 关键： 优先级存储了频率和数字，直接定一个PriorityQueue<int[ ] > 
>
> 



给定一个整数数组 `nums` 和一个整数 `k` ，请返回其中出现频率前 `k` 高的元素。可以按 **任意顺序** 返回答案。



**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

 

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        PriorityQueue<int[]> queue= new PriorityQueue<>(new Comparator<>(){
            public int compare(int[] a,int[] b){
                return a[1]-b[1];
            }
        });
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            // 遍历每一个map的元素
            int num = entry.getKey(), count = entry.getValue();
            
            if(queue.size()==k){
                if(queue.peek()[1]<count){
                    queue.poll();
                    queue.offer(new int[]{num,count});
                }
            }else{
                queue.offer(new int[]{num,count});
            }
            /*也可以全部都加进去，之后再判断队列大小，大了的部分就poll出去。
            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                Integer num = entry.getKey();
                Integer value = entry.getValue();
                queue.offer(new int[]{num,value});
            }
            while (queue.size()>k){
                queue.poll();
            }
            */
            
        }
        int[] res = new int[k];
        for(int i = 0;i<k;i++){
            res[i] = queue.poll()[0];
        }
        return res;
    }
}
```



### [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)



给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。

 

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->nums1[a[0]] + nums2[a[1]] - nums1[b[0]] - nums2[b[1]]);
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]));
        for(int i = 0;i<Math.min(k,nums1.length);i++){
            heap.offer(new int[]{i,0});
            //nums1的索引都放到heap里面，
            
        }
        List<List<Integer>> ans = new ArrayList<>();
        // 最多弹出 k 次
        while(k-- >0 && !heap.isEmpty()){
            //其实就是吧heap整理一下
            //卧槽，就是说弹出k次heap堆的堆顶，肯定就是最小值
            int[] pos = heap.poll();
            ans.add(Arrays.asList(nums1[pos[0]],nums2[pos[1]]));
            // 将 index2 加 1 之后继续入队
            if(++pos[1]<nums2.length){
                heap.offer(pos);
            }
        }
        return ans;
    }
}
```



## TreeSet

 Java中 TreeMap和TreeSet算是java集合类里面比较有难度的数据结构。和普通的HashMap不一样，普通的HashMap元素存取的时间复杂度一般是O(1)的范围，而TreeMap内部对元素的操作复杂度为O(logn)。

虽然在元素的存取方面TreeMap并不占优，但是它内部的元素都是排序的，当需要查找某些元素以及顺序输出元素的时候它能够带来比较理想的结果。可以说，**TreeMap是一个内部元素排序版的HashMap。**同样，TreeSet是一个封装了一个HashSet的成员变量来实现的，底层运用了红黑树的数据结构。

### TreeSet Vs. HashSet

TreeSet和HashSet都实现了Set接口。然而，它们之间存在着一些区别。

- 与HashSet不同，TreeSet中的元素是以某种顺序存储的。这是因为TreeSet还实现了SortedSet接口。
- TreeSet提供了一些易于导航的方法。 例如first()，last()，headSet()，tailSet()等。这是因为TreeSet还实现了NavigableSet接口。
- 对于添加、删除、包含和大小等基本操作，HashSet比TreeSet更快。



### 使用

为了创建树集，我们必须首先导入java.util.TreeSet包。

导入包之后，下面是如何在Java中创建TreeSet。

```
TreeSet<Integer> numbers = new TreeSet<>();
```

在这里，我们创建了一个没有任何参数的TreeSet。在本示例中，TreeSet中的元素自然排序(升序)。

但是，我们可以使用Comparator接口自定义元素的排序。



### [剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/)

给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。

如果存在则返回 `true`，不存在返回 `false`。

 

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

```java
class Solution {

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        // 滑动窗口，窗口大小为k，窗口内两个数字的大小相差为t
        TreeSet<Long> set =  new TreeSet<>();
        for(int i = 0;i<nums.length;i++){
            Long item = nums[i]*1L;
            Long floor = set.floor(item);
            Long ceil = set.ceiling(item);
            // 比较ceil和floor一个是刚大于一点点item，一个是稍小一点点item的元素
            if(floor!=null && (item-floor<=t)) return true;
            if(ceil!=null && ceil-item<=t)  return true;
            set.add(item);
            //移除大于窗口的元素
            if(i>=k) set.remove(nums[i-k]*1L);
        }
        return false;
    }
}
```







### Method

### first()和last()方法

- first() - 返回集合的第一个元素
- last() - 返回集合的最后一个元素

例如，

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 first() 方法
        int first = numbers.first();
        System.out.println("第一个数字: " + first);

        // 使用 last() 方法
        int last = numbers.last();
        System.out.println("最后一个数字: " + last);
    }
}
```

**输出结果**

```
TreeSet: [2, 5, 6]
第一个数字: 2
最后一个数字: 6
```

### ceiling()，floor()，higher()和lower()方法

- **Higher(element)** - 返回大于指定元素(element)的最小元素。
- **lower(element)** - 返回小于指定元素(element)的最大元素。
- **ceiling(element)** - 返回大于指定元素(element)的那些元素中的最小元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。
- **floor(element)** - 返回小于指定元素(element)的元素中最大的元素。如果传递的元素(element)存在于树集中，则返回作为参数传递的元素(element)。

```java
import java.util.TreeSet;

class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(4);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // 使用 higher()
        System.out.println("使用 higher: " + numbers.higher(4));

        // 使用 lower()
        System.out.println("使用 lower: " + numbers.lower(4));

        // 使用 ceiling()
        System.out.println("使用 ceiling: " + numbers.ceiling(4));

        // 使用 floor()
        System.out.println("使用 floor: " + numbers.floor(3));

    }
}
```

**输出结果**

```
TreeSet: [2, 4, 5, 6]
使用 higher: 5
使用 lower: 2
使用 ceiling: 4
使用 floor: 2
```

> 当然作为基础的set也可以实现set的方法，执行集合的各种操作







> **TreeMap** 
>
> ```sh
> 输入:
> ["MyCalendar","book","book","book"]
> [[],[10,20],[15,25],[20,30]]
> 输出: [null,true,false,true]
> 解释: 
> MyCalendar myCalendar = new MyCalendar();
> MyCalendar.book(10, 20); // returns true 
> MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了
> MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 
> 
> ```
>
> 
>
> ```java
> 
> class MyCalendar {
>      TreeMap<Integer,Integer> map =null;
>     public MyCalendar() {
>         map =   new TreeMap<>();
>     }
>     
>     public boolean book(int start, int end) {
>         // 查找刚刚好大于等于start时间的条目；
>         Map.Entry<Integer,Integer> event = map.ceilingEntry(start);
>         if(event!=null && event.getKey()<end){
>             // 如果刚大于start，但是开始的比要添加进去的end还要早，就错了
>             return false;
>         }
>         // 查找刚刚好小于等于start时间的条目；
>         event = map.floorEntry(start);
>         // 结束的时间不能比要插入的开始的晚，
>         if(event!=null && event.getValue()>start){
>             return false;
>         }
>         map.put(start,end);
>         return true;
> 
>     }
> }
> 
> /**
>  * Your MyCalendar object will be instantiated and called as such:
>  * MyCalendar obj = new MyCalendar();
>  * boolean param_1 = obj.book(start,end);
>  */
> ```
>
> 



## 图论



### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。 

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

解题思路：这是一个有向图的搜索问题。本质上就是求两个节点之间的距离。

首先定义邻接节点，里面有两个字段，分表表示邻接节点的名称和当前节点到达邻接节点所需的倍数；
然后构造一个map来存储图，map的键就是节点名称，map的值就是节点的邻接节点列表；
遍历给定所有算式，将节点和值都存到map当中；
遍历需要求的问题，深搜每个节点，为了防止进入环绕圈，用一个集合来存储已经搜索过的节点。



```java
class Node{
    public String id;
    public double num;
    public Node(String i,double n){
        id = i;
        num = n;
    }
}
class Solution {
    Map<String, List<Node>> map;
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int n = equations.size();
        map = new HashMap<>();
        double[] ans = new double[queries.size()];
        for (int i = 0; i < n; i++) {
            String divided = equations.get(i).get(0);//被除的数
            String divisor = equations.get(i).get(1);//除数
            if (!map.containsKey(divided)) map.put(divided,new ArrayList<>());
            if (!map.containsKey(divisor)) map.put(divisor,new ArrayList<>());
            map.get(divided).add(new Node(divisor,values[i]));
            map.get(divisor).add(new Node(divided,1/values[i]));//保存和另一个节点的倍数的关系
        }
        int cnt = 0;
        for (List<String> query : queries) {
            ans[cnt] = dfs(query.get(0),query.get(1),1.0,new HashSet<>());
            cnt++;
        }
        return ans;
    }

    /**
     * 深搜
     * @param cur 表示当前节点
     * @param tar 表示目标节点
     * @param k 计算的倍数
     * @param set 保存已经走过的节点
     * @return
     */
    double dfs(String cur,String tar,double k,Set<String> set){
        if (!map.containsKey(cur)||set.contains(cur)) return -1.0;
        if (cur.equals(tar)) return k;
        set.add(cur);
        for (Node node : map.get(cur)) {
            //遍历当前的cur的相邻的边的节点
            double t = dfs(node.id, tar, k * node.num, set);
            if (t!=-1.0) return t;
        }
        return -1.0;
    }
}
```



### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**



方法一，主要是理解邻接表。

例如，`numCourses = 5, prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]` 时：

邻接表如下：

- 节点 1 能到节点 2 和节点 4，节点 2 能到节点 3 和节点 4；
- 这就表明节点 2，4 的前置节点都为 1，节点 3，4 的前置节点都为 2。

```java
前置节点        
    1     |2|  ——>  |4|

    2     |3|  ——>  |4|

    3     |5|

    4     |5|

    5
```

在每次 pre 出队时，执行 numCourses--；
若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 000。
因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //入度表
        int[] inDegrees = new int[numCourses];//记录节点的入度的数
        List<List<Integer>> adjacency = new ArrayList<>();//邻接表
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }
        for (int[] pre : prerequisites) {
            //节点的入度等于将以该节点为目标节点的边的数量。
            inDegrees[pre[0]]++;//统计每个节点的入度
            adjacency.get(pre[1]).add(pre[0]);//记录从pre[1]指向出去的值
        }
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                //统计入度为0的值，存入queue
                queue.add(i);//入度为0，说明没有前提预修课程
            }
        }
        // numCourses = 5
        // prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]
        while (!queue.isEmpty()){
            //遍历所有没有以该节点为目标节点的节点，入度为0；
            Integer pre = queue.poll();
            numCourses--;
            for (Integer cur : adjacency.get(pre)) {
                //遍历以该节点为预修课程的节点
                //相当于本来机械设计 需要材料力学和理论力学，汽车设计需要理论力学，理论力学是入度为0的课程
                // 现在的pre等于理论力学，adjacency里面存储的就是 材料力学和理论力学，
                inDegrees[cur]--;//消除掉当前预科对应的这个入度，也就是材料力学和理论力学的入度都--；
                if (inDegrees[cur]==0){ //当入度为0的时候，完成了所有的潜质的课程
                    queue.add(cur);
                }
            }
        }
        return numCourses==0;
    }
}
```



### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2：**

```
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**示例 3：**

```
输入：numCourses = 1, prerequisites = []
输出：[0]
```

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        //入度表
        int[] inDegrees = new int[numCourses];//记录节点的入度的数
        List<List<Integer>> adjacency = new ArrayList<>();//邻接表
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }
        for (int[] pre : prerequisites) {
            //节点的入度等于将以该节点为目标节点的边的数量。
            inDegrees[pre[0]]++;//统计每个节点的入度
            adjacency.get(pre[1]).add(pre[0]);//记录从pre[1]指向出去的值
        }
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i]==0){
                //统计入度为0的值，存入queue
                queue.add(i);//入度为0，说明没有前提预修课程
            }
        }
        int idx = 0;
        int[] ans = new int[numCourses];
        // numCourses = 5
        // prerequisites = [[2,1],[3,2],[4,1],[4,2],[5,3],[5,4]]
        while (!queue.isEmpty()){
            //遍历所有没有以该节点为目标节点的节点，入度为0；
            Integer pre = queue.poll();
            ans[idx++] = pre;
            for (Integer cur : adjacency.get(pre)) {
                //遍历以该节点为预修课程的节点
                //相当于本来机械设计 需要材料力学和理论力学，汽车设计需要理论力学，理论力学是入度为0的课程
                // 现在的pre等于理论力学，adjacency里面存储的就是 材料力学和理论力学，
                inDegrees[cur]--;//消除掉当前预科对应的这个入度，也就是材料力学和理论力学的入度都--；
                if (inDegrees[cur]==0){ //当入度为0的时候，完成了所有的潜质的课程
                    queue.add(cur);
                }
            }
        }
        if (idx==numCourses) return ans;
        return new int[0];
    }
}
```



## 多叉树



### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

 

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```



Trie 树
TrieTrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。

其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

![IMG_1659.PNG](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1618369228-slAfrQ-IMG_1659.png)





```java
class Trie {
    class TrieNode{
        // Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。
        boolean end;
        TrieNode[] tns = new TrieNode[26];
    }
    TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        /**
         * 首先从根结点的子结点开始与 word 第一个字符进行匹配，
         * 一直匹配到前缀链上没有对应的字符，
         * 这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，
         * 同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。
         */
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u] = new TrieNode();
            p = p.tns[u];//26叉树
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        /**
         * 从根结点的子结点开始，一直向下匹配即可，
         * 如果出现结点值为空就返回 false，
         * 如果匹配到了最后一个字符，那我们只需判断 node->isEnd即可。
         */
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) return false;
            p = p.tns[u];//26叉树
        }
        return p.end;
    }

    /**
     * 判断 Trie 中是或有以 prefix 为前缀的单词
     * @param prefix
     * @return
     */
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char c : prefix.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) return false;
            p = p.tns[u];//26叉树
        }
        return true;
    }
}
```



### [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。

 

**示例：**

```
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // 返回 False
wordDictionary.search("bad"); // 返回 True
wordDictionary.search(".ad"); // 返回 True
wordDictionary.search("b.."); // 返回 True
```



```java
class WordDictionary {
    class TrieNode{
        boolean isWord;
        TrieNode[] tns = new TrieNode[26];
    }
    TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void addWord(String word) {
        TrieNode p = root;
        for (char c : word.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u]= new TrieNode();
            p = p.tns[u];//就是插入一个u的下标的元素
        }
        p.isWord = true;
    }
    
    public boolean search(String word) {
        return dfs(word,root,0);
    }
    boolean dfs(String s,TrieNode p,int idx){
        if (idx==s.length()) return p.isWord;
        char c = s.charAt(idx);
        if (c=='.'){
            for (int i = 0; i < 26; i++) {
                //遍历一下所有的26个字母，如果不等于null，继续回溯遍历
                if (p.tns[i]!=null && dfs(s,p.tns[i],idx+1)) return true;
            }
            return false;
        }else {
            if (p.tns[c-'a']==null) return false;
            return dfs(s,p.tns[c-'a'],idx+1);//继续遍历下一个。
        }
    }
}
```



### [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)



给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， *返回所有二维网格上的单词* 。

单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

**示例 2：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/search2.jpg)

```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]
```

 

**提示：**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` 是一个小写英文字母
- `1 <= words.length <= 3 * 104`
- `1 <= words[i].length <= 10`



```java
class Solution {
    class TrieNode{
        String s;
        TrieNode[] tns= new TrieNode[26];
    }
    void insert(String s){
        TrieNode p = root;
        for (char c : s.toCharArray()) {
            int u = c - 'a';
            if (p.tns[u]==null) p.tns[u] = new TrieNode();
            p = p.tns[u];
        }
        p.s = s;//存储当前的单词
    }
    Set<String> set = new HashSet<>();
    char[][] board;
    int m,n;//方块的大小小于 12
    TrieNode root = new TrieNode();
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    boolean[][] vis = new boolean[15][15];//15够用了
    public List<String> findWords(char[][] board, String[] words) {
        this.board = board;
        m = board.length;
        n = board[0].length;
        for (String word : words) {
            insert(word);//将所有的单词存进去字典树里面，如果遍历到有单词的时候，就直接添加到结果
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int u = board[i][j] - 'a';
                if (root.tns[u]!=null){
                    //当前棋盘当前位置能够在字典树找到对应的字母就继续开始寻找
                    vis[i][j]=true;
                    dfs(i,j,root.tns[u]);
                    vis[i][j] = false;
                }
            }
        }
        List<String> ans = new ArrayList<>();
        for (String s : set) {
            ans.add(s);
        }
        return ans;
    }
    void dfs(int i,int j,TrieNode node){
        if (node.s!=null) set.add(node.s);
        for (int[] dir : dirs) {
            int dx = i+dir[0],dy = j+dir[1];
            if (dx<0||dx>=m||dy<0||dy>=n) continue;//超限的就不遍历了
            if (vis[dx][dy]) continue;//遍历过的就不遍历了。
            int u = board[dx][dy] - 'a';
            if (node.tns[u]!=null){
                vis[dx][dy]=true;
                dfs(dx,dy,node.tns[u]);
                vis[dx][dy] = false;
            }
        }
    }
}
```

## 堆/优先队列

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

 

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        //使用堆的方法
        if (nums==null||nums.length<k ||k==0) return Integer.MIN_VALUE;
        PriorityQueue<Integer> maxQ = new PriorityQueue<>(Collections.reverseOrder());
        for (int num : nums) {
            maxQ.add(num);
        }
        while (k-->1){
            maxQ.poll();
        }
        return maxQ.peek();
    }
}
```





# 二、算法模板

## 排序算法

### 选择排序

```java
import java.util.Arrays;
public class Solution {
// 选择排序：每一轮选择最小元素交换到未排定部分的开头

public int[] sortArray(int[] nums) {
    int len = nums.length;
    // 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子
    for (int i = 0; i < len - 1; i++) {
        // 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i
        int minIndex = i;
        for (int j = i + 1; j < len; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j;
            }
        }
        swap(nums, i, minIndex);
    }
    return nums;
}

private void swap(int[] nums, int index1, int index2) {
    int temp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = temp;
	}	

public static void main(String[] args) {
    int[] nums = {5, 2, 3, 1};
    Solution solution = new Solution();
    int[] res = solution.sortArray(nums);
    System.out.println(Arrays.toString(res));
	}
}
```
### 快速排序



```java
class Solution {
    public String minNumber(int[] nums) {
        //参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的asc码差值
        String[] strs = new String[nums.length];
        for(int i =0;i<nums.length;i++){
            strs[i]=String.valueOf(nums[i]);
        }
      	quickSort(strs,0,strs.length-1);
     	 StringBuilder res = new StringBuilder();
      	for(String s:strs){
        	res.append(s);
      	}
      	return res.toString();
    }
    void quickSort(String[] strs,int left,int right){
        if(left>=right) {
            return;
        }
        int pivotIndex =partition(strs,left,right);
        quickSort(strs,left,pivotIndex-1);
        quickSort(strs,pivotIndex+1,right);
    }
    private int partition(String[] strs,int left,int right) {
        String pivot=strs[left];
        //j是pivot第一个区间最后一个元素所在的位置
        int j=left;
        for(int i=left+1;i<=right;i++) {
            if((strs[i]+pivot).compareTo((pivot+strs[i]))<0) {
                j++;
                swap(strs,i,j);
            }
            
        }
        swap(strs,left,j);
        //此时j处于第一个区间的最后一个位置，实际上就是需要的切分元素现在所在的位置了
        return j;
    }
    private void swap(String[] nums,int i,int j) {
        String temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

}
```

### 插入排序

由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。

```java
public class Solution {

    // 插入排序：稳定排序，在接近有序的情况下，表现优异

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组
        for (int i = 1; i < len; i++) {
            // 先暂存这个元素，然后之前元素逐个后移，留出空位
            int temp = nums[i];
            int j = i;
            // 注意边界 j > 0
            while (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}


```

### 堆排序

堆就是完全二叉树

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图

![img](https://raw.githubusercontent.com/52chen/imagebed2023/main/picgo/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://gcore.jsdelivr.net/gh/mcxen/image@main/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

堆排序的基本思想是：将**待排序序列构造成一个大顶堆**heapify，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```java
import java.util.Arrays;
public class HeapSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i=arr.length/2-1;i>=0;i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j>0;j--){
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr,0,j);//重新对堆进行调整
        }

    }
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i
        for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```



```java
class Solution {
    public int[] sortArray(int[] nums) {
        //实战堆排序
        for(int i = nums.length/2-1;i>=0;i--){
            heapify(nums,i,nums.length);
        }
        for(int i = nums.length-1;i>=1;i--){
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            heapify(nums,0,i);
        }
        return nums;
    }
    void heapify(int[] nums,int i,int length){
        int maxindex = i;
        int leftson = 2*i+1;
        int rightson = 2*i+2;
        if(leftson<length&&nums[leftson]>nums[maxindex]) maxindex =leftson;
        if(rightson<length&&nums[rightson]>nums[maxindex]) maxindex = rightson;//选这三者里面最大的作为naxIndex。
        if(maxindex!=i){
            // 如果发生了交换，那么
            int temp = nums[maxindex];
            nums[maxindex] =nums[i];
            nums[i] = temp;
            heapify(nums,maxindex,length);//交换了最大元素之后的位置继续进行堆排序
        }

    }
}
```

[LeetCode排序堆排序题解](https://leetcode.cn/submissions/detail/410212711/)

### 归并排序

[链表排序](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
//        归并排序
       if(head == null || head.next == null) return head;
       ListNode fast = head;
       ListNode slow = head;
       while (fast.next!=null && fast.next.next!=null) {
           fast = fast.next.next;
           slow = slow.next;
       }
        ListNode cnt = slow.next;//从中间切开
        slow.next = null;
        ListNode dummy = new ListNode();
        ListNode res = dummy;
        ListNode left = sortList(head);
        ListNode right = sortList(cnt);
        while (left!=null&&right!=null) {
            if(left.val<right.val) {
                res.next = left;
                left = left.next;
            }else {
                res.next = right;
                right=right.next;
            }
            res = res.next;
        }
        res.next = left!=null? left:right;
        return dummy.next;

    }

}
```



统计逆序对：

```java
class Solution {
    int[] nums,tmp;
    public int reversePairs(int[] nums) {
        //归并排序，计算逆序
        this.nums = nums;
        tmp = new int[nums.length];
        return merge(0,nums.length-1);
    }
    int merge(int left,int right){
        if(left>=right) return 0;
        int m = (left+right)/2;
        int res = merge(left,m)+merge(m+1,right);
        //上面是归并拆分
      
        //下面开始归并排序
        int i = left,j=m+1;
        for(int k =left;k<=right;k++){
            tmp[k] = nums[k];//拷贝一份
            //
        }
        for(int k = left;k<=right;k++){
            //左子区间的元素都遍历了，剩下只要把右子区间剩下的元素加入nums即可
            if(i==m+1)
                while(k<=right) nums[k++]=tmp[j++];
             //同上，此时右子区间的元素已经遍历完，只需要添加左子区间的元素到nums
            else if(j==right+1)
                while(k<=right) nums[k++]=tmp[i++];
            else if(tmp[i]<=tmp[j]){
                //往nums添加一个按从小到达排列的元素，不引入逆序对
                nums[k]=tmp[i++];
            }else {
                //对应 tmp[i] > tmp[j]
                res+=m-i+1;//也就是说，在合并左右子区间时，新引入了共m-i+1对 以tmp[j]为右元素的逆序对
                nums[k]=tmp[j++];
            } 
        }
        return res;
    }
}
```

### [280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)



给你一个的整数数组 `nums`, 将该数组重新排序后使 `nums[0] <= nums[1] >= nums[2] <= nums[3]...` 

输入数组总是有一个有效的答案。



**示例 1:**

```
输入：nums = [3,5,2,1,6,4]
输出：[3,5,1,6,2,4]
解释：[1,6,2,5,3,4]也是有效的答案
```

```java
class Solution {
    public void wiggleSort(int[] nums) {
        for (int i = 0; i < nums.length-1; i++) {
            if ((i%2==0)==(nums[i]>nums[i+1])){
                //当前位置为偶数的时候，应该递增，为奇数时为递减
                //nums[i]>nums[i+1]为递减的时候我们就交换一下
                int temp = nums[i];
                nums[i] = nums[i+1];
                nums[i+1] = temp;
            }
        }
    }
}
```

## 二分查找法 

### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

 

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

众所周知，满足两个条件就可以二分：

- 答案一定存在，或者可以 O(1)O(1)O(1) 验证是不是答案；

- 一次查询可以扔掉一半答案.

假设当前分割点 mid 满足关系 num[mid] ＞ nums[mid + 1] 的话，一个很简单的想法是 num[mid]可能为峰值，而 nums[mid + 1] 必然不为峰值，于是r=mid，从左半部分继续找峰值。

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
          	//这里是r=mid，所以不需要加0.5，向下取整，就是向左取整，因此r=mid不会循环
            if (nums[mid] > nums[mid + 1]) r = mid;//num[mid]可能为峰值
            else l = mid + 1; //nums[mid + 1] 可能为峰值
        }
        return r;
    }
}
```



```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        if (n == 1) return 0;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (nums[mid] > nums[mid - 1]) l = mid;
            else r = mid - 1;
        }
        return r;
    }
}

```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0,r = nums.length-1;
        while (l<=r){
            int m = (l + r) / 2;
            if (nums[m]==target) return m;
            // [3, 1] 1 如果没有等号，l=0,m=0,r=1,没有等号，就遍历不到0这个位置了
            else if (nums[m] >=nums[l]) {
                //System.out.println("m = " + m);
                //这里是左边有序
                if (nums[m]>target&&nums[l]<=target){
                    r = m-1;
                }else {
                    l = m+1;
                }
            }else{
                //这里是右边有序
                if (nums[m]<target&&nums[r]>=target){
                    l = m+1;
                }else {
                    r = m-1;
                }
            }
        }
        return -1;
    }
}
```



### 二分查找

**前提是数组为有序数组**，同时题目还强调**数组中无重复元素**

```java
class Solution {
    public int search(int[] nums,int target){
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;//左闭右闭
    }
}
```



```CPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        return right;
    }
};

```

## KMP

```CPP
void kmp(int* next, const string& s){
    next[0] = -1;
    int j = -1;
    for(int i = 1; i < s.size(); i++){
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

## 二叉树

###  基础知识

- 如何找到叶子节点：

```java
if (root.left == null && root.right == null) {
    // 当是叶子节点的时候，开始处理
    res += listToInt(path);
    return;
}
```



### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/num1tree.jpg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```



```java
class Solution {
    List<Integer> path = new ArrayList<>();
    int res = 0;
    public int sumNumbers(TreeNode root) {
        // 如果节点为0，那么就返回0
        if (root == null) return 0;
        // 首先将根节点放到集合中
        path.add(root.val);
        // 开始递归
        recur(root);
        return res;
    }

    public void recur(TreeNode root){
        if (root.left == null && root.right == null) {
            // 当是叶子节点的时候，开始处理
            res += listToInt(path);
            return;
        }

        if (root.left != null){
            // 注意有回溯
            path.add(root.left.val);
            recur(root.left);
            path.remove(path.size() - 1);
        }
        if (root.right != null){
            // 注意有回溯
            path.add(root.right.val);
            recur(root.right);
            path.remove(path.size() - 1);
        }
        return;
    }
    public int listToInt(List<Integer> path){
        int sum = 0;
        for (Integer num:path){
            // sum * 10 表示进位
            sum = sum * 10 + num;
        }
        return sum;
    }
}

```



```java
class Solution {

    public int sumNumbers(TreeNode root) {
        if(root==null) return 0;
        return recur(root,0);
    }
    int recur(TreeNode root,int sum){
        if(root==null) return 0;
        sum=sum*10+root.val;
        if(root.left==null&&root.right==null) return sum;
        return recur(root.left,sum)+recur(root.right,sum);
    }
}
```





### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return helper(root.left,root.right);
    }
    private boolean helper(TreeNode left,TreeNode right){
        if(left==null&&right!=null) return false;
        else if(left!=null&&right==null) return false;
        else if(left==null&&right==null) return true;
        else if(left.val!=right.val) return false;
        boolean outside = helper(left.left,right.right);
        boolean inside = helper(left.right,right.left);
        return outside&&inside;
    } 
}
```





### 序列化与反序列化二叉树：

```java
public String serialize(TreeNode root) {
        if (root==null) return "";
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
//            只要不是空的
            TreeNode polled = queue.poll();
            if (polled!=null){
                sb.append(""+polled.val);
                queue.offer(polled.left);
                queue.offer(polled.right);

            }else {
                sb.append("null");
            }
            sb.append(",");
        }
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data=="") return null;
        String substring = data.substring(1, data.length() - 1);
        String[] datalist = substring.split(",");
//        split之后就可以得到字符串列表了
        TreeNode root = new TreeNode(Integer.parseInt(datalist[0]));
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i =1;
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            if (!"null".equals(datalist[i])){
                poll.left =  new TreeNode(Integer.parseInt(datalist[i]));
                queue.offer(poll.left);
            }
            i++;
            if (!"null".equals(datalist[i])){
                poll.right =  new TreeNode(Integer.parseInt(datalist[i]));
                queue.offer(poll.right);
            }
            i++;
        }
        return root;

    }
```





##  

二叉树的定义：

```CPP
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 非递归的方式 前序中序后序遍历

- 二叉搜索树

![二叉搜索树案例](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/101244_5f1a777e_508704.png)

#### 前序遍历

**java 实现**

完全二叉树的非递归遍历前序遍历， 中间，左边，右边

```java
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> lists = new ArrayList<>();
    if(root == null){
        return lists;
    }
    Stack<TreeNode> stack = new Stack<>();
    //根节点先入栈
    stack.push(root);
    TreeNode current = null;
    while(!stack.isEmpty()){
        current = stack.pop();
        lists.add(current.val);

        //这里注意，要先压入右子结点，再压入左节点。因为栈是先进后出
        if(current.right != null){
            stack.push(current.right);
        }
        if(current.left != null){
            stack.push(current.left);
        }
    }
    return lists;
}
```

**栈信息**

我们可以加一点 debug 日志，把访问的节点和 stack 的内容输出出来。

```java
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> lists = new ArrayList<>();
    if(root == null){
        return lists;
    }
    Stack<TreeNode> stack = new Stack<>();
    //根节点先入栈
    stack.push(root);
    System.out.println("【根节点】root.value="+root.val+" 入栈，STACK " + root);
    TreeNode current = null;
    while(!stack.isEmpty()){
        current = stack.pop();
        lists.add(current.val);
        System.out.println("\n【出栈】"+current.val+"，STACK " + lists);
        System.out.println("【添加】添加 "+current.val+" 到 LIST" + lists);

        //这里注意，要先压入右子结点，再压入左节点。因为栈是先进后出
        if(current.right != null){
            stack.push(current.right);
            System.out.println("【右节点】入栈 "+current.right.val+" 到 STACK " + stack);
        }
        if(current.left != null){
            stack.push(current.left);
            System.out.println("【左节点】入栈 "+current.left.val+" 到 STACK " + stack);
        }
    }
    return lists;
}
```
![输入图片说明](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/101244_5f1a777e_508704.png)

重新执行以下，日志如下：

```sh
【根节点】root.value=4 入栈，STACK (4: (2: (1: null,null),(3: null,null)),(6: (5: null,null),(7: null,null)))

【出栈】4，STACK []
【添加】添加 4 到 LIST[4]
【右节点】入栈 6 到 STACK [(6: (5: null,null),(7: null,null))]
【左节点】入栈 2 到 STACK [(6: (5: null,null),(7: null,null)), (2: (1: null,null),(3: null,null))]

【出栈】2，STACK [4]
【添加】添加 2 到 LIST[4, 2]
【右节点】入栈 3 到 STACK [(6: (5: null,null),(7: null,null)), (3: null,null)]
【左节点】入栈 1 到 STACK [(6: (5: null,null),(7: null,null)), (3: null,null), (1: null,null)]

【出栈】1，STACK [4, 2]
【添加】添加 1 到 LIST[4, 2, 1]

【出栈】3，STACK [4, 2, 1]
【添加】添加 3 到 LIST[4, 2, 1, 3]

【出栈】6，STACK [4, 2, 1, 3]
【添加】添加 6 到 LIST[4, 2, 1, 3, 6]
【右节点】入栈 7 到 STACK [(7: null,null)]
【左节点】入栈 5 到 STACK [(7: null,null), (5: null,null)]

【出栈】5，STACK [4, 2, 1, 3, 6]
【添加】添加 5 到 LIST[4, 2, 1, 3, 6, 5]

【出栈】7，STACK [4, 2, 1, 3, 6, 5]
【添加】添加 7 到 LIST[4, 2, 1, 3, 6, 5, 7]
[4, 2, 1, 3, 6, 5, 7]
```

 



#### 中序遍历

>  中序遍历的时候 访问到的元素是从小到大顺序排列的。

下面是递归遍历的模板

```java
中序遍历过程模板
public void inorder(TreeNode root){
        if (root == null) return ;    //终止条件
        inorder(root.left);           //访问左子树
        对当前节点进行一些操作          //访问根节点-----在遍历过程中希望实现的操作
        inorder(root.right);          //访问右子树
    }
```



非递归的方式就是用栈来存取走过的路

![输入图片说明](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/112405_d205ffd2_508704.png)



```java

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //前中后
        ArrayList<Integer> list = new ArrayList<>();
        if (root==null) return list;
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;
        while (cur!=null||!stack.isEmpty()){
            while (cur!=null){
                stack.push(cur);
                cur = cur.left;//找到最左边的位置
            }
            cur = stack.pop();//找到最左边的了
            list.add(cur.val);
            cur = cur.right;//开始访问右边的的了
        }
        return list;
    }
}
```





#### 后序遍历：

**思路**

①先序遍历顺序：根节点-左孩子-右孩子

②后序遍历顺序：左孩子-右孩子-根节点

③后序遍历倒过来：根节点-右孩子-左孩子

①和③对比发现，访问顺序只有左孩子和右孩子颠倒了一下

**思路：**

第一步，将二叉树按照先序非递归算法进行遍历，

注意在入栈的时候左右孩子入栈的顺序，先左后右。

第二步，将遍历得到的结果进行倒置。 思路牛逼666

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        //后续遍历的非递归的实现
        //后序是 左 右 中，倒过来就是 中 右 左 stack就是中，左，右
        LinkedList<Integer> list = new LinkedList<>();
        if (root==null) return list;
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            list.addFirst(pop.val);//直接添加到头部就可以反过来了
            if (pop.left!=null){
                stack.push(pop.left);
            }
            if (pop.right!=null){
                stack.push(pop.right);
            }
        }
        return list;
    }
}
```



> 也可以直接reverse整个的list的结果：
>
> ```java
> class Solution {
>     public List<Integer> postorderTraversal(TreeNode root) {
>         //非递归
>         // 就是先序的反过来的方式 左 右 中，
>         // 中 右 左 饭过来
>         LinkedList<Integer> list = new LinkedList<>();
>         if (root==null) return list;
>         ArrayDeque<TreeNode> stack = new ArrayDeque<>();
>         stack.push(root);
>         while (!stack.isEmpty()){
>             TreeNode curr = stack.pop();
>             list.add(curr.val);
>             if(curr.left!=null){
>                 stack.push(curr.left);
>             }
>             if(curr.right!=null){
>                 stack.push(curr.right);
>             }
>         }
>         Collections.reverse(list);
>         return list;
>     }
> }
> ```
>
> 



### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```



如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。 即情况一： 

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20220922173502.png" style="zoom:50%;" />

情况二： 

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20220922173530.png" style="zoom:50%;" />

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```CPP
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树写法：

```CPP
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

看出区别了没？

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

如图：

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2021020415105872.png" alt="236.二叉树的最近公共祖先" style="zoom:50%;" />

就像图中一样直接返回7，多美滋滋。

但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。

因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。

```CPP 
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

所以此时大家要知道我们要遍历整棵树。

完整流程图如下：

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/202102041512582.png" alt="236.二叉树的最近公共祖先2" style="zoom:50%;" />



```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) { // 递归结束条件
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left == null && right == null) { // 若未找到节点 p 或 q
            return null;
        }else if(left == null && right != null) { // 若找到一个节点
            return right;
        }else if(left != null && right == null) { // 若找到一个节点
            return left;
        }else { // 若找到两个节点
            return root;
        }
    }
}
```





### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

本题需要将二叉树转化为列表，对于二叉树的题目，无非就以下几种解题思路：

先序遍历（深度优先搜索）
中序遍历（深度优先搜索）（尤其二叉搜索树）
后序遍历（深度优先搜索）
层序遍历（广度优先搜索）（尤其按照层来解决问题的时候）
序列化与反序列化（结构唯一性问题）
根据我们的观察，本题应该是使用深度优先搜索的方式来解决，我们看看是怎样变成一个列表的。如图所示：



其实是分为三步：

首先将根节点的左子树变成链表
其次将根节点的右子树变成链表
最后将变成链表的右子树放在变成链表的左子树的最右边
这就是一个递归的过程，递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出。对于函数flatten来说：

函数作用：将一个二叉树，原地将它展开为链表
输入：树的根节点
输出：无
那我们就直接根据三步来写程序就可以了

代码
```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return ;
        }
        //将根节点的左子树变成链表
        flatten(root.left);
        //将根节点的右子树变成链表
        flatten(root.right);
        TreeNode temp = root.right;
        //把树的右边换成左边的链表
        root.right = root.left;
        //记得要将左边置空
        root.left = null;
        //找到树的最右边的节点
        while(root.right != null) root = root.right;
        //把右边的链表接到刚才树的最右边的节点
        root.right = temp;
    }
}


```







### 纠正二叉搜索树

输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。

```java
class Solution {
    TreeNode pre = new TreeNode(Integer.MIN_VALUE);
    TreeNode err1 = null;
    TreeNode err2 = null;
    public void recoverTree(TreeNode root) {
        inorder(root);
        int tmp = err1.val;
        err1.val = err2.val;
        err2.val = tmp;
    }
    void inorder(TreeNode root) {
        if(root == null) return;
        inorder(root.left);
        if(pre.val>root.val&&err1==null) err1=pre;//！不相邻，前大后小，第一个错误就要取大的
        if(pre.val>root.val&&err1!=null) err2=root;//哦哦哦哦哦！不相邻，前大后小，第二个错误就要取小的
        pre = root;
        inorder(root.right);

    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //非递归方式实现中序遍历
        List<Integer> res = new LinkedList();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root!=null||!stack.isEmpty()) {
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
    
}
```





### 深度优先遍历（递归） 

前序遍历（中左右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```
中序遍历（左中右）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```
后序遍历（左右中）
```CPP
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

### 深度优先遍历（迭代法）

相关题解：[0094.二叉树的中序遍历](https://github.com/youngyangyang04/leetcode/blob/master/problems/0094.二叉树的中序遍历.md)

前序遍历（中左右）
```CPP
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}

```

中序遍历（左中右）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result; // 存放中序遍历的元素
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); 
            if (node->right) st.push(node->right);  // 右
            st.push(node);                          // 中
            st.push(NULL); 
            if (node->left) st.push(node->left);    // 左
        } else {
            st.pop(); 
            node = st.top(); 
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

后序遍历（左右中）
```CPP
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```




#### [剑指 Offer II 049. 从根节点到叶节点的路径数字之和](https://leetcode.cn/problems/3Etpl5/)

难度中等49

给定一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }
    int dfs(TreeNode root,int preSum){
        if(root == null) return 0;
        int sum = preSum*10+root.val;
        if(root.left==null && root.right == null){
            return sum;
        }
        return dfs(root.left,sum) + dfs(root.right,sum);
    }
}
```





### 广度优先遍历（队列）

相关题解：[0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)

```CPP
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}

```



可以直接解决如下题目：

* [0102.二叉树的层序遍历](https://programmercarl.com/0102.二叉树的层序遍历.html)
* [0199.二叉树的右视图](https://github.com/youngyangyang04/leetcode/blob/master/problems/0199.二叉树的右视图.md)
* [0637.二叉树的层平均值](https://github.com/youngyangyang04/leetcode/blob/master/problems/0637.二叉树的层平均值.md) 
* [0104.二叉树的最大深度 （迭代法）](https://programmercarl.com/0104.二叉树的最大深度.html)

* [0111.二叉树的最小深度（迭代法）](https://programmercarl.com/0111.二叉树的最小深度.html)
* [0222.完全二叉树的节点个数（迭代法）](https://programmercarl.com/0222.完全二叉树的节点个数.html)



### [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode.cn/problems/hPov7L/)-层序遍历



给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。



**示例1：**

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 
```



```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
        List<Integer> ans = new LinkedList<Integer>();
        if(root == null) return ans;
        stack.push(root);
        
        while(!stack.isEmpty()){
            int size = stack.size();
            int tempMax =Integer.MIN_VALUE;
            for(int i = 0;i<size;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
                tempMax = Math.max(tempMax,poped.val);
            }
            ans.add(tempMax);
        }
        return ans;

    }
}
```





### [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode.cn/problems/LwUNpT/)-层序遍历

难度中等40

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈

写出来了

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
       int ans = 0;
        if(root == null) return ans;
        stack.push(root);
        
        while(!stack.isEmpty()){
            int size = stack.size();
            int tempMax =Integer.MIN_VALUE;
            ans = stack.peek().val;
            for(int i = 0;i<size;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
                tempMax = Math.max(tempMax,poped.val);
            }
            
        }
        return ans;
    }
}
```



### [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode.cn/problems/WNC0Lk/)

难度中等43

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```



哈哈哈哈哈哈哈，层序遍历，每一层最右边的就是需要的右侧的试图

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        ArrayDeque<TreeNode> stack =  new ArrayDeque<>();
        List<Integer> ans = new LinkedList<Integer>();
        if(root == null) return ans;
        stack.push(root);
        while(!stack.isEmpty()){
            int size = stack.size();
            
            for(int i = 0;i<size-1;i++){
                TreeNode poped = stack.pop();
                if(poped.left!=null) stack.addLast(poped.left);
                if(poped.right!=null) stack.addLast(poped.right);
            }
            TreeNode poped = stack.pop();
            ans.add(poped.val);
            if(poped.left!=null) stack.addLast(poped.left);
            if(poped.right!=null) stack.addLast(poped.right);
        }
        return ans;
    }
}

```

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```



```java
class Solution {
    public Node connect(Node root) {
        Node dummy = root;
        Queue<Node> list = new LinkedList<>();//stack 实现层序遍历
        if(root==null) return root;
        list.add(root);
        while(!list.isEmpty()){
            Node curr = null;
            Node prev = null;
            int size = list.size();
            for(int i = 0;i<size;i++){
                if(i==0){
                    prev = list.poll();
                    curr = prev;
                }else{
                    curr = list.poll();
                    prev.next = curr;
                    prev = prev.next;
                }
                if(curr.left!=null) list.add(curr.left);
                if(curr.right!=null) list.add(curr.right);
            }
            prev.next = null;
        }
        return dummy;
    }
}
```





### 二叉树深度

```CPP
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

### 二叉树节点数量

```CPP
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```



### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。

实现 `CBTInserter` 类:

- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)` 向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；
- `CBTInserter.get_root()` 将返回树的头节点。

 



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg)

```java
class CBTInserter {
    List<TreeNode> list = new ArrayList<>();
    int idx = 0;
    public CBTInserter(TreeNode root) {
        list.add(root);
        int cur =0;
        //这里就是把传进来的二叉树进行序列化
        while(cur<list.size()) {
            // 如果当前的长度比较长的话
            TreeNode node = list.get(cur);
            if(node.left!=null) list.add(node.left);
            if(node.right!=null) list.add(node.right);
            cur++;
        }
    }
    
    public int insert(int val) {
        TreeNode node = new TreeNode(val);
        while(list.get(idx).left!=null && list.get(idx).right!=null)
            idx++;
        TreeNode father = list.get(idx);//找到了左边或者右边的子节点有位置的地方
        if(father.left==null) father.left = node;
        else if(father.right == null) father.right =node;
        list.add(node);
        return father.val;
    }
    
    public TreeNode get_root() {
        return list.get(0);
    }
}
```



### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root==null) return true;
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        if (leftNode!=null){
            while (leftNode.right!=null){
                leftNode = leftNode.right;//左边子树的最大值
            }
            if (leftNode.val>=root.val) return false;
        }
        if (rightNode!=null){
            while (rightNode.left!=null){
                rightNode = rightNode.left;//右边子树的最小值
            }
            if (rightNode.val<=root.val) return false;
        }
        return isValidBST(root.left) && isValidBST(root.right);
    }
    //只要根节点大于左子树的最大值，小于右子树的最小值即可。

}
```





## 回溯算法 

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：

![回溯算法理论基础](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20210130173631174.png)



递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

如果是求目标target，就是找到target之后是多少层就是多少层。







```CPP
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }a

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

回溯函数遍历过程伪代码如下：

```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。



### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```



```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        traverse(candidates,target,0);
        return ans;
    }
    private void traverse(int[] candidates,int target,int idx){
        if (sum==target){
            ans.add(new ArrayList<>(path));
            return;
        }
        if (sum>target) return;
        for (int i = idx; i < candidates.length; i++) {
          //这里是在遍历集合区间，可以理解一个节点有多少个孩子，idx就是保证每一次遍历后
          //孩子节点都会少一个。
            int candidate = candidates[i];
            if (i>idx&&candidates[i-1]==candidate) continue;//wocao,这里确实碉堡了
          //如果不是上这样，结果就是【1 2 6】、【1 2 6】这样会用重复的结果，
          
            if (candidate >target) return;
            sum+=candidate;
            path.add(candidate);
            traverse(candidates, target, i+1);
            sum-=candidate;
            path.remove(path.size()-1);
        }
    }
}

```

### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

 

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```



```java

class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();//过程路径
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        //数组元素重复，但是搭配不能重复，
        vertrace(nums,0);
        return ans;
    }
    void vertrace(int[] nums,int idx){
        ans.add(new ArrayList<>(path));//存储
        for (int i = idx; i < nums.length; i++) {
            //回溯算法注意遍历的广度和深度
            if (i>idx&&nums[i-1]==nums[i]){
                continue;//如果同一个树树干上使用过相同的，就跳过
            }
            path.add(nums[i]);
            vertrace(nums,i+1);
            path.remove(path.size()-1);
        }
        return;
    }
}
```



### 47.全排列 II

[力扣题目链接](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

* 输入：nums = [1,1,2]
* 输出：
  [[1,1,2],
   [1,2,1],
   [2,1,1]]

示例 2：

* 输入：nums = [1,2,3]
* 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

提示：

* 1 <= nums.length <= 8
* -10 <= nums[i] <= 10



这道题目和[46.全排列](https://programmercarl.com/0046.全排列.html)的区别在与**给定一个可包含重复数字的序列**，要返回**所有不重复的全排列**。

这里又涉及到去重了。

在[40.组合总和II](https://programmercarl.com/0040.组合总和II.html) 、[90.子集II](https://programmercarl.com/0090.子集II.html)我们分别详细讲解了组合问题和子集问题如何去重。

那么排列问题其实也是一样的套路。

**还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：

![47.全排列II1](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201331223-20230802163414885.png)

如果是按照used[i-1]=true时候：按树枝来减

![全排列去重复.drawio](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/%E5%85%A8%E6%8E%92%E5%88%97%E5%8E%BB%E9%87%8D%E5%A4%8D.drawio.svg)



图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。

**一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果**。

在[46.全排列](https://programmercarl.com/0046.全排列.html)中已经详细讲解了排列问题的写法，在[40.组合总和II](https://programmercarl.com/0040.组合总和II.html) 、[90.子集II](https://programmercarl.com/0090.子集II.html)中详细讲解了去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```

大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 `used[i - 1] == true`， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/20201124201431571-20230802163519118.png)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。

总结

这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

和这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

都是可以的，这也是很多同学做这道题目困惑的地方，知道`used[i - 1] == false`也行而`used[i - 1] == true`也行，但是就想不明白为啥。

所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！

是不是豁然开朗了！！

### [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> res= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTrace(n,k,1);//递归函数返回值为void，一般直接就在参数里面修改
        return res;
    }
    void backTrace(int n,int k, int s){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        /*
        已经选择的元素个数：path.size();
        还需要的元素个数为: k - path.size();
        在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
        */
        //可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠s
        for(int i =s;i<=n-(k-path.size())+1;i++ ){
            path.add(i);
            backTrace(n,k,i+1);
            path.removeLast();
        }
    }
}
```

> 如果 `n = 7, k = 4`，**从 5 开始搜索就已经没有意义了**，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。
>
> 因此在集合n中至多要从该起始位置 : n - (k - path.size()) + 1
>
> ```java
>         for (int i = begin; i <= n-(k-path.size())+1; i++) {
> 
> ```
>
> 

![77.组合1](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67.png)

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)



给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```



```JAVA
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    HashMap<Integer,String> map = new HashMap<>(){
        {
            put(2,"abc");
            put(3,"def");
            put(4,"ghi");
            put(5,"jkl");
            put(6,"mno");
            put(7,"pqrs");
            put(8,"tuv");
            put(9,"wxyz");
        }
    };
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits.length()==0) return ans;
        back(digits,0,0);
        //回溯算法，就是遍历
        return ans;
    }
    void back(String digits,int idx,int charIdx){
        if (idx==digits.length()){
            ans.add(sb.toString());
            return;
        }
        //遍历数字，
        char c = digits.charAt(idx);
        String s = map.get(c - '0');
        for (int j = 0; j < s.length(); j++) {
            //单个字符的长度
            sb.append(s.charAt(j));
            back(digits,idx+1,j);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```





### [剑指 Offer II 084. 含有重复元素集合的全排列 ](https://leetcode.cn/problems/7p8L0Z/)

给定一个可包含重复数字的整数集合 `nums` ，**按任意顺序** 返回它所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);//排列一下
        used = new boolean[nums.length];
        back(nums);
        return ans;
    }
    void back(int[] nums){
        if (path.size() == nums.length){
            ans.add(new ArrayList<>(path));
            return;
        }
        int last = -11;
        for (int i = 0; i < nums.length; i++) {
            if ((used[i] || i>0 && nums[i]==nums[i-1] && used[i-1]))
                continue;//去掉重
            // i>0 && nums[i]==nums[i-1] && used[i-1] 这里应该是说如果当前元素和上一个相同，有可能是可以继续使用的
//            判断为不能使用的话，得加一个判断，判断之前的元素也是用过的，那就可以了
            path.add(nums[i]);
            used[i]= true;
            back(nums);
            used[i]= false;
            path.remove(path.size()-1);
        }
    }
}
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)



**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        //startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。
        //本题我们还需要一个变量pointNum，记录添加逗点的数量。
        if (s.length()>12) return ans;
        backTrace(s,0,0);
        return ans;
    }
    void backTrace(String s, int begin,int pointNumber) {
        if (pointNumber==3){
            //此时已经到达了最后一个阶段，判断begin到最后的一段是否合法，不合法就不添加
            if (isValid(s,begin,s.length()-1))
                ans.add(s);
            return;
        }
        for (int i = begin; i < s.length(); i++) {
            if (isValid(s,begin,i)){
                s=s.substring(0, i + 1) + "." + s.substring(i + 1);
                //插入一个。
                pointNumber++;
                backTrace(s,i+2,pointNumber);
                pointNumber--;
                s=s.substring(0, i + 1) + s.substring(i + 2);
            }else {
                continue;
            }
        }
    }
    boolean isValid(String s,int begin,int end) {
        if (begin>end) return false;
        if (s.charAt(begin)=='0'&&begin!=end){
            return false;
            //0开头的数字不合法，此时begin和end不相等的
        }
        int num =0;

        for (int i = begin; i <= end; i++) {
            if (s.charAt(i)>'9'||s.charAt(i)<'0')
                return false;
            num = num *10 + (s.charAt(i)-'0');
            if (num>255)
                return false;
        }
        return true;
    }
}
```



### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)



给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

```java
class Solution {
    HashMap<Long,Integer> map = new HashMap<>();
    public int pathSum(TreeNode root, int targetSum) {
//        回溯算法
        map.put(0L,1);//存储前缀和为0的次数为1；
        return recursion(root,targetSum,0L);
    }
    int recursion(TreeNode root,int targetSum,Long currSum) {
        if (root==null) return 0;
        int res = 0;
        currSum+=root.val;
        // 看看root到当前节点这条路上是否存在[节点前缀和加target] 为currSum的路径
        //currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target
        //因为currSUm是前缀和，也就是前面所有的都加起来，如果之前走过的路上有事currSum-target的位置，那么
        //那个位置到现在，currSum-(curr-target)=target，不就是一个你需要的target吗？
        res+=map.getOrDefault(currSum-targetSum,0);
        // 更新路径上当前节点前缀和的个数
        map.put(currSum,map.getOrDefault(currSum,0)+1);
        res+=recursion(root.left,targetSum,currSum);
        res+=recursion(root.right,targetSum,currSum);
        map.put(currSum,map.getOrDefault(currSum,0)-1);
        return res;
    }

}
```



### :star2: [112. 路径总和](https://leetcode.cn/problems/path-sum/) 



给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsum2-20231026201006343.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```



https://www.bilibili.com/video/BV19t4y1L7CR/?t=46



```java
// 标准回溯的写法：

class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        //要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。
        //遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。
        if(root==null) return false;
        return recur(root,targetSum-root.val);
    }
    boolean recur(TreeNode root,int targetSum){
        if(root==null) return false;
//        targetSum-=root.val;
        if(root.left==null&&root.right==null&&targetSum==0) return true;
        if(root.left==null&&root.right==null) return false;
        if(root.left!=null){
//            targetSum-=root.left.val;
//            if (recur(root.left,targetSum)) return true;
//            targetSum+=root.left.val;
            //上面的代码可以缩减为一行，其实你只要穿一个虚幻的树枝下去，不用实际更改targetSum的值就可以回溯
            if (recur(root.left,targetSum-root.left.val)) return true;
        }
        if(root.right!=null){
            targetSum-=root.right.val;
            if (recur(root.right,targetSum)) return true;
            targetSum+=root.right.val;
        }
        return false;
    }
}
```







### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```



```java
class Solution {

    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        //如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。
        recur(root,targetSum);
        return ans;
    }
    void recur(TreeNode root,int target){
        if(root==null) return;
        path.add(root.val);
        target-=root.val;
        if (root.left==null&&root.right==null&&target==0){
            ans.add(new ArrayList<>(path));
        }
        recur(root.left,target);
        recur(root.right,target);
        path.remove(path.size()-1);
    }
}
```



```java
// 标准回溯的写法：
class Solution {

    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null) return ans;
        //如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。
        path.add(root.val);
        recur(root,targetSum-root.val);//这里对最开始的处理了，就得在path加上这个val。
        return ans;
    }
    void recur(TreeNode root,int target){

        if (root.left==null&&root.right==null&&target==0){
            ans.add(new ArrayList<>(path));
            return;
        }
        if (root.left==null&&root.right==null){
            return;
        }
        if(root.left!=null){
            path.add(root.left.val);
            target-=root.left.val;
            recur(root.left,target);
            target+=root.left.val;
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            path.add(root.right.val);
            target-=root.right.val;
            recur(root.right,target);
            target+=root.right.val;
            path.remove(path.size()-1);
        }
        return;
    }
}

```





### [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)



给定一个字符串 `s` ，请将 `s` 分割成一些子串，使每个子串都是 **回文串** ，返回 s 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 

**示例 1：**

```
输入：s = "google"
输出：[["g","o","o","g","l","e"],["g","oo","g","l","e"],["goog","l","e"]]
```



```java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();
    private String s;
    public String[][] partition(String s) {
        this.s = s;
        back(0);
        String[][] res = new String[ans.size()][];
        for (int i = 0; i < ans.size(); i++) {
            String[] temp = new String[ans.get(i).size()];
            for (int j = 0; j < ans.get(i).size(); j++) {
                temp[j] = ans.get(i).get(j);
            }
            res[i] = temp;//这里的temp每一个都是不同的。
        }
        return res;
    }
    void back(int idx){
        if (idx == s.length()){
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            if (isPali(idx,i)) {
                path.add(s.substring(idx,i+1));
                back(i+1);
                path.remove(path.size()-1);
            }
        }
    }
    boolean isPali(int left,int right){
        while (left < right)
            if (s.charAt(left++) != s.charAt(right--))
                return false;
        return true;
    }
}
```

### 79.单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**输入：**board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED" **输出：**true





```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board,word,0,i,j)) return true;
            }
        }
        return false;
    }
    int[] dx = new int[]{-1,0,1,0},dy =  new int[]{0,1,0,-1};
    boolean dfs(char[][] board,String word,int u,int x,int y){
        if (board[x][y]!=word.charAt(u)) return false;
        if (u==word.length()-1) return true;
        char c = board[x][y];
        board[x][y]='.';
        for (int i = 0; i < 4; i++) {
            int a = x+dx[i],b = y+dy[i];
            if (a<0||a>=board.length||b<0||b>=board[0].length||board[a][b]=='.')
                continue;
            if (dfs(board,word,u+1,a,b)) return true;
        }
        board[x][y]=c;
        return false;
    }
}
```





### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

 

**示例 1:**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```







```java
class Solution {
    int deepest = Integer.MIN_VALUE;
    int ans = 0;
    public int findBottomLeftValue(TreeNode root) {
        recur(root,1);
        return ans;
    }
    void recur(TreeNode root,int depth){
        if (root==null) return;
        if (root.left==null&&root.right==null&&depth>deepest){
            ans = root.val;
            deepest = Math.max(deepest,depth);
        }
//        if (root.left!=null){
//            recur(root.left,depth+1);
//        }
        recur(root.left,depth+1);//还可以缩减成这样，因为就算是null传进去了，也无所谓
//        if (root.right!=null){
//            recur(root.right,depth+1);
//        }
        recur(root.right,depth+1);
    }
}
```







### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 ```java
 class Solution {
     List<String> ans = new ArrayList<>();
     public List<String> generateParenthesis(int n) {
         backtrack(n,n,"");
         return ans;
     }
     void backtrack(int l,int r,String cur){
         if (l==0&&r==0){
             ans.add(cur);
             return;
         }
         if (l>0){
             backtrack(l-1,r,cur+'(');
         }
         if (r>l){
             backtrack(l,r-1,cur+')');
         }
     }
 }
 ```



### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```



```java
class Solution {
    boolean[][] visited = new boolean[15][15];
    int m,n;
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board,i,j,word,0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board,int i,int j, String word,int idx){
        if (board[i][j]!= word.charAt(idx)) return false;
        if (idx==word.length()-1) return true;
        visited[i][j]=true;
        for (int[] dir : dirs) {
            int dx = i+dir[0],dy = j+dir[1];
            if (dx<0||dx>=m||dy<0||dy>=n||visited[dx][dy]) continue;//超限的就不遍历了
            if (dfs(board,dx,dy,word,idx+1)) return true;
        }
        visited[i][j]=false;
        return false;
    }
}
```





## 动态规划



### [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true
```



我们定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。

状态转换方程也很好写了，如果要求 dp [ i ] [ j ] 。

如果 dp [ i - 1 ] [ j ] == true，并且 s1 [ i - 1] == s3 [ i + j - 1]， dp [ i ] [ j ] = true 。

如果 dp [ i ] [ j - 1 ] == true，并且 s2 [ j - 1] == s3 [ i + j - 1]， dp [ i ] [ j ] = true 。

否则的话，就更新为 dp [ i ] [ j ] = false。

如果 i 为 0，或者 j 为 0，那直接判断 s2 和 s3 对应的字母或者 s1 和 s3 对应的字母即可。



```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s3.length()!=(s1.length()+s2.length())) return false;
        int m = s1.length();
        int n = s2.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                int k = i+j-1;
                if (i>0){
                    //向前推进dp数组，新的dp等于原来的是不是true，然后当前的字符是不是相等的
                    dp[i][j] = dp[i-1][j] &&(s1.charAt(i-1)==s3.charAt(k));
                }
                if (j>0){
                    dp[i][j] = dp[i][j] ||(dp[i][j-1]&&s2.charAt(j-1)==s3.charAt(k));
                }
            }
        }
        return dp[m][n];
        //dp[i][j] 表示的是当前是否是s3的i+j的正确的表达式
        //if(s3.chatAt(i+j)==s1.char或者s2.char -》dp[i][j] = dp[i-1][j]

    }
}
```



### II 019回文字符 



给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。



**示例 1:**

```
输入: s = "aba"
输出: true
```

**示例 2:**

```
输入: s = "abca"
输出: true
解释: 可以删除 "c" 字符 或者 "b" 字符
```

```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }
        }
        return true;
    }
    private boolean validSub(String s,int le,int ri){
        while (le<ri){
            if (s.charAt(le)!=s.charAt(ri)) return false;
            le++;
            ri--;
        }
        return true;
    }
}
```



### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给定一个字符串 `s` ，请计算这个字符串中有多少个回文子字符串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。



**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```



**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成



注意：本题与主站 647 题相同：https://leetcode-cn.com/problems/palindromic-substrings/



```java
class Solution {
    public int countSubstrings(String s) {
        //动态规划，dp[i][j]表示i到j是否是回文串
        int length = s.length();
        boolean[][] dp = new boolean[length][length];
        int count = 0;
        for (int i = 0; i < length; i++) {
            dp[i][i] = true;
            count++;
        }
        /*
        * 当下标 i 和 j 相同时：区间只有一个字母，是回文子串。
        * 当下标 i 和 j 相差为 1 时：区间有两个字母，且这两个字母相同，是回文子串。
        * 当下标 i 和 j 相差大于 1 时：此时有 s[i] == s[j] ，
        要看区间 [i, j] 是不是回文子串，就得看中间夹着的区间 [i + 1, j - 1]
        是不是回文子串，即当 dp[i + 1][j - 1] = true 时，
        区间 [i, j] 是回文子串，否则就不是回文子串。
         */
        for (int i = length-1; i >= 0; i--) {
            for (int j = i+1; j < length; j++) {
                char ci = s.charAt(i);
                char cj = s.charAt(j);
                if (j-1>=i+1){
                    //中间的区间
                    dp[i][j] = (ci==cj) && dp[i+1][j-1];
                }else {
                    dp[i][j] = (ci==cj);//只有一个元素的时候
                }
                if (dp[i][j]) count++;
                //如果上述判断完了之后是true，那么就计数+1；
            }
        }
        return count;
    }
}
```




```java
for (int i = 0; i < n; i++) {
  for (int j = 0; j < i; j++) {
    char ci = s.charAt(i);
    char cj = s.charAt(j);
    if (i>j+1){
      dp[j][i]=(dp[j+1][i-1])&&(ci==cj);
    }else {
      dp[j][i]=(ci==cj);
    }
    if (dp[j][i]) count++;
  }
}
```



### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

本题最容易想到的一种方法应该就是 **中心扩散法**。

中心扩散法怎么去找回文串？

从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。举个例子，*str*=*acdbbdaa* 我们需要寻找从第一个 b（位置为 3）出发最长回文串为多少。怎么寻找？

首先往左寻找与当期位置相同的字符，直到遇到不相等为止。

然后往右寻找与当期位置相同的字符，直到遇到不相等为止。

最后左右双向扩散，直到左和右不相等。如下图所示：

<img src="https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/2f205fcd0493818129e8d3604b2d84d94678fda7708c0e9831f192e21abb1f34.png" alt="img" style="zoom:50%;" />

每个位置向两边扩散都会出现一个窗口大小（`len`）。如果 `len>maxLen`(用来表示最长回文串的长度）。则更新 `maxLen` 的值。
因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 `maxLen` 时的起始位置（`maxStart`），即此时还要 `maxStart=len`。

```java
class Solution {
    public String longestPalindrome(String s) {
        //用中间向两边扩散的方法
        if (s.length()<2) return s;
        int n = s.length();
        int maxLeft=0,maxRight=0;
        int left = 0,right = 0;
        int len = 1;
        int maxLen = 0;
        for (int i = 0; i < n; i++) {
            left = i-1;
            right = i+1;
            while (left>=0 && s.charAt(left)==s.charAt(i)) {
                left--;
                len++;
            }
            while (right<n && s.charAt(right)==s.charAt(i)) {
                right++;
                len++;
            }
            //left 和right都是不和i处相等的了，
            while (left>=0 && right<n && s.charAt(left)==s.charAt(right)) {
                len+=2;
                left--;
                right++;
            }
            if (len>maxLen){
                maxLen=len;
                maxLeft=left;
                maxRight=right;
            }
            len=1;
        }
        return s.substring(maxLeft+1,maxRight);
    }
}
```





```java
class Solution {
    public String longestPalindrome(String s) {
        /**
         * 我们用一个 boolean dp[l][r] 表示字符串从
         * i 到 j 这段是否为回文。试想如果 dp[l][r]=true
         * ，我们要判断 dp[l-1][r+1] 是否为回文。
         * 只需要判断字符串在(l-1)和（r+1)两个位置是否为
         * 相同的字符，是不是减少了很多重复计算。
         */
        if (s==null||s.length()<2) return s;
        int n = s.length();
        int maxStart=0,maxEnd=0,maxLen=1;
        boolean[][] dp = new boolean[n][n];
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < j; i++) {
                //遍历从i到j
                if (s.charAt(i)==s.charAt(j)&&(j-i<=2||dp[i+1][j-1])){
                    dp[i][j]=true;
                    //j-i<=2||dp[i+1][j-1] i和j之间的元素小于等于一个或者中间的为回文
                    if (j-i+1>maxLen){
                        maxStart=i;
                        maxEnd=j;
                        maxLen=j-i+1;
                    }
                }
            }
        }
        return s.substring(maxStart,maxEnd+1);
    }
}
```



```java
class Solution {
    public String longestPalindrome(String s) {
        //用动态规划的方法

        if (s.length()<2) return s;
        String ans= String.valueOf(s.charAt(0));
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i]=true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                char ci = s.charAt(i);
                char cj = s.charAt(j);
                if (i>j+1){
                    //间隔一个以上
                    dp[j][i]=(dp[j+1][i-1])&&(ci==cj);
                }else {
                    dp[j][i]=(ci==cj);
                }
                if (dp[j][i]){
                    if (ans.length()<(i-j+1)) ans = s.substring(j,i+1);
                }
            }
        }
        return ans;
    }
}
```



### [剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/)

如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列 `arr` ，找到 `arr` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

*（回想一下，子序列是从原序列 `arr` 中派生出来的，它从 `arr` 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， `[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的一个子序列）*



```java
class Solution {
    public int lenLongestFibSubseq(int[] arr) {
        //每个斐波那契数列都可以由其最后两位数字精准定位
        int n = arr.length;
        int[][] dp = new int[n][n];
        // dp[2][3]表示数列[1,2,3]、dp[3][5]表示数列[1,2,3,5]、
        // dp[5][8]表示数列[1,2,3,5,8]
        //每个dp元素的值，代表它所定位的数列的长度，
        // 例如上面的 dp[2][3]=3 , dp[3][5]=4 , dp[5][8]=5；
        int max = 0;
        for (int i = 2; i < n; i++) {
            int j = 0, k = i-1;
            //j k 为双指针，
            while (j<k){
                if (arr[j] + arr[k] == arr[i]){
                    //找到
                    if (dp[j][k] == 0){//如果j和k，j之前的长度为0，
                        dp[k][i] = 3;//至少有三个元素了，k和i有3的长度
                        //两个前置元素j、k之前并没有形成斐波那契子数列（即dp[j][k]==0），
                        // 那就将当前位置存储的斐波那契数列长度dp[k][i]修改为3
                    }else {
                        //如果前置元素j、k之前作为某个斐波那契数列的最后两位元素存在
                        // （即dp[j][k]==n，n>=3）
                        dp[k][i] = Math.max(dp[j][k]+1,dp[k][i]);
                        //将当前位置存储的斐波那契数列长度dp[k][i]修改为 n+1 ，
                    }
                    max = Math.max(max,dp[k][i]);
                    j++;k--;
                }else if (arr[j] + arr[k] < arr[i]){
                    j++;
                }else
                    k--;
            }
        }
        return max;

    }
}
```



### [剑指 Offer II 092. 翻转字符](https://leetcode.cn/problems/cyJERH/)

2

如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是 **单调递增** 的。

我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 s，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。

返回使 s **单调递增** 的最小翻转次数。

 

**示例 1：**

```
输入：s = "00110"
输出：1
解释：我们翻转最后一位得到 00111.
```

```java
class Solution {
    public int minFlipsMonoIncr(String s) {
        if(s.length() < 2){
            return 0;
        } // 前一位反转成0的最小值和前一位反转成1的最小值
         int [][] dp = new int[s.length()][2];
        if (s.charAt(0)=='1'){
            dp[0][0] = 1;//第一个为1的话，他反转成零就需要变动一下，所以是一，
          		//但如果他反转成一的话，就不用动，所以就最小值变动次数为零
            dp[0][1] = 0;
        }else {
            dp[0][0] = 0;
            dp[0][1] = 1;
        }
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i)=='1'){
                dp[i][0] = dp[i-1][0]+1;//前一个是0的时候，就得多翻一个
                dp[i][1] = Math.min(dp[i-1][0],dp[i-1][1]);
            }else {
                //当前位置为0 的时候。如果前一个为0，那么就不需要变，
//                前一个为1，需要加一
                dp[i][0] = dp[i-1][0];
                dp[i][1] = Math.min(dp[i-1][1],dp[i-1][0])+1;
            }
        }
        return Math.min(dp[s.length()-1][0],dp[s.length()-1][1]);
    }
}
```



### [44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2：**

```
输入：s = "aa", p = "*"
输出：true
解释：'*' 可以匹配任意字符串。
```



```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        s = " "+s;//char数组就是从1开始的了
        p = " "+p;
        char[] chars = s.toCharArray();
        char[] charp = p.toCharArray();
        //动态规划，dp(i,j)就是1到i的字符和p的1到j的字符是否匹配
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0]=true;
        for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (charp[j]=='*'){
                    //如果p的此处为*，那么
                    dp[i][j] = dp[i][j-1] || (i-1>=0 && dp[i-1][j]);
                    //此时dp[i][j] 可以是由 dp[i][j-1]匹配传递来 或者(i-1>=0 && dp[i-1][j]);
                    
                }else {
                    dp[i][j] = i-1>=0 
                        && dp[i-1][j-1] && (chars[i]==charp[j] 
                                            || charp[j]=='?');
                // ? 匹配的条件是前面的字符匹配，s 中的第 i 个字符可以是任意字符。
                //   匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。
                }
            }
        }
        return dp[m][n];
    }
}
```



### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)



给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```



```java
class Solution {
    public int minDistance(String word1, String word2) {
        //Dynamic Plan
        //二维数组，dp[i][j] 表示前i个word1转化成前j个word2的最少的操作数
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i <= n; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <=m ; i++) {
            for (int j = 1; j <= n; j++) {
                //开始比较了
                if (word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else {
                    //如果是删除i的话：dp[i][j] = dp[i-1][j]+1；
                  //这个增加其实就是两个单词反过来操作的结果，第一个单词增加一个元素变成第二个，
                  //实际上就是第二个元素删除一个元素变成第一个，他们两个的操作步骤次数是一样的。
                    //如果是增加的话：dp[i][j] = dp[i][j-1]+1；
                    //如果是替换那就是dp[i][j] = dp[i-1][j-1]+1;
                    dp[i][j] = Math.min( dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
                }
            }
        }
        return dp[m][n];
    }
}
```

### 718. 最长重复子数组

[力扣题目链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入：

* A: [1,2,3,2,1]
* B: [3,2,1,4,7]
* 输出：3
* 解释：长度最长的公共子数组是 [3, 2, 1] 。

提示：

* 1 <= len(A), len(B) <= 1000
* 0 <= A[i], B[i] < 100

**思路**

注意题目中说的子数组，其实就是连续子序列。

要求两个数组中最长重复子数组，如果是暴力的解法 只需要先两层for循环确定两个数组起始位置，然后再来一个循环可以是for或者while，来从两个起始位置开始比较，取得重复子数组的长度。 

本题其实是动规解决的经典题目，我们只要想到 **用二维数组可以记录两个字符串的所有比较情况，**这样就比较好推 递推公式了。 
动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]` ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。  （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

此时细心的同学应该发现，那`dp[0][0]`是什么含义呢？总不能是以下标-1为结尾的A数组吧。

其实`dp[i][j]` 的定义也就决定着，我们在遍历`dp[i][j]` 的时候i 和 j都要从1开始。

那有同学问了，我就定义`dp[i][j]` 为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？

行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分，在本题解下面的拓展内容里，我给出了 第二种 dp数组的定义方式所对应的代码和讲解，大家比较一下就了解了。 

2. 确定递推公式

根据`dp[i][j]` 的定义，`dp[i][j]` 的状态只能由dp[i - 1][j - 1]推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j]`  = dp[i - 1][j - 1] + 1;

根据递推公式可以看出，遍历i 和 j 要从1开始！

3. dp数组如何初始化

根据`dp[i][j]` 的定义，dp[i][0] 和`dp[0][j]`其实都是没有意义的！

但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式`dp[i][j]`  = dp[i - 1][j - 1] + 1;

所以dp[i][0] 和dp[0][j]初始化为0。

举个例子A[0]如果和B[0]相同的话，dp[1][1] = dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。


4. 确定遍历顺序

外层for循环遍历A，内层for循环遍历B。

那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？

也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。

同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]` 的最大值记录下来。



代码如下：

```CPP
for (int i = 1; i <= nums1.size(); i++) {
    for (int j = 1; j <= nums2.size(); j++) {
        if (nums1[i - 1] == nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        if (dp[i][j] > result) result = dp[i][j];
    }
}

```


5. 举例推导dp数组

拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：


![718.最长重复子数组](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg)



```CPP
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[][] dp = new int[n1 + 1][n2 + 1];//dp存储相同的长度
        //以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
        int count = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <=nums2.length ; j++) {
                if (nums1[i-1]==nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                if (dp[i][j]>count) count = dp[i][j];
            }
        }
        return count;
    }
}
```

* 时间复杂度：O(n × m)，n 为A长度，m为B长度
* 空间复杂度：O(n × m)



打家劫舍：

### 198.打家劫舍

[力扣题目链接](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

* 示例 1：
* 输入：[1,2,3,1]
* 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

* 示例 2：
* 输入：[2,7,9,3,1]
* 输出：12
  解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
       偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

* 0 <= nums.length <= 100
* 0 <= nums[i] <= 400



决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);



```java
class Solution {
    public int rob(int[] nums) {
        //打家劫舍
        //dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        int[] dp = new int[nums.length];
        if (nums.length==1) return nums[0];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
}
```



### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

**动态规划**
s 串能否分解为单词表的单词（前 s.length 个字符的 s 串能否分解为单词表单词）
将大问题分解为规模小一点的子问题：
前`i`个字符的子串，能否分解成单词
剩余子串，是否为单个单词。
`dp[i]`：长度为i的`s[0:i-1]`子串是否能拆分成单词。题目求:`dp[s.length]`

![image.png](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/70b0957d0086f43cd56b9e311e03deed4e9a77be0ae40ccbaa2f2b006d7caeb5-image.png)

**状态转移方程**
类似的，我们用指针 `j` 去划分`s[0:i]` 子串如下图：
`s[0:i]` 子串对应 `dp[i+1]` ，它是否为 true（`s[0:i]`能否 break），取决于两点：
它的前缀子串 `s[0:j-1]` 的 `dp[j]`，是否为 true。
剩余子串 `s[j:i]`，是否是单词表的单词。

![image.png](https://fastly.jsdelivr.net/gh/52chen/imagebed2023@main/uPic/bcef185f09c72fb525855bd56155f4658793d86b0dc4f3de31cace6bd9398c5b-image.png)

**base case**
base case 为`dp[0] = true`。即，长度为 0 的`s[0:-1]`**能**拆分成单词表单词。
这看似荒谬，但这只是为了让边界情况也能套用状态转移方程，而已。
当 j = 0 时（上图黄色前缀串为空串），`s[0:i]`的`dp[i+1]`，取决于`s[0:-1]`的`dp[0]`，和，剩余子串`s[0:i]`是否是单个单词。
只有让`dp[0]`为真，`dp[i+1]`才会只取决于`s[0:i]`是否为单个单词，才能用上这个状态转移方程。



```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        //dp[i]：长度为i的s[0:i-1]子串是否能拆分成单词。
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0]=true;
        for (int i = 1; i < n + 1; i++) {
            for (int j = i-1; j >=0; j--) {
                String suffix = s.substring(j, i);//后缀部分
                if (wordDict.contains(suffix)&&dp[j]){
                    dp[i]=true;
                    break;//如果找到了就退出
                }
            }
        }
        return dp[n];
    }
}
```

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```



- **状态定义：**

- - *dp*[*i*] 的值代表 nums 以 *nums*[*i*] 结尾的最长子序列长度。

- **转移方程：** 设 *j*∈[0,*i*)，考虑每轮计算新 *dp*[*i*] 时，遍历 [0,*i*) 列表区间，做以下判断：

- - **当** *nums*[*i*]>*nums*[*j*] **时：** *nums*[*i*] 可以接在 *nums*[*j*] 之后（此题要求严格递增），此情况下最长上升子序列长度为 *dp*[*j*]+1 ；
  - **当** *nums*[*i*]<=*nums*[*j*] **时：** *nums*[*i*] 无法接在 *nums*[*j*] 之后，此情况上升子序列不成立，跳过。
  - 上述所有 **1.** **情况** 下计算出的 *dp*[*j*]+1 的最大值，为直到 *i* 的最长上升子序列长度（即 *dp*[*i*] ）。实现方式为遍历 *j* 时，每轮执行 *dp*[*i*]=*max*(*dp*[*i*],*dp*[*j*]+1)。
  - **转移方程：** dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。

- **初始状态：**

- - *dp*[*i*] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。

- **返回值：**

- - 返回 *dp* 列表最大值，即可得到全局最长上升子序列长度。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length==0) return 0;
        int[] dp = new int[nums.length + 1];
        Arrays.fill(dp,1);//每一个都是自己给自己递增的都是 1
        int maxSize=0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                //遍历从0到i，如果有nums[j]<nums[i]
                //dp[i]=math.max(dp[i]+dp[j]+1);
                //也就是上一个的dp[j]加上当前位置，这就是地推
                if (nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            maxSize=Math.max(maxSize,dp[i]);
        }
        return maxSize;
    }
}
```



### [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

 

**示例 1：**

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**示例 2：**

```
输入：triangle = [[-10]]
输出：-10
```

 

**提示：**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-104 <= triangle[i][j] <= 104`

 

状态定义：`dp[i][j]`表示包含第i行第j列元素的最小路径和

状态分析

1. 初始化：
   `dp[0][0]=triangle[0][0]`
2. 常规：
   `triangle[i][j]`一定会**经过**`triangle[i-1][j]`或者`triangle[i-1][j-1]`,
   所以状态`dp[i][j]`一定等于`dp[i-1][j]`或者`dp[i-1][j-1]`的最小值+`triangle[i][j]`
3. 特殊：
   ` triangle[i][0]`没有左上角 只能从`triangle[i-1][j]`经过
   `triangle[i][row[0].length]`没有上面 只能从`triangle[i-1][j-1]`经过

转换方程：`dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]`



```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        //dp[i][j]表示i和j位置的最小的路径之和
        int size = triangle.size();
        int[][] dp = new int[size + 1][size + 1];
        dp[0][0]=triangle.get(0).get(0);
//        if (size==1) return dp[0][0];
        for (int i = 1; i < size; i++) {
            for (int j = 0; j <= i; j++) {
                if (j==0){
                    // triangle[i][0]没有左上角
                    dp[i][0]=dp[i-1][0]+triangle.get(i).get(0);
                } else if (j == i) {
                    //triangle[i][row[0].length]没有上面
                    dp[i][i]=dp[i-1][i-1]+triangle.get(i).get(i);
                }else {
                    //dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]
                    dp[i][j]=Math.min(dp[i-1][j],dp[i-1][j-1])+triangle.get(i).get(j);
                }
            }
        }
        int minPath = Integer.MAX_VALUE;
        for (int i = 0; i < size; i++) {
            minPath=Math.min(minPath,dp[size-1][i]);
        }
        return minPath;
    }
}
```

### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

 

**示例 1：**



![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)



```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

理解 min(上, 左, 左上) + 1

如题，在其他动态规划方法的题解中，大都会涉及到下列形式的代码：

- []

```Java
// 伪代码
if (matrix(i - 1, j - 1) == '1') {
    dp(i, j) = min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1;
}
```

其中，`dp(i, j)` 是以 `matrix(i - 1, j - 1)` 为 **右下角** 的正方形的最大边长。(感谢 [@liweiwei1419]() 提出补充)
等同于：`dp(i + 1, j + 1)` 是以 `matrix(i, j)` 为右下角的正方形的最大边长

翻译成中文

> 若某格子值为 `1`，则以此为**右下角**的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格。

先来阐述简单共识

- 若形成正方形（非单 `1`），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 `1`
- 可以换个角度：当前格、上、左、左上都不能受 `0` 的限制，才能成为正方形

![image.png](https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png)

上面详解了 三者取最小 的含义：

- 图 1：受限于左上的 0
- 图 2：受限于上边的 0
- 图 3：受限于左边的 0
- 数字表示：以此为正方形右下角的最大边长
- 黄色表示：格子 `?` 作为右下角的正方形区域

就像 **[木桶的短板理论](https://baike.baidu.com/item/短板理论)** 那样——附近的最小边长，才与 `?` 的最长边长有关。
此时已可得到递推公式

- []

```Java
// 伪代码
if (grid[i - 1][j - 1] == '1') {
    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
}
```

从感性理解，到代码实现

- 从上述图解中，我们似乎得到的只是「动态规划 **推进** 的过程」，即「如何从前面的 `dp` 推出后面的 `dp`」，甚至还只是感性理解
- 距离代码我们还缺：`dp` 具体定义如何，数组多大，初值如何，如何与题目要求的面积相关
- `dp` 具体定义：`dp[i + 1][j + 1]` 表示 「以第 `i` 行、第 `j` 列为右下角的正方形的最大边长」



- 为何不是 `dp[i][j]`

- 回到图解中，任何一个正方形，我们都「依赖」**当前格** 左、上、左上三个方格的情况

- 但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 `if` 判断来处理

- 为了代码简洁，我们 **假设补充** 了多一行全 `'0'`、多一列全 `'0'`

- ![image.png](https://pic.leetcode-cn.com/035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png)

- 此时 `dp` 数组的大小也明确为 `new dp[height + 1][width + 1]`

- 初始值就是将第一列 `dp[row][0]` 、第一行 `dp[0][col]` 都赋为 `0`，相当于已经计算了所有的第一行、第一列的 `dp` 值

- 题目要求面积。根据 「面积 = 边长 x 边长」可知，我们只需求出最大边长

  即可

  - 定义 `maxSide` 表示最长边长，每次得出一个 `dp`，就 `maxSide = max(maxSide, dp);`
  - 最终返回 `return maxSide * maxSide;`



```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix==null||matrix.length<1||matrix[0].length<1) return 0;
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m + 1][n + 1];
        int maxSize = 0;
        //dp就是木桶效应，选择左边，左上，和上边三个最小的那个再加上1，
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j]=='1'){
                    dp[i+1][j+1]=Math.min(Math.min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1;
                    maxSize=Math.max(maxSize,dp[i+1][j+1]);
                }
            }
        }
        return maxSize*maxSize;
    }
}
```





### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        //得买两笔，不能同时买
        int[][] dp = new int[prices.length][5];
        //初始化dp
        dp[0][0]=0;//不操作;
        dp[0][1]=-prices[0];//第一次持有;
        dp[0][2]=0;//第一次卖出;
        dp[0][3]=-prices[0];//第二次买入
        dp[0][4]=0;//第二次卖出;
        for (int i = 1; i < prices.length; i++) {
            dp[i][1]=Math.max(dp[i-1][1],dp[i][0]-prices[i]);//不持有到持有
            dp[i][2]=Math.max(dp[i-1][2],dp[i][1]+prices[i]);//
            dp[i][3]=Math.max(dp[i-1][3],dp[i][2]-prices[i]);//
            dp[i][4]=Math.max(dp[i-1][4],dp[i][3]+prices[i]);//
        }
        return dp[prices.length-1][4];
    }
}
```



### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)



给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```



```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        //k笔的话，就是2k大小的dp
        int[][] dp = new int[prices.length][2 * k + 1];
        for (int i = 0; i < (2 * k + 1); i++) {
            if (i%2==1){
                //奇数的话就等于price[0];
                dp[0][i]=-prices[0];
            }
        }
        for (int i = 1; i < prices.length; i++) {
            for (int j = 1; j < (2 * k + 1); j++) {
                if (j%2==1){
                    //奇数的话就是要持有;
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]-prices[i]);
                }else {
                    //偶数的话就是要卖;
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]+prices[i]);
                }
            }
        }
        return dp[prices.length-1][2 * k];
    }
}
```



## 背包算法:baggage_claim:



![416.分割等和子集1](https://cdn.jsdelivr.net/gh/52chen/imagebed2023@main/picgo/20210117171307407-20230310132423205.png)

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```CPP
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**完全背包的模版**：



```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```



### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 

问装满背包所有物品的最小个数：dp[j] =  min(dp[j - coins[i]] + 1, dp[j]); 

### 遍历顺序

### 01背包

二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

一维dp数组01背包**只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历**。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

举例：

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if (sum%2==1) return false;
        int target = sum/2;
        //动态规划 1/背包问题，能不能找到target大小的元素
        // dp[i] = dp[i-nums[j]]
        boolean[] dp = new boolean[target + 1];
        //先遍历物品，再遍历背包，
        dp[0] = true;
        for (int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = dp[j]||dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}
}
```



#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```



1. 确定dp数组以及下标的含义

**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。

可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。

相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”

2. 确定递推公式

01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

本题则是：**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。

大家可以再去看 dp[j]的含义。

最后dp[target]里是容量为target的背包所能背的最大重量。

那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。

那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。



```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        //粉碎石头，其实就是看两个能不能各分一半
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int target = sum/2; // if achieved target，then result is zero;
        //dp表示装满容量为i的背包所能装的最大的价值也就是重量；
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-2*dp[target];//taget容量的背包最多能装下的
        //一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。
        //那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。
    }
}
```

> 本题其实和**[416. 分割等和子集]**几乎是一样的，只是最后对dp[target]的处理方式不同。
>
> **<u>*[416. 分割等和子集]*</u>**相当于是求背包是否正好装满，而本题是求背包最多能装多少。



#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 01 背包，dp表示放到正数的一遍的方法，
        // p+d=s; p-d = t; p = s+t /2;
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        //如果二者相加小于0，显然是不行的
        if ((sum+target)%2==1 ||(sum+target)/2<0) return 0;
        int plus = (sum+target)/2;
        int[] dp = new int[plus + 1];
        dp[0] =1;
        //找到和为plus的树木有多少种，装满这个plus的背包
        for (int i = 0; i < nums.length; i++) {
            for (int j = plus; j >=nums[i] ; j--) {
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[plus];
    }
}
```







### 完全背包

纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是**纯完全背包**的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。也就是不同的排序都算做新的方法就是求排列数

相关题目如下：

#### [剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/)



给定一个由 **不同** 正整数组成的数组 `nums` ，和一个目标整数 `target` 。请从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```sh
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合
```

dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。 

其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。 

如果数组[0] ，target = 0，那么 bagSize =  (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。 

所以本题我们应该初始化 dp[0] 为 1。

可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。 

其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。 

dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。



```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
//        背包问题，背包总的只能装target大小的东西
//        顺序可以作为不同的组合dp[j] +=dp[j-nums[i]];
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //完全背包（可以重复使用），求排列数（不同的排序都算方法）
        for (int i = 1; i <= target; i++) {
            // 先遍历背包，因为这个容器背包是1的时候，可以每一个nums都去遍历所以是组合
            // 如果先去遍历物品，也就是nums的时候，那不就是没有顺序l
            for (int j = 0; j < nums.length; j++) {
                if (nums[j]<=i){
                    dp[i] += dp[i-nums[j]];
                }
            }
        }
        return dp[target];

    }
}
```

#### [剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/)



给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //无线硬币就是完全背包，组合数首先遍历物品，再遍历背包
        int[] dp = new int[amount + 1];
       //完全背包（可以重复使用），求组合（不同的排序不算方法）
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if(dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
                }//最小的数
            }
        }
        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```

## Kadane’s Algorithm / Kadene算法

计算机历史上有一个非常经典的问题叫做Maximum-Subarray-Problem， 求数组的最大子序列，要求该子序列和为最大值，子序列应当连续。

比如 [−2, 1, −3, 4, −1, 2, 1, −5, 4]， 最大应该子序列为 [4, −1, 2, 1]。

暴力的解法是算出所有的子序列，然后求和，该方法的时间复杂度为O(n^2).

Kadane’s Algorithm是求解该类问题的一个通法，原理是利用Dynamic Programming保存所有以i结尾的子序列的最大长度，dp公式为:

如果以i - 1为结尾的子序列最大值为负，那么不管怎么样，dp[i]就应该从头开始计数，因为前面的子序列已经不再有影响了(dp[i - 1] + nums[i]必然小于nums[i])

Leetcode里有两道经典的题目，用到了这个算法，分别为Leetcode53和Leetcode1186，Leetcode 53是这一算法的直接运用，代码如下：

```java
public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int res = dp[0];
    for(int i = 1; i < nums.length; i++){
      //如果前面的比0小，直接就不去取了
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        res = Math.max(dp[i], res);
    }
    return res;  
}
```



> LeetCode 1186
>
> 给你一个整数数组，返回它的某个 **非空** 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。
>
> 注意，删除一个元素后，子数组 **不能为空**。
>
> 
>
> **示例 1：**
>
> ```sh
> 输入：arr = [1,-2,0,3]
> 输出：4
> 解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
> ```

Leetcode 1186是一个变式，基本思路不变，不过我们可以选择是否删除删除一个元素，显然，如果遇到负数，我们可以考虑将其删除，然后计算两头，对于第i个数字，如果它是负数，则计算**以i - 1为结尾的最大子序列**和以**i + 1为开头的最大子序列**，我们分别用dp1，dp2存储这两种状态，原理依旧是Kadane’s Algorithm。

> 从两头开始，分别算好，如果里面有负数，再去计算负数导致的可能存在的删除某个元素的情况。

```java
public int maximumSum(int[] arr) {
    int[] dp1 = new int[arr.length];
    int[] dp2 = new int[arr.length];
    dp1[0] = arr[0];
    int res = arr[0];
    for(int i = 1; i < arr.length; i++){
        dp1[i] = Math.max(dp1[i - 1], 0) + arr[i];
        res = Math.max(res,dp1[i]);
    }
    dp2[arr.length - 1] = arr[arr.length - 1];
    for(int i = arr.length - 2; i > -1; --i){
        dp2[i] = Math.max(dp2[i + 1], 0) + arr[i];
    }
    
    for(int i = 1; i < arr.length - 1; i++){
        if(arr[i] < 0)
            res = Math.max(dp1[i - 1] + dp2[i + 1], res);
    }

    return res;
}
```

> 我的：
>
> ```java
> class Solution {
>     public int maximumSum(int[] arr) {
>         int[] dp1 = new int[arr.length];//存储从头开始的连续最大和
>         int[] dp2 = new int[arr.length];//存储从尾开始的连续最大和
>         int max = arr[0];
>         dp1[0]=arr[0];
>         for (int i = 1; i < arr.length; i++) {
>             dp1[i]=Math.max(dp1[i-1],0)+arr[i];
>             max = Math.max(max,dp1[i]);
>         }
>         System.out.println("dp1 = " + Arrays.toString(dp1));
>         dp2[arr.length-1]=arr[arr.length-1];//最后一个位置赋值
>         for (int i = arr.length-2; i >0; i--) {
>             dp2[i]=Math.max(dp2[i+1],0)+arr[i];
>             max = Math.max(max,dp2[i]);
>         }
>         System.out.println("dp2 = " + Arrays.toString(dp2));
>         for (int i = 1; i < arr.length-1; i++) {
>             if (arr[i]<0){
>                 max=Math.max(dp1[i-1]+dp2[i+1],max);
>             }
>         }
>         return max;
>     }
> }
> ```
>
> 

## 并查集 

```CPP
    int n = 1005; // 根据题意而定 
    int father[1005];

    // 并查集初始化
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
```

## 滑动窗口

在 Java 中，可以通过双指针的方式来实现滑动窗口算法，这里给出一个示例代码：

```java
public int slidingWindow(int[] nums, int target) {
    int left = 0, right = 0;
    int sum = 0, minLen = Integer.MAX_VALUE;

    while (right < nums.length) {
        sum += nums[right];

        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }

        right++;
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```



以上代码实现了一个求取数组中最短连续子数组长度的问题，其时间复杂度为 $O(n)$，其中 `left` 和 `right` 分别代表滑动窗口的左右指针，`sum` 为滑动窗口中元素之和，`minLen` 为最短连续子数组的长度。

在双指针算法中，常常需要使用嵌套循环，其中外层循环为右指针移动，内层循环为左指针移动，直到找到符合要求的结果。在内循环中，要注意移动左指针时的细节处理，此外还需要注意边界条件控制。



### 双指针



判断回文数

```java
boolean isPali(String s,int begin,int end) {
    for (int i = begin, j = end; i < j; i++, j--) {
        if (s.charAt(i)!=s.charAt(j))
            return false;
    }
    return true;
}
```



**判断回文串时，允许删除 1 个字符。**

给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。



**示例 1:**

```
输入: s = "aba"
输出: true
```



也就是说，在双指针相向遍历时，当

s[left]\\=s[right]

我们**有且仅有一次**跳过的机会：

- 可以跳过 left 指针指向的元素，继续 [left+1⟶,right⟵]；
- 也可以跳过 right 指针指向的元素，继续 [left⟶,right−1⟵]。

两种情况中，只要有一个判定被为回文串，那么 s 就是合法的回文串。



```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length()-1;
        while (left<right){
            if (s.charAt(left)!=s.charAt(right)){
                return validSub(s,left+1,right) || validSub(s,left,right-1);
            }else {
                left++;
                right--;
            }

        }
        return true;
    }
    boolean validSub(String s,int left,int right) {
        while (left<right){
            if (s.charAt(left)!=s.charAt(right))
                return false;
            left++;
            right--;
        }
        return true;
    }
}
```



### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

难度简单3158收藏分享切换为英文接收动态反馈

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。



```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //返回不重复的部分的长度，就是可以把重复的放在最后
        int slow = 0;//最后返回这个就可以了
        int fast = 1;
        while (fast<nums.length){
            //fast在前面标记为可以交换的元素
            if (nums[slow] == nums[fast])
                fast++;
            else {//找到不一样的之后再进行slow前进
                slow++;
                nums[slow]=nums[fast];
                fast++;
            }
        }
        return slow+1;
    }
}
```





### 统计连续子数组个数

给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。



**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

**示例 2:**

```
输入: nums = [1,2,3], k = 0
输出: 0
```



**提示:**

- `1 <= nums.length <= 3 * 104`
- `1 <= nums[i] <= 1000`
- `0 <= k <= 106`



注意：本题与主站 713 题相同：https://leetcode-cn.com/problems/subarray-product-less-than-k/

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        //滑动窗口
        //使用一个变量 cur 记录当前窗口的乘积，使用两个变量 j 和 i 分别代表当前窗口的左右端点。
        int len = nums.length;
        int ans = 0;
        if (k<=1) return 0;
        for (int i = 0, j = 0, cur = 1; i < len; i++) {
            cur*=nums[i];
            // 当 cur>=k 时，我们考虑将左端点 j 右移，同时消除原来左端点元素 nums[j] 对 cur 的贡献，
            // 直到 cur>=k 不再满足，这样我们就可以得到每个右端点 nums[i] 的最远左端点 nums[j]
            while (cur>=k) cur/=nums[j++];
            ans+=i-j+1;
        }
        return ans;
        //请找出该数组内乘积小于 k 的连续的子数组的个数。
    }
}
```



### offer || 014 是否包含 `s1` 的某个变位词。

给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。



**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```



**提示：**

- `1 <= s1.length, s2.length <= 104`
- `s1` 和 `s2` 仅包含小写字母



注意：本题与主站 567 题相同： https://leetcode-cn.com/problems/permutation-in-string/



```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        int[] list1 = new int[26];
        int[] list2 = new int[26];
        if (l2<l1) return false;
        //// 同时填充两个字符表，其中alpha1填充完毕，alpha2只填充了前面一部分。
        for (int i = 0; i < l1; i++) {
            list1[s1.charAt(i)-'a']++;
            list2[s2.charAt(i)-'a']++;
        }
        if (Arrays.equals(list1,list2)) return true;
        for (int i = l1; i < l2; i++) {
            //窗口右边新来的加加
//            窗口左边要排除的渐渐
            list2[s2.charAt(i)-'a']++;
            list2[s2.charAt(i-l1)-'a']--;//注意这里，因为有i-li所以要额外写一个遍历
            // 判断当前状态下，s2窗口中的字符是否和s1的字符种类和数量都一致。
            // Arrays.equals() 是通过遍历判断的，自己些for也一样。
            if (Arrays.equals(list2,list1)) return true;
        }
        return false;
    }
}
```





### 滑动窗口统计变位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。



**示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (p.length()>s.length()) return ans;
        int[] listp = new int[26];
        int[] lists = new int[26];
        for (int i = 0; i < p.length(); i++) {
            listp[p.charAt(i)-'a']++;
            lists[s.charAt(i)-'a']++;
        }

        if (Arrays.equals(listp,lists)) ans.add(0);
        for (int i = p.length(); i < s.length(); i++) {
            lists[s.charAt(i)-'a']++;
            lists[s.charAt(i-p.length())-'a']--;
            if (Arrays.equals(listp,lists)) ans.add(i-p.length()+1);
        }
        return ans;
    }
}
```

## 前缀和算法



### 和大于等于target的连续子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int left = 0;
        int right = 1;
        int res = Integer.MAX_VALUE;
        while (right<=nums.length) {
            if (preSum[right]-preSum[left]>=target){
                res = Math.min(right-left,res);
                left++;
                right=left;
            }else
                right++;

        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int[] preSum = new int[nums.length+1];
        preSum[0]=0;
        for (int i = 0; i < nums.length; i++) {
            preSum[i+1] = preSum[i]+nums[i];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= nums.length; i++) {
            // 前缀和数组下标 [0,i] 范围内找到满足「值小于等于 s−target」
            // 的最大下标，充当子数组左端点的前一个值。
            // 左边的范围小于等于，那么就是说preSum[i]-preSum[left]>=target
            int s = preSum[i],d = s-target;
            int left = 0, right = i;
            while (left<right){
                int mid = (left+right+1)>>1;
                if (preSum[mid]<=d) left=mid;//如果中间的前缀和小于需要的。
                else
                    right = mid -1;
            }
            if (preSum[right]<=d) res = Math.min(res,i-right);
        }
        if (res==Integer.MAX_VALUE){
            return 0;
        }else
            return res;
    }
}
```



### offer010 和为k的子数组个数

给定一个整数数组和一个整数 `k` **，**请找到该数组中和为 `k` 的连续子数组的个数。



**示例 1：**

```
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
```

**示例 2：**

```
输入:nums = [1,2,3], k = 3
输出: 2
```



**提示:**

- `1 <= nums.length <= 2 * 104`



统计以每一个 *n**u**m**s*[*i*] 为结尾，和为 *k* 的子数组数量即是答案。

我们可以预处理前缀和数组 `sum`（前缀和数组下标默认从 1 开始），对于求解以某一个 *n**u**m**s*[*i*] 为结尾的，和为 *k* 的子数组数量，本质上是求解在 [0,*i*] 中，`sum` 数组中有多少个值为 *s**u**m*[*i*+1]−*k* 的数，这可以在遍历过程中使用「哈希表」进行同步记录。

```JAVA
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length, ans = 0;
        int[] pre = new int[n+1];
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + nums[i];
        }
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        for (int i = 1; i <= n; i++) {
            int tmp = pre[i], d = tmp-k;//求解在 [0,i] 中，
            // pre 数组中有多少个值为 pre[i+1]−k 的数，
            ans+=map.getOrDefault(d,0);//看看有无目标的值
            map.put(tmp,map.getOrDefault(tmp,0)+1);
        }
        return ans;
    }
}
```



### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int len = nums.length;
        int ans = 0;
        int[] pre = new int[len + 1];
        HashMap<Integer, Integer> map = new HashMap<>();
        //「某个前缀和出现的最小下标」
        map.put(0,0);
        for (int i = 0; i < len; i++) {
            pre[i+1] = pre[i]+(nums[i]==0?-1:1);
            //将 nums[i] 为 0 的值当做 −1 处理。
        }
        for (int i = 1; i <= len; i++) {
            int t = pre[i];
            if (map.containsKey(t))
                // get(t)的目的是，是前缀和，所以找到相同的t的时候，
                // 区间之间长度就是0了
                ans = Math.max(ans,i-map.get(t));
//            每遍历一个元素，就用「当前前缀和」去前面已经统计的前缀和
//            中找到一个使得两者之间区间为0的，并计算这个区间长度
            else
                map.put(t,i);
        }
        return ans;
    }
}
```



### 二位前缀和子数组



给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回左上角 `(row1, col1)` 、右下角 `(row2, col2)` 的子矩阵的元素总和。

<img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img" style="zoom:50%;" />



```java
class NumMatrix {
    int[][] matrix = null;
    int[][] sum = null;
    public NumMatrix(int[][] matrix) {
        this.matrix=matrix;
        int m = matrix.length;
        int n = matrix[0].length;
        sum=new int[m +1][n +1];
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j < n; j++) {
                sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+matrix[i][j];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2+1][col2+1]-sum[row1][col2+1]-sum[row2+1][col1]+sum[row1][col1];
    }
}
```



## 算数运算

### 进位与非进位

设两数字的二进制形式 ,观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。



![Picture1.png](assets\56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png)





```java
// 设两数字的二进制形式a、b, 其求和s = a + b, a(i)代表a的二进制第i位, 则分为以下四种情况:
//   a(i)  b(i)  无进位和n(i) 进位c(i+1)
//    0     0         0           0
//    0     1         1           0
//    1     0         1           0 
//    1     1         0           1
// 
// 观察发现，无进位和与"异或运算"规律相同，进位和"与运算"规律相同(并需左移一位)
// 因此,无进位和n与进位c的计算公式如下:
//                                     n =  a ^ b         非进位和: 异或运算
//                                     c = (a & b) << 1    进位: 与运算+左移一位
// 因为 (和s) = (非进位和n) + (进位c) ，所以即可将 s = a + b 转化为 s = n + c ，即 s = a ^ b + (a & b) << 1
// 
// 采用递归思想: 虽然s = a + b = n + c，但是n + c还是用了'+'，因此我们对n + c再次采用这种运算 (也就是把n当成a，c当成b，继续做a+b运算。看似无限循环，但是进位c总会有等于0的时候，此时结果就等于n)
// 非递归同理，循环求n和c，直至进位c = 0; 此时s = n, 返回n即可。

class Solution {
    public int add(int a, int b) {
        // a的二进制表示与b的二进制，
        // 每一位取异或运算，得到无进位和的结果，每一位取与运算，左移<<一位，得到进位，
        // 不用担心整数转二进制，因为他就是默认就是二进制存取的直接去&就可以了
        while(b!=0){
            int c = (a&b)<<1;//进位，左移一位
            a = a ^ b;//非进位和
            b=c;//当进位为0的时候就可以不需要进位，直接非进位和就可以了
        }
        return a;
    }
}
```

### 不用除法的除法：倍增求解

给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。

返回被除数 dividend 除以除数 divisor 得到的 商 。

注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。



```java
class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        //返回完异常值
        //倍增法，每次减去一个2^x倍
        boolean sign = false;
        if((dividend>0&&divisor>0)||(dividend<0&&divisor<0))
            sign = true;//正数标记
        dividend = dividend > 0? -dividend:dividend;
        divisor = divisor > 0? -divisor:divisor;
        int ans = 0;
        //dividend / divisor
        while(dividend<=divisor){
            int tmp = divisor,count =1;
            //tmp + tmp >= dividend
            while(tmp>=dividend-tmp){
                tmp+=tmp;
                count+=count;
            }
            dividend = dividend - tmp;
            ans = ans+count;
        }
        return sign?ans:-ans;
    }
}


```



### 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数

```
如果我们是使用「朴素解法」求解的话，无论是从高位进行统计，还是从低位进行统计，最后一位扫描的都是边缘的数（如果是 1 就计数，不是 1 就不计数）。

从低位到高位，最后一步在扫描最高位之前，统计出 1 的个数应该等同于将 i 左移一位，并在最低位补 0，也就是等于 ans[i << 1]，这时候就要求我们在计算 i 的时候 i << 1 已经被算出来（从大到小遍历）
从高位到低位，最后一步在扫描最低位之前，统计出 1 的个数应该等同于将 i 右移一位，并在最高位补 0，也就是等于 ans[i >> 1]，这时候就要求我们在计算 i 的时候 i >> 1 已经被算出来（从小到大遍历）

```





```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for(int i=1;i<n+1;i++)
        //res[i] = 「i >> 1 所包含的 1 的个数」+「i 的最低位是否为 1」
            res[i] = res[i>>1] + (i&1);
        return res;
    }
}
```



### [剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,100]
输出：100
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

**进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

哈希表解法的空间复杂度是 *O*(*n*) 的，而题目的【进阶】部分提到应当使用常数空间来做。

其中一个比较容易想到的做法，是利用int类型固定为 32 位。

**使用一个长度为 32 的数组 cnt[] 记录下所有数值的每一位共出现了多少次 1，再对cnt[] 数组的每一位进行mod 3 操作，重新拼凑出只出现一次的数值。**

举个 🌰，考虑样例 `[1,1,1,3]`，1 和 3 对应的二进制表示分别是 `00..001` 和 `00..011`，存入 *c**n**t*[] 数组后得到 `[0,0,...,0,1,4]`。进行 *m**o**d* 3 操作后得到 `[0,0,...,0,1,1]`，再转为十进制数字即可得「只出现一次」的答案 3。

```java
class Solution {
    public int singleNumber(int[] nums) {
//        出现了三次，那么取模3，应该就是等于0；
        int[] cnt = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                if(((num>>i) & 1)==1){
                    cnt[i]++;
//                    如果当前元素右移i个单位是1的话，就在cnt加加
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i]%3==1)
//                mod 3 之后，其实也不会出现2，因为mod 3 就是去掉了重复3次的，
                ans+=(1<<i);
        }
        return ans;
    }
}
```





### [剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/)-位运算

给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。



**示例 1:**

```
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
```

根据题意进行模拟即可，利用每个 *w**or**d**s*[*i*] 只有小写字母，且只需要区分两字符是否有字母重复。

我们可以使用一个 `int` 来代指某个 *w**or**d*[*i*]：低 26 来代指字母 `a-z` 是否出现过。

然后对每个「字符对」所对应的两个 `int` 值执行 `&` 操作（若两字符无重复字符，则结果为 0），并得出最终答案。

位运算：比较两个字符串不相同

```java
class Solution {
    public int maxProduct(String[] words) {
//        位运算，进行&操作，如果两个字符有重复的字符马，那么就是1，无重复的就是0
        int length = words.length;
        int idx = 0;
        int[] masks = new int[length];
        for (String word : words) {
            int t = 0;
            for (int i = 0; i < word.length(); i++) {
                int u = word.charAt(i)-'a';
                t |= (1<<u);
            }
//            对每一个word进行或运算，计算1左移u位的，
//            则 abc 可以表示为 111 def 可以表示为 111000
            masks[idx++] = t;
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < i; j++) {
//         // 如果两个字符串不包含相同元素 那么与运算肯定为 0
                if ((masks[i]&masks[j])==0)
                    ans = Math.max(ans, words[i].length() * words[j].length());
            }
        }
        return ans;
    }
}
```



### [剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/)

难度中等61收藏分享切换为英文接收动态反馈

给定一个只包含整数的有序数组 `nums` ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

 

**示例 1:**

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0;
        
        int right = nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]==nums[mid^1]){
                left = mid+1;
                //如果mid是奇数，那么异或1的结果是mid-1；所以就相当于是比较mid和mid-1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；

                 //如果mid是偶数，那么异或1的结果是mid+1；所以就相当于是比较mid和mid+1是否是一样的
                // 由于前偶后奇相等，顺序是对的，所以缩小范围，left = mid+1；
            }else right = mid;
        }
        return nums[left];
    }
}
```



### [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

 

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

 



```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        String res = "0";
        for (int i = num2.length()-1; i >=0 ; i--) {
            int carry = 0;//纪录进位
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < num2.length()-1-i; j++) {
                sb.append(0);//sb是逆序的，因此，假如说是第2个num2的数字，那就是sb代表的数字要进10。
            }
            int n2 = num2.charAt(i)-'0';
            //num2的第i位数字与num1想成
            for (int j = num1.length()-1; j >=0 || carry!=0; j--) {
                int n1 = j<0?0:num1.charAt(j)-'0';
                int product = (n1*n2+carry)%10;
                sb.append(product);
                carry = (n1*n2+carry)/10;
            }
            res = addStrings(res,sb.reverse().toString());
        }
        return res;
    }
    private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
    }
}
```





### 实现两个字符串相加



```java
private String addStrings(String num1,String num2){
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for (int i = num1.length()-1,j = num2.length()-1;
             i >=0 || j>=0||carry!=0 ;
             i--,j--) {
            int x = i<0?0:num1.charAt(i)-'0';
            int y = j<0?0:num2.charAt(j)-'0';
            int sum = (x+y+carry)%10;
            sb.append(sum);
            carry = (x+y+carry)/10;
        }
        return sb.reverse().toString();
 }

```





### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

 

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```



```java
class Solution {
    public double myPow(double x, int n) {
        //快速幂，二进制
        //x^9 = (x^1) * (x^0*2) * (x^0*4) * (x^1*8)
        //就是9的二进制 1 0 0 1 然后乘以对应的2^(i-1)
        if (x == 0.0f) return 0.0d;
        long b = n;
        double res = 1.0;
        if (b < 0) {
            x = 1/x;
            b = -b;
        }
        //x^n = (x^2) ^ (n/2),将指数n除以二，如果是偶数则正常，如果是奇数，由于是向下取整，所以后面多乘以x
        while (b > 0) {
            if ((b&1) == 1) res *= x; //对b取余数，b%2 = b&1;
            //当 n 为奇数时，二分后会多出一项 x 。所以要多乘一次x
            x *= x;//x的平方
            b>>=1;
        }
        return res;
    }
}

```



### 66.加一



给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```



```    java
class Solution {
    public int[] plusOne(int[] digits) {
        int len = digits.length;
        for (int i = len -1; i >= 0; i--) {
            digits[i]++;
            digits[i]%=10;
            if (digits[i]!=0)
                return digits;
        }
        digits = new int[len+1];
//        for (int digit : digits) {
//            System.out.println(digit);//其实此时所有位置都是零了
//        }
        digits[0] = 1;
        return digits;
    }
}ƒ
```
